<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>celltraj.imageprep &mdash; celltraj 0.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../_static/documentation_options.js?v=a58bc63e"></script>
        <script src="../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            celltraj
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../readme.html">celltraj</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">celltraj</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">celltraj.imageprep</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for celltraj.imageprep</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">urllib.parse</span> <span class="kn">import</span> <span class="n">urlparse</span>
<span class="kn">import</span> <span class="nn">skimage.io</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">subprocess</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">color</span><span class="p">,</span> <span class="n">morphology</span>
<span class="kn">import</span> <span class="nn">skimage.transform</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">fourier_shift</span>
<span class="kn">import</span> <span class="nn">h5py</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="nn">scipy.optimize</span> <span class="kn">import</span> <span class="n">minimize</span>
<span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">watershed</span>
<span class="kn">from</span> <span class="nn">skimage.segmentation</span> <span class="kn">import</span> <span class="n">clear_border</span>
<span class="kn">from</span> <span class="nn">skimage.feature</span> <span class="kn">import</span> <span class="n">peak_local_max</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">skimage.filters</span> <span class="kn">import</span> <span class="n">threshold_local</span>
<span class="kn">import</span> <span class="nn">pyemma.coordinates.clustering</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">pystackreg</span> <span class="kn">import</span> <span class="n">StackReg</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">transform</span> <span class="k">as</span> <span class="n">tf</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">ndimage</span>
<span class="kn">from</span> <span class="nn">skimage.transform</span> <span class="kn">import</span> <span class="n">resize</span><span class="p">,</span><span class="n">rescale</span>
<span class="kn">import</span> <span class="nn">utilities</span>

<div class="viewcode-block" id="list_images">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.list_images">[docs]</a>
<span class="k">def</span> <span class="nf">list_images</span><span class="p">(</span><span class="n">imagespecifier</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Lists image files in a directory matching a specified pattern by executing a shell command.</span>
<span class="sd">    This function constructs a command to list files using Unix &#39;ls&#39; based on the given pattern,</span>
<span class="sd">    which includes both the path and the file matching pattern (e.g., &#39;/path/to/images/*.jpg&#39;).</span>
<span class="sd">    It then executes this command and parses the output to return a list of file names.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imagespecifier : str</span>
<span class="sd">        A string that specifies the directory and pattern to match for image files. </span>
<span class="sd">        This should be a path including a wildcard expression to match files, </span>
<span class="sd">        for example, &#39;/path/to/images/*.png&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        A list containing the names of files that match the specified pattern. If no files match,</span>
<span class="sd">        the list will be empty.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; image_files = list_images(&#39;/path/to/images/*.jpg&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(image_files)</span>
<span class="sd">    [&#39;image1.jpg&#39;, &#39;image2.jpg&#39;, ...]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function relies on the Unix &#39;ls&#39; command, which makes it platform-specific and not portable to Windows</span>
<span class="sd">      without modification.</span>
<span class="sd">    - The function requires that the shell used to execute commands has access to &#39;ls&#39;, which is typical for Unix-like</span>
<span class="sd">      systems.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    OSError</span>
<span class="sd">        If the &#39;ls&#39; command fails or the specified directory does not exist or cannot be accessed.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pCommand</span><span class="o">=</span><span class="s1">&#39;ls &#39;</span><span class="o">+</span><span class="n">imagespecifier</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">(</span><span class="n">pCommand</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">shell</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">err</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">communicate</span><span class="p">()</span>
    <span class="n">output</span><span class="o">=</span><span class="n">output</span><span class="o">.</span><span class="n">decode</span><span class="p">()</span>
    <span class="n">fileList</span><span class="o">=</span><span class="n">output</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">fileList</span><span class="o">=</span><span class="n">fileList</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fileList</span></div>


<div class="viewcode-block" id="organize_filelist_fov">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.organize_filelist_fov">[docs]</a>
<span class="k">def</span> <span class="nf">organize_filelist_fov</span><span class="p">(</span><span class="n">filelist</span><span class="p">,</span> <span class="n">fov_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">fov_len</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Organizes a list of image files by sorting them according to the field of view (FOV) identifier</span>
<span class="sd">    specified within each file name. This function is useful for grouping and sorting files that include</span>
<span class="sd">    a numeric FOV identifier at a known position within their names.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filelist : list of str</span>
<span class="sd">        A list containing file names to be organized.</span>
<span class="sd">    fov_pos : int, optional</span>
<span class="sd">        The position in the file name string where the FOV identifier begins. If not provided, the function</span>
<span class="sd">        will request this parameter explicitly.</span>
<span class="sd">    fov_len : int, optional</span>
<span class="sd">        The number of characters in the file name that make up the FOV identifier (default is 2).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        A list of file names sorted by their FOV identifiers in ascending order.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; filelist = [&#39;image_fov01.tif&#39;, &#39;image_fov02.tif&#39;, &#39;image_fov10.tif&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_files = organize_filelist_fov(filelist, fov_pos=11, fov_len=2)</span>
<span class="sd">    &gt;&gt;&gt; print(sorted_files)</span>
<span class="sd">    [&#39;image_fov01.tif&#39;, &#39;image_fov02.tif&#39;, &#39;image_fov10.tif&#39;]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function assumes that the FOV identifiers in the file names are numeric and located in a fixed position.</span>
<span class="sd">    - It is crucial to correctly specify `fov_pos` and `fov_len` to ensure files are correctly identified and sorted.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `fov_pos` is None, indicating the position of the FOV specifier was not set.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">fov_pos</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;please input the position of the field of view specifier&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">nF</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
    <span class="n">fovlist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nF</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nF</span><span class="p">):</span>
        <span class="n">fovstr</span><span class="o">=</span><span class="n">filelist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">fov_pos</span><span class="p">:</span><span class="n">fov_pos</span><span class="o">+</span><span class="n">fov_len</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ifov</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fovstr</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">numeric_filter</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="nb">str</span><span class="o">.</span><span class="n">isdigit</span><span class="p">,</span> <span class="n">fovstr</span><span class="p">)</span>
            <span class="n">fovstr</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">numeric_filter</span><span class="p">)</span>
        <span class="n">fovlist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">fovstr</span><span class="p">)</span>
    <span class="n">indfovs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">fovlist</span><span class="p">)</span>
    <span class="n">fovlist</span><span class="o">=</span><span class="n">fovlist</span><span class="p">[</span><span class="n">indfovs</span><span class="p">]</span>
    <span class="n">filelist_sorted</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nF</span><span class="p">):</span>
        <span class="n">filelist_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filelist</span><span class="p">[</span><span class="n">indfovs</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">filelist_sorted</span></div>


<div class="viewcode-block" id="organize_filelist_time">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.organize_filelist_time">[docs]</a>
<span class="k">def</span> <span class="nf">organize_filelist_time</span><span class="p">(</span><span class="n">filelist</span><span class="p">,</span> <span class="n">time_pos</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Organizes a list of image files by sorting them based on timestamps contained in the filenames.</span>
<span class="sd">    The expected timestamp format is &quot;??d??h??m&quot; (e.g., &quot;02d11h30m&quot; for 2 days, 11 hours, and 30 minutes).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filelist : list of str</span>
<span class="sd">        A list containing filenames to be organized, each containing a timestamp.</span>
<span class="sd">    time_pos : int, optional</span>
<span class="sd">        The starting position in the filename where the timestamp pattern begins. If None, the function</span>
<span class="sd">        searches for a timestamp anywhere in the filename.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of str</span>
<span class="sd">        A list of filenames sorted by their timestamps in ascending order.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; filelist = [&#39;image_02d11h30m.jpg&#39;, &#39;image_01d05h00m.jpg&#39;, &#39;image_03d12h15m.jpg&#39;]</span>
<span class="sd">    &gt;&gt;&gt; sorted_files = organize_filelist_time(filelist)</span>
<span class="sd">    &gt;&gt;&gt; print(sorted_files)</span>
<span class="sd">    [&#39;image_01d05h00m.jpg&#39;, &#39;image_02d11h30m.jpg&#39;, &#39;image_03d12h15m.jpg&#39;]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function converts each timestamp into seconds to compare and sort them effectively.</span>
<span class="sd">    - It is essential that the timestamp format strictly follows the &quot;??d??h??m&quot; pattern for correct processing.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If no timestamp can be found in a filename, or if `time_pos` is provided but incorrect, leading to</span>
<span class="sd">        unsuccessful timestamp parsing.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nF</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
    <span class="n">timelist</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nF</span><span class="p">)</span> <span class="c1">#times in seconds</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nF</span><span class="p">):</span>
        <span class="n">tpos</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s1">&#39;\d\dd\d\dh\d\dm&#39;</span><span class="p">,</span><span class="n">filelist</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
        <span class="n">timestamp</span><span class="o">=</span><span class="n">filelist</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">tpos</span><span class="o">.</span><span class="n">start</span><span class="p">():</span><span class="n">tpos</span><span class="o">.</span><span class="n">end</span><span class="p">()]</span>
        <span class="n">day</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">hour</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">3</span><span class="p">:</span><span class="mi">5</span><span class="p">])</span>
        <span class="n">minute</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">timestamp</span><span class="p">[</span><span class="mi">6</span><span class="p">:</span><span class="mi">8</span><span class="p">])</span>
        <span class="n">seconds</span><span class="o">=</span><span class="n">day</span><span class="o">*</span><span class="mi">86400</span><span class="o">+</span><span class="n">hour</span><span class="o">*</span><span class="mi">3600</span><span class="o">+</span><span class="n">minute</span><span class="o">*</span><span class="mi">60</span>
        <span class="n">timelist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">seconds</span>
    <span class="n">indtimes</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">timelist</span><span class="p">)</span>
    <span class="n">timelist</span><span class="o">=</span><span class="n">timelist</span><span class="p">[</span><span class="n">indtimes</span><span class="p">]</span>
    <span class="n">filelist_sorted</span><span class="o">=</span><span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nF</span><span class="p">):</span>
        <span class="n">filelist_sorted</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filelist</span><span class="p">[</span><span class="n">indtimes</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>
    <span class="k">return</span> <span class="n">filelist_sorted</span></div>


<div class="viewcode-block" id="znorm">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.znorm">[docs]</a>
<span class="k">def</span> <span class="nf">znorm</span><span class="p">(</span><span class="n">img</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs variance normalization (Z-normalization) on an input array or image, scaling it by its mean and standard</span>
<span class="sd">    deviation to achieve a mean of zero and a standard deviation of one. </span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The input array or image to be normalized. The input should be a real array where operations such as</span>
<span class="sd">        mean and standard deviation can be computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        The Z-normalized version of `img` where each element has been scaled by the mean and standard deviation</span>
<span class="sd">        of the original array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; img = np.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; normalized_img = znorm(img)</span>
<span class="sd">    &gt;&gt;&gt; print(normalized_img)</span>
<span class="sd">    [-1.41421356 -0.70710678  0.          0.70710678  1.41421356]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function handles NaN values in the input by ignoring them in the computation of the mean and</span>
<span class="sd">      standard deviation, which prevents NaN propagation but assumes NaNs are missing data points.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ZeroDivisionError</span>
<span class="sd">        If the standard deviation of the input array is zero.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">nanmean</span><span class="p">(</span><span class="n">img</span><span class="p">))</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">nanstd</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img</span></div>


<div class="viewcode-block" id="histogram_stretch">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.histogram_stretch">[docs]</a>
<span class="k">def</span> <span class="nf">histogram_stretch</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">lp</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">hp</span><span class="o">=</span><span class="mi">99</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Performs histogram stretching on an input array or image to enhance the contrast by scaling the pixel </span>
<span class="sd">    intensity values to the specified lower and upper percentile bounds. This method spreads out the most </span>
<span class="sd">    frequent intensity values, improving the perceptual contrast of the image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The input image or array to be processed. This array should contain real numbers.</span>
<span class="sd">    lp : float, optional</span>
<span class="sd">        The lower percentile to use for scaling the histogram. Default is 1, which uses the 1st percentile.</span>
<span class="sd">    hp : float, optional</span>
<span class="sd">        The upper percentile to use for scaling the histogram. Default is 99, which uses the 99th percentile.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        The histogram stretched version of `img` where pixel values are scaled between the values at the</span>
<span class="sd">        `lp` and `hp` percentiles.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; img = np.array([50, 100, 150, 200, 250])</span>
<span class="sd">    &gt;&gt;&gt; stretched_img = histogram_stretch(img, lp=10, hp=90)</span>
<span class="sd">    &gt;&gt;&gt; print(stretched_img)</span>
<span class="sd">    [ 0.   0.2  0.4  0.8  1. ]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function is useful for enhancing features in an image that are difficult to see due to poor </span>
<span class="sd">      contrast between high and low intensity.</span>
<span class="sd">    - If the specified percentiles result in a divide-by-zero (when `plow` is equal to `phigh`), the output </span>
<span class="sd">      will contain NaNs.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `lp` or `hp` are not within the range [0, 100] or if `lp` is greater than `hp`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">plow</span><span class="p">,</span> <span class="n">phigh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="p">(</span><span class="n">lp</span><span class="p">,</span> <span class="n">hp</span><span class="p">))</span>
    <span class="n">img</span><span class="o">=</span><span class="p">(</span><span class="n">img</span><span class="o">-</span><span class="n">plow</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">phigh</span><span class="o">-</span><span class="n">plow</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img</span></div>


<div class="viewcode-block" id="get_images">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_images">[docs]</a>
<span class="k">def</span> <span class="nf">get_images</span><span class="p">(</span><span class="n">filelist</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reads a list of image files and loads them into memory as arrays. This function is useful for batch processing </span>
<span class="sd">    images for analysis or input into machine learning models.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filelist : list of str</span>
<span class="sd">        A list containing the file paths of images to be loaded. Each element in the list should be a string</span>
<span class="sd">        specifying the full path to an image file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of ndarray</span>
<span class="sd">        A list of image arrays, where each array corresponds to an image file from `filelist`. The format and </span>
<span class="sd">        dimensions of each image array depend on the image file format and its content.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; filelist = [&#39;path/to/image1.jpg&#39;, &#39;path/to/image2.png&#39;]</span>
<span class="sd">    &gt;&gt;&gt; images = get_images(filelist)</span>
<span class="sd">    &gt;&gt;&gt; print(type(images[0]), images[0].shape)</span>
<span class="sd">    (&lt;class &#39;numpy.ndarray&#39;&gt;, (height, width, channels))</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function uses `skimage.io.imread` to load images, which supports various image formats including</span>
<span class="sd">      JPEG, PNG, and TIFF among others.</span>
<span class="sd">    - The function directly reads images into memory, which may consume a lot of resources for large image</span>
<span class="sd">      files or long lists of images.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    IOError</span>
<span class="sd">        If any file in the list cannot be opened or read. This could be due to the file not existing, being </span>
<span class="sd">        unreadable, or being corrupted.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">imgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">skimage</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">imread</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">filelist</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">imgs</span></div>


<div class="viewcode-block" id="get_tile_order">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_tile_order">[docs]</a>
<span class="k">def</span> <span class="nf">get_tile_order</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="p">,</span><span class="n">snake</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs an ordering matrix for assembling image tiles, often used to arrange microscope image tiles </span>
<span class="sd">    into a single large image. This function generates a 2D array where each element represents the </span>
<span class="sd">    positional index of a tile in a grid layout. The layout can be in a standard or snaked pattern.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nrows : int</span>
<span class="sd">        The number of rows in the tile grid.</span>
<span class="sd">    ncols : int</span>
<span class="sd">        The number of columns in the tile grid.</span>
<span class="sd">    snake : bool, optional</span>
<span class="sd">        If True, the order of tiles will alternate directions across rows to form a snaking pattern. </span>
<span class="sd">        Specifically, odd-numbered rows (0-indexed) will be flipped. Default is False, where tiles are </span>
<span class="sd">        ordered in a standard left-to-right, top-to-bottom pattern.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D array of integers, with each value representing the index of a tile. The dimensions of the </span>
<span class="sd">        array are determined by `nrows` and `ncols`.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; nrows = 3</span>
<span class="sd">    &gt;&gt;&gt; ncols = 4</span>
<span class="sd">    &gt;&gt;&gt; get_tile_order(nrows, ncols)</span>
<span class="sd">    array([[11, 10,  9,  8],</span>
<span class="sd">           [ 7,  6,  5,  4],</span>
<span class="sd">           [ 3,  2,  1,  0]])</span>

<span class="sd">    &gt;&gt;&gt; get_tile_order(nrows, ncols, snake=True)</span>
<span class="sd">    array([[11, 10,  9,  8],</span>
<span class="sd">           [ 4,  5,  6,  7],</span>
<span class="sd">           [ 3,  2,  1,  0]])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This ordering is particularly useful in scenarios where image tiles must be stitched together in a specific </span>
<span class="sd">      sequence to correctly reconstruct the original scene, such as in microscopy imaging where individual </span>
<span class="sd">      fields of view are captured in a grid pattern.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">image_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nrows</span><span class="o">*</span><span class="n">ncols</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">snake</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">rowv</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nrows</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">rowv</span><span class="o">%</span><span class="mi">2</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">image_inds</span><span class="p">[</span><span class="n">rowv</span><span class="p">,:]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">image_inds</span><span class="p">[</span><span class="n">rowv</span><span class="p">,:])</span>
    <span class="k">return</span> <span class="n">image_inds</span></div>


<div class="viewcode-block" id="get_slide_image">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_slide_image">[docs]</a>
<span class="k">def</span> <span class="nf">get_slide_image</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span><span class="n">nrows</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">ncols</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">image_inds</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">foverlap</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span><span class="n">histnorm</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a single composite image from a list of tiled images based on specified row and column </span>
<span class="sd">    information, overlap, and optional histogram normalization. This function is useful for reconstructing </span>
<span class="sd">    large images from smaller segmented parts, such as in digital microscopy or image stitching applications.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imgs : list of ndarray</span>
<span class="sd">        A list of 2D arrays, where each array is an image tile.</span>
<span class="sd">    nrows : int, optional</span>
<span class="sd">        The number of rows in the tiled image layout. If None, it is assumed that the tiling is square,</span>
<span class="sd">        and nrows is calculated as the square root of the number of images. Defaults to None.</span>
<span class="sd">    ncols : int, optional</span>
<span class="sd">        The number of columns in the tiled image layout. If None and nrows is also None, ncols is set to </span>
<span class="sd">        the same value as nrows, assuming a square layout. Defaults to None.</span>
<span class="sd">    image_inds : ndarray, optional</span>
<span class="sd">        A 2D array indicating the ordering of image tiles within the grid. If None, ordering is generated </span>
<span class="sd">        by `get_tile_order`. Defaults to None.</span>
<span class="sd">    foverlap : float, optional</span>
<span class="sd">        The fraction of overlap between adjacent images, expressed as a decimal between 0 and 1. Defaults to 0.</span>
<span class="sd">    histnorm : bool, optional</span>
<span class="sd">        If True, histogram stretching is applied to each tile before assembly to normalize contrast across </span>
<span class="sd">        the slide. Defaults to True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D array representing the assembled slide image from the given tiles.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; img_list = [np.random.rand(100, 100) for _ in range(16)]</span>
<span class="sd">    &gt;&gt;&gt; slide_image = get_slide_image(img_list, nrows=4, ncols=4, foverlap=0.1, histnorm=False)</span>
<span class="sd">    &gt;&gt;&gt; print(slide_image.shape)</span>
<span class="sd">    (370, 370)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function adjusts the position of each tile based on the overlap specified and stitches them together </span>
<span class="sd">      to form a larger image.</span>
<span class="sd">    - The images in `imgs` should be of the same dimensions. Variable dimensions across tiles may lead to </span>
<span class="sd">      unexpected results.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the dimensions of the tiles in `imgs` do not match or if the number of provided images does not </span>
<span class="sd">        fit the specified `nrows` and `ncols` layout.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nimg</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">nrows</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nrows</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">nimg</span><span class="p">))</span>
        <span class="n">ncols</span><span class="o">=</span><span class="n">nrows</span>
    <span class="n">nh_single</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">nv_single</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nfh</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">foverlap</span><span class="o">*</span><span class="n">nh_single</span><span class="p">))</span>
    <span class="n">nfv</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">foverlap</span><span class="o">*</span><span class="n">nv_single</span><span class="p">))</span>
    <span class="n">npixh</span><span class="o">=</span><span class="n">ncols</span><span class="o">*</span><span class="n">nh_single</span><span class="o">-</span><span class="nb">int</span><span class="p">((</span><span class="n">ncols</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nfh</span><span class="p">)</span>
    <span class="n">npixv</span><span class="o">=</span><span class="n">nrows</span><span class="o">*</span><span class="n">nv_single</span><span class="o">-</span><span class="nb">int</span><span class="p">((</span><span class="n">nrows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nfv</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">image_inds</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">image_inds</span><span class="o">=</span><span class="n">get_tile_order</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span><span class="n">ncols</span><span class="p">)</span>
    <span class="n">ws_img</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">npixv</span><span class="p">,</span><span class="n">npixh</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">im</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimg</span><span class="p">):</span>
        <span class="n">img</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">im</span><span class="p">]</span>
        <span class="n">ih</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">image_inds</span><span class="o">==</span><span class="n">im</span><span class="p">)[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">iv</span><span class="o">=</span><span class="p">(</span><span class="n">nrows</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">image_inds</span><span class="o">==</span><span class="n">im</span><span class="p">)[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ws_mask</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">npixv</span><span class="p">,</span><span class="n">npixh</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">lv</span><span class="o">=</span><span class="n">iv</span><span class="o">*</span><span class="p">(</span><span class="n">nv_single</span><span class="o">-</span><span class="n">nfv</span><span class="p">)</span>
        <span class="n">uv</span><span class="o">=</span><span class="n">lv</span><span class="o">+</span><span class="n">nv_single</span>
        <span class="n">lh</span><span class="o">=</span><span class="n">ih</span><span class="o">*</span><span class="p">(</span><span class="n">nh_single</span><span class="o">-</span><span class="n">nfh</span><span class="p">)</span>
        <span class="n">uh</span><span class="o">=</span><span class="n">lh</span><span class="o">+</span><span class="n">nh_single</span>
        <span class="k">if</span> <span class="n">histnorm</span><span class="p">:</span>
            <span class="n">img</span><span class="o">=</span><span class="n">histogram_stretch</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
        <span class="n">ws_img</span><span class="p">[</span><span class="n">lv</span><span class="p">:</span><span class="n">uv</span><span class="p">,</span><span class="n">lh</span><span class="p">:</span><span class="n">uh</span><span class="p">]</span><span class="o">=</span><span class="n">img</span>
    <span class="k">return</span> <span class="n">ws_img</span></div>


<div class="viewcode-block" id="load_ilastik">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.load_ilastik">[docs]</a>
<span class="k">def</span> <span class="nf">load_ilastik</span><span class="p">(</span><span class="n">file_ilastik</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads pixel classification results from an HDF5 file generated by Ilastik. This function reads the dataset</span>
<span class="sd">    containing pixel predictions and returns it as a numpy array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_ilastik : str</span>
<span class="sd">        The path to the HDF5 file containing the Ilastik prediction data. This file typically contains</span>
<span class="sd">        segmented or classified image data where each pixel is assigned a label.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A multi-dimensional array extracted from the Ilastik HDF5 file. The shape of the array is typically</span>
<span class="sd">        2D (for image data) extended by the number of label classes predicted by Ilastik. Each slice along the</span>
<span class="sd">        third dimension corresponds to a different label class.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; prediction = load_ilastik(&#39;path/to/ilastik/output.h5&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(prediction.shape)</span>
<span class="sd">    (1024, 1024, 3)  # Example shape, indicating an image of 1024x1024 pixels and 3 label classes</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function assumes that the dataset is stored under the key &#39;exported_data&#39; in the HDF5 file, which is</span>
<span class="sd">      the default output configuration for Ilastik predictions.</span>
<span class="sd">    - Users should ensure that the HDF5 file exists and is not corrupted before attempting to load it.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    OSError</span>
<span class="sd">        If the file cannot be opened, possibly due to being nonexistent or corrupted.</span>
<span class="sd">    KeyError</span>
<span class="sd">        If the expected dataset &#39;exported_data&#39; is not found in the file.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">file_ilastik</span><span class="p">,</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
    <span class="n">dset</span><span class="o">=</span><span class="n">f</span><span class="p">[</span><span class="s1">&#39;exported_data&#39;</span><span class="p">]</span>
    <span class="n">pmask</span><span class="o">=</span><span class="n">dset</span><span class="p">[:]</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">pmask</span></div>


<div class="viewcode-block" id="get_mask_2channel_ilastik">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_mask_2channel_ilastik">[docs]</a>
<span class="k">def</span> <span class="nf">get_mask_2channel_ilastik</span><span class="p">(</span><span class="n">file_ilastik</span><span class="p">,</span><span class="n">fore_channel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">holefill_area</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">growthcycles</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">pcut</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes a pixel classification output from Ilastik to generate a binary mask for a specified foreground </span>
<span class="sd">    channel. This function includes options to fill holes, apply morphological operations, and threshold the </span>
<span class="sd">    probability maps to create a final binary mask.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file_ilastik : str</span>
<span class="sd">        The path to the HDF5 file containing the Ilastik classification output.</span>
<span class="sd">    fore_channel : int, optional</span>
<span class="sd">        The index of the channel in the Ilastik output that represents the foreground probability. Default is 0.</span>
<span class="sd">    holefill_area : int, optional</span>
<span class="sd">        The minimum area threshold for opening and closing operations to fill holes in the foreground mask.</span>
<span class="sd">        If 0, no hole filling is performed. Default is 0.</span>
<span class="sd">    growthcycles : int, optional</span>
<span class="sd">        The number of cycles of dilation followed by erosion to grow and then shrink the foreground mask.</span>
<span class="sd">        This can help in smoothing the mask edges. Default is 0, which means no growth or erosion cycles.</span>
<span class="sd">    pcut : float, optional</span>
<span class="sd">        The probability cutoff threshold to convert the probability map to a binary mask. Values above this</span>
<span class="sd">        threshold will be considered foreground. Default is 0.8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D binary mask where pixels classified as foreground based on the specified channel and probability</span>
<span class="sd">        threshold are marked as True, and all other pixels are False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; binary_mask = get_mask_2channel_ilastik(&#39;output_from_ilastik.h5&#39;, fore_channel=1, holefill_area=500, growthcycles=2, pcut=0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(binary_mask.shape)</span>
<span class="sd">    (1024, 1024)  # Example shape for a typical output mask</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses skimage&#39;s morphological operations for hole filling and size adjustments, which are</span>
<span class="sd">      highly effective in post-processing segmentation masks.</span>
<span class="sd">    - Appropriate tuning of `holefill_area`, `growthcycles`, and `pcut` parameters is crucial for achieving</span>
<span class="sd">      optimal segmentation results based on the specific characteristics of the image data.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">pmask</span><span class="o">=</span><span class="n">load_ilastik</span><span class="p">(</span><span class="n">file_ilastik</span><span class="p">)</span>
    <span class="n">msk_fore</span><span class="o">=</span><span class="n">pmask</span><span class="p">[:,:,</span><span class="n">fore_channel</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">holefill_area</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">msk_fore</span><span class="o">=</span><span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">area_opening</span><span class="p">(</span><span class="n">msk_fore</span><span class="p">,</span> <span class="n">area_threshold</span><span class="o">=</span><span class="n">holefill_area</span><span class="p">)</span>
        <span class="n">msk_fore</span><span class="o">=</span><span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">area_closing</span><span class="p">(</span><span class="n">msk_fore</span><span class="p">,</span> <span class="n">area_threshold</span><span class="o">=</span><span class="n">holefill_area</span><span class="p">)</span>
    <span class="n">msk_fore</span><span class="o">=</span><span class="n">msk_fore</span><span class="o">&gt;</span><span class="n">pcut</span>
    <span class="k">if</span> <span class="n">growthcycles</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
       <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">growthcycles</span><span class="p">):</span>
           <span class="n">msk_fore</span><span class="o">=</span><span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">msk_fore</span><span class="p">)</span>
       <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">growthcycles</span><span class="p">):</span>
           <span class="n">msk_fore</span><span class="o">=</span><span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">msk_fore</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msk_fore</span></div>


<div class="viewcode-block" id="get_masks">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_masks">[docs]</a>
<span class="k">def</span> <span class="nf">get_masks</span><span class="p">(</span><span class="n">masklist</span><span class="p">,</span><span class="n">fore_channel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">holefill_area</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">growthcycles</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">pcut</span><span class="o">=</span><span class="mf">0.8</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes a list of Ilastik prediction files to generate binary masks based on specified foreground channels</span>
<span class="sd">    and other morphological processing parameters. This function is useful for batch processing multiple segmentation</span>
<span class="sd">    outputs, applying uniform post-processing steps such as hole filling, growth cycles, and probability thresholding.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    masklist : list of str</span>
<span class="sd">        A list of file paths to Ilastik prediction outputs (HDF5 files).</span>
<span class="sd">    fore_channel : int, optional</span>
<span class="sd">        The index of the channel in the Ilastik output that represents the foreground probabilities. Default is 0.</span>
<span class="sd">    holefill_area : int, optional</span>
<span class="sd">        The minimum area threshold for opening and closing operations to fill holes in the masks. If set to 0, </span>
<span class="sd">        no hole filling is performed. Default is 0.</span>
<span class="sd">    growthcycles : int, optional</span>
<span class="sd">        The number of dilation followed by erosion cycles applied to the masks to enhance mask boundaries. </span>
<span class="sd">        Default is 0, meaning no growth or erosion cycles are applied.</span>
<span class="sd">    pcut : float, optional</span>
<span class="sd">        The probability threshold above which a pixel is considered as foreground (mask is set to True). Default is 0.8.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list of ndarray</span>
<span class="sd">        A list of 2D binary masks where each mask corresponds to the processed output of each file in `masklist`.</span>
<span class="sd">        Each mask has pixels marked as True for foreground and False for background based on the provided parameters.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; mask_files = [&#39;path/to/ilastik_output1.h5&#39;, &#39;path/to/ilastik_output2.h5&#39;]</span>
<span class="sd">    &gt;&gt;&gt; masks = get_masks(mask_files, fore_channel=1, holefill_area=500, growthcycles=2, pcut=0.5)</span>
<span class="sd">    &gt;&gt;&gt; print(len(masks), masks[0].shape)</span>
<span class="sd">    2, (1024, 1024)  # Assuming the masks are from 1024x1024 pixel images</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function is particularly useful in large-scale image processing workflows where consistent mask processing</span>
<span class="sd">      across multiple images or conditions is required.</span>
<span class="sd">    - Ensure that all files in `masklist` are accessible and properly formatted as Ilastik output HDF5 files.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    FileNotFoundError</span>
<span class="sd">        If any file in `masklist` does not exist or cannot be read.</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `pcut` is not between 0 and 1, or other parameter constraints are violated.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nF</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">masklist</span><span class="p">)</span>
    <span class="n">masks</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">nF</span>
    <span class="k">for</span> <span class="n">iF</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nF</span><span class="p">):</span>
        <span class="n">file_ilastik</span><span class="o">=</span><span class="n">masklist</span><span class="p">[</span><span class="n">iF</span><span class="p">]</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;loading &#39;</span><span class="o">+</span><span class="n">file_ilastik</span><span class="p">)</span>
        <span class="n">msk</span><span class="o">=</span><span class="n">get_mask_2channel_ilastik</span><span class="p">(</span><span class="n">file_ilastik</span><span class="p">,</span><span class="n">fore_channel</span><span class="o">=</span><span class="n">fore_channel</span><span class="p">,</span><span class="n">holefill_area</span><span class="o">=</span><span class="n">holefill_area</span><span class="p">,</span><span class="n">growthcycles</span><span class="o">=</span><span class="n">growthcycles</span><span class="p">,</span><span class="n">pcut</span><span class="o">=</span><span class="n">pcut</span><span class="p">)</span>
        <span class="n">masks</span><span class="p">[</span><span class="n">iF</span><span class="p">]</span><span class="o">=</span><span class="n">msk</span>
    <span class="k">return</span> <span class="n">masks</span></div>


<div class="viewcode-block" id="local_threshold">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.local_threshold">[docs]</a>
<span class="k">def</span> <span class="nf">local_threshold</span><span class="p">(</span><span class="n">imgr</span><span class="p">,</span><span class="n">block_size</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span><span class="n">z_std</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a local thresholding algorithm to an image using adaptive threshold values computed from each pixel&#39;s</span>
<span class="sd">    local neighborhood, adjusted by a global threshold defined as a multiple of the image&#39;s standard deviation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imgr : ndarray</span>
<span class="sd">        The input image array for which local thresholding is to be performed. Typically, this should be a 2D grayscale image.</span>
<span class="sd">    block_size : int, optional</span>
<span class="sd">        The size of the neighborhood block used for calculating the local threshold for each pixel. This value should be an odd integer.</span>
<span class="sd">        Default is 51, which balances responsiveness to local variations with noise reduction.</span>
<span class="sd">    z_std : float, optional</span>
<span class="sd">        The standard deviation multiplier to adjust the global thresholding offset. Default is 1.0, which sets the offset to one standard</span>
<span class="sd">        deviation of the image&#39;s intensity values.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A binary image of the same shape as `imgr`, where pixels are True if their intensity is greater than the local threshold value,</span>
<span class="sd">        otherwise False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; imgr = np.random.rand(100, 100) * 255  # Create a random grayscale image</span>
<span class="sd">    &gt;&gt;&gt; binary_image = local_threshold(imgr, block_size=51, z_std=1.5)</span>
<span class="sd">    &gt;&gt;&gt; print(binary_image.shape)</span>
<span class="sd">    (100, 100)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Local thresholding is particularly useful in images with varying lighting conditions where global thresholding might fail.</span>
<span class="sd">    - The `block_size` determines the adaptability of the thresholding algorithm to local changes in lighting and should be chosen</span>
<span class="sd">      based on the specific spatial scale of features of interest.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If `block_size` is even, as an odd-sized block is required to have a central pixel.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nuc_thresh</span><span class="o">=</span><span class="n">z_std</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">imgr</span><span class="p">)</span>
    <span class="n">local_thresh</span> <span class="o">=</span> <span class="n">threshold_local</span><span class="p">(</span><span class="n">imgr</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="n">nuc_thresh</span><span class="p">)</span>
    <span class="n">b_imgr</span> <span class="o">=</span> <span class="n">imgr</span> <span class="o">&gt;</span> <span class="n">local_thresh</span>
    <span class="k">return</span> <span class="n">b_imgr</span></div>


<div class="viewcode-block" id="get_labeled_mask">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_labeled_mask">[docs]</a>
<span class="k">def</span> <span class="nf">get_labeled_mask</span><span class="p">(</span><span class="n">b_imgr</span><span class="p">,</span><span class="n">imgM</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">apply_watershed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fill_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">dist_footprint</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">zscale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes a binary image to label connected components, optionally applying the watershed algorithm to</span>
<span class="sd">    separate closely touching objects. This function can also fill holes within binary objects and mask out</span>
<span class="sd">    areas from an exclusion mask.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    b_imgr : ndarray</span>
<span class="sd">        A binary image where True represents the foreground (objects to label) and False represents the background.</span>
<span class="sd">    imgM : ndarray, optional</span>
<span class="sd">        An exclusion mask where True values specify areas to ignore during labeling, such as known noise or artifacts.</span>
<span class="sd">        If provided, any foreground in these areas will be set to False. Default is None.</span>
<span class="sd">    apply_watershed : bool, optional</span>
<span class="sd">        Whether to apply the watershed algorithm to separate overlapping or touching objects using a distance transform.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    fill_holes : bool, optional</span>
<span class="sd">        If True, fills holes within the binary objects. This is often useful for cleaning up segmentation artifacts.</span>
<span class="sd">        Default is True.</span>
<span class="sd">    dist_footprint : int, optional</span>
<span class="sd">        The size of the footprint used for the distance transform if applying the watershed. Specifies the connectivity</span>
<span class="sd">        of the neighborhood used in the local maximum detection. Default is None, which uses a 3x3 square.</span>
<span class="sd">    zscale : float, optional</span>
<span class="sd">        The scaling factor for z-dimension in volumetric data (3D). It compensates for the difference in resolution</span>
<span class="sd">        between xy-plane and z-axis and is used only if the image is three-dimensional. Default is None.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A labeled image where each unique integer (starting from 1) corresponds to a separate object, with 0 representing</span>
<span class="sd">        the background.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; img = np.random.randint(0, 2, size=(100, 100), dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; labeled_mask = get_labeled_mask(img, apply_watershed=True, fill_holes=True, dist_footprint=5)</span>
<span class="sd">    &gt;&gt;&gt; print(np.unique(labeled_mask))</span>
<span class="sd">    [0 1 2 3 ...]  # Example of labels found in the mask</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The watershed algorithm can help in separating objects that touch each other but requires careful setting of the</span>
<span class="sd">      `dist_footprint` and `zscale` in case of volumetric data.</span>
<span class="sd">    - Exclusion masks are useful in experiments where certain areas need to be systematically ignored, such as damaged</span>
<span class="sd">      regions on a slide or expected artifacts.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">imgM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">indBackground</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">imgM</span><span class="p">))</span>
        <span class="n">b_imgr</span><span class="p">[</span><span class="n">indBackground</span><span class="p">]</span><span class="o">=</span><span class="kc">False</span>
    <span class="k">if</span> <span class="n">fill_holes</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">b_imgr</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">b_imgr</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">b_imgr</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">b_imgr</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b_imgr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">b_imgr</span><span class="p">[</span><span class="n">iz</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">b_imgr</span><span class="p">[</span><span class="n">iz</span><span class="p">,:,:])</span>
    <span class="n">masks_nuc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">b_imgr</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">apply_watershed</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">dist_footprint</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dist_footprint</span><span class="o">=</span><span class="mi">3</span>
        <span class="k">if</span> <span class="n">b_imgr</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">footprint</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">dist_footprint</span><span class="p">,</span> <span class="n">dist_footprint</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">b_imgr</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">zscale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zscale</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">d_imgr</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">b_imgr</span><span class="p">)</span>
        <span class="n">local_maxi</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">d_imgr</span><span class="p">,</span> <span class="n">indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">footprint</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="n">masks_nuc</span><span class="p">,</span><span class="n">num_peaks_per_label</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">markers_nuc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">local_maxi</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">masks_nuc</span> <span class="o">=</span> <span class="n">watershed</span><span class="p">(</span><span class="o">-</span><span class="n">d_imgr</span><span class="p">,</span> <span class="n">markers</span><span class="o">=</span><span class="n">markers_nuc</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="n">b_imgr</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">masks_nuc</span></div>


<div class="viewcode-block" id="clean_labeled_mask">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.clean_labeled_mask">[docs]</a>
<span class="k">def</span> <span class="nf">clean_labeled_mask</span><span class="p">(</span><span class="n">masks_nuc</span><span class="p">,</span><span class="n">remove_borders</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">remove_padding</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">edge_buffer</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span><span class="n">minsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">maxsize</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">fill_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">selection</span><span class="o">=</span><span class="s1">&#39;largest&#39;</span><span class="p">,</span><span class="n">test_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">test_cut</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Cleans up a labeled mask by removing small or large objects based on size thresholds, handling image borders,</span>
<span class="sd">    and optionally filling holes within the objects. This function can also trim padding around the image and </span>
<span class="sd">    filter objects based on a secondary map.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    masks_nuc : ndarray</span>
<span class="sd">        An integer-labeled mask where each unique positive integer represents a separate object, and 0 represents the background.</span>
<span class="sd">    remove_borders : bool, optional</span>
<span class="sd">        If True, removes objects touching the image border. Default is False.</span>
<span class="sd">    remove_padding : bool, optional</span>
<span class="sd">        If True, removes padding around the image, focusing the mask on the central region. Default is False.</span>
<span class="sd">    edge_buffer : int, optional</span>
<span class="sd">        Defines a buffer zone around the edges when removing border-touching objects. Default is 0.</span>
<span class="sd">    minsize : int, optional</span>
<span class="sd">        The minimum size threshold for objects to be retained. Objects smaller than this are removed. Default is None, which disables this filter.</span>
<span class="sd">    maxsize : int, optional</span>
<span class="sd">        The maximum size threshold for objects. Objects larger than this are removed. Default is None, which disables this filter.</span>
<span class="sd">    verbose : bool, optional</span>
<span class="sd">        If True, print details about object removal. Default is False.</span>
<span class="sd">    fill_holes : bool, optional</span>
<span class="sd">        If True, fills holes within each labeled object. Default is True.</span>
<span class="sd">    selection : str, optional</span>
<span class="sd">        The method for selecting objects within a connected component. Supported values are &#39;largest&#39; to keep only the largest object. Default is &#39;largest&#39;.</span>
<span class="sd">    test_map : ndarray, optional</span>
<span class="sd">        An additional map used to test objects for a secondary criterion, such as intensity thresholding. Default is None.</span>
<span class="sd">    test_cut : float, optional</span>
<span class="sd">        The cutoff value used along with `test_map` to decide whether an object should be retained. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A cleaned labeled mask with the same shape as `masks_nuc`, where retained objects are relabeled consecutively starting from 1, and background remains 0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; labeled_mask = np.array([[0, 1, 1], [1, 2, 2], [2, 2, 0]])</span>
<span class="sd">    &gt;&gt;&gt; cleaned_mask = clean_labeled_mask(labeled_mask, minsize=2, fill_holes=True)</span>
<span class="sd">    &gt;&gt;&gt; print(cleaned_mask)</span>
<span class="sd">    [[0 1 1]</span>
<span class="sd">     [1 0 0]</span>
<span class="sd">     [0 0 0]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function is useful for post-processing segmentation outputs where removal of noise and small artifacts is necessary.</span>
<span class="sd">    - If `remove_padding` is used, ensure that the indices provided match the actual data layout to avoid misalignment.</span>
<span class="sd">    - Combining `test_map` and `test_cut` allows for sophisticated filtering based on specific measurement criteria, such as fluorescence intensity or other cell properties.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ndim</span><span class="o">=</span><span class="n">masks_nuc</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">minsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">minsize</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">maxsize</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">maxsize</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
    <span class="k">if</span> <span class="n">remove_padding</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">xmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span><span class="n">xmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ymin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span><span class="n">ymax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">masks_nuc_trimmed</span><span class="o">=</span><span class="n">masks_nuc</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,:];</span> <span class="n">masks_nuc_trimmed</span><span class="o">=</span><span class="n">masks_nuc_trimmed</span><span class="p">[:,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">xmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">]);</span><span class="n">xmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">ymin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">2</span><span class="p">]);</span><span class="n">ymax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">2</span><span class="p">])</span>
            <span class="n">zmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]);</span><span class="n">zmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">masks_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">masks_nuc_trimmed</span><span class="o">=</span><span class="n">masks_nuc</span><span class="p">[:,</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,:];</span> <span class="n">masks_nuc_trimmed</span><span class="o">=</span><span class="n">masks_nuc_trimmed</span><span class="p">[:,:,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">];</span> <span class="n">masks_nuc_trimmed</span><span class="o">=</span><span class="n">masks_nuc_trimmed</span><span class="p">[</span><span class="n">zmin</span><span class="p">:</span><span class="n">zmax</span><span class="p">,:,:]</span>
        <span class="n">masks_nuc_trimmed</span><span class="o">=</span><span class="n">clear_border</span><span class="p">(</span><span class="n">masks_nuc_trimmed</span><span class="p">,</span><span class="n">buffer_size</span><span class="o">=</span><span class="n">edge_buffer</span><span class="p">)</span>
        <span class="n">bmsk1</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">masks_nuc</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">);</span><span class="n">bmsk2</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">masks_nuc</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">bmsk1</span><span class="p">[</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,:]</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">bmsk2</span><span class="p">[:,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
            <span class="n">bmsk1</span><span class="p">[:,</span><span class="n">xmin</span><span class="p">:</span><span class="n">xmax</span><span class="p">,:]</span><span class="o">=</span><span class="kc">True</span>
            <span class="n">bmsk2</span><span class="p">[:,:,</span><span class="n">ymin</span><span class="p">:</span><span class="n">ymax</span><span class="p">]</span><span class="o">=</span><span class="kc">True</span>
        <span class="n">indscenter</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">bmsk1</span><span class="p">,</span><span class="n">bmsk2</span><span class="p">))</span>
        <span class="n">masks_nuc_edgeless</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">masks_nuc</span><span class="p">)</span>
        <span class="n">masks_nuc_edgeless</span><span class="p">[</span><span class="n">indscenter</span><span class="p">]</span><span class="o">=</span><span class="n">masks_nuc_trimmed</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">masks_nuc</span><span class="o">=</span><span class="n">masks_nuc_edgeless</span>
    <span class="k">if</span> <span class="n">remove_borders</span><span class="p">:</span>
        <span class="n">masks_nuc</span><span class="o">=</span><span class="n">clear_border</span><span class="p">(</span><span class="n">masks_nuc</span><span class="p">,</span><span class="n">buffer_size</span><span class="o">=</span><span class="n">edge_buffer</span><span class="p">)</span>
    <span class="n">masks_nuc_clean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">masks_nuc</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="n">nc</span><span class="o">=</span><span class="mi">1</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">masks_nuc</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1">#size filtering</span>
        <span class="n">mskc</span> <span class="o">=</span> <span class="n">masks_nuc</span><span class="o">==</span><span class="n">ic</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mskc</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_holes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mskc</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">mskc</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">mskc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mskc</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mskc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">mskc</span><span class="p">[</span><span class="n">iz</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">mskc</span><span class="p">[</span><span class="n">iz</span><span class="p">,:,:])</span>
            <span class="n">labelsc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mskc</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">largestCC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labelsc</span><span class="o">.</span><span class="n">flat</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">selection</span><span class="o">==</span><span class="s1">&#39;largest&#39;</span><span class="p">:</span>
                <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labelsc</span> <span class="o">==</span> <span class="n">largestCC</span><span class="p">)</span> <span class="c1">#keep largest connected component</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mskc</span><span class="p">)</span>
            <span class="n">npixc</span><span class="o">=</span><span class="n">indc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span>
            <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">npixc</span><span class="o">&lt;</span><span class="n">minsize</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; too small: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">npixc</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">npixc</span><span class="o">&gt;</span><span class="n">maxsize</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; too big: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">npixc</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">npixc</span><span class="o">&gt;</span><span class="n">minsize</span> <span class="ow">and</span> <span class="n">npixc</span><span class="o">&lt;</span><span class="n">maxsize</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">test_map</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">masks_nuc_clean</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="n">nc</span>
                    <span class="n">nc</span><span class="o">=</span><span class="n">nc</span><span class="o">+</span><span class="mi">1</span>
                <span class="k">if</span> <span class="n">test_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">test_sum</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">test_map</span><span class="p">[</span><span class="n">indc</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">test_sum</span><span class="o">&gt;</span><span class="n">test_cut</span><span class="p">:</span>
                        <span class="n">masks_nuc_clean</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="n">nc</span>
                        <span class="n">nc</span><span class="o">=</span><span class="n">nc</span><span class="o">+</span><span class="mi">1</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; has not enough value in test map: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">test_sum</span><span class="p">))</span>    
    <span class="k">return</span> <span class="n">masks_nuc_clean</span></div>


<div class="viewcode-block" id="get_label_largestcc">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_label_largestcc">[docs]</a>
<span class="k">def</span> <span class="nf">get_label_largestcc</span><span class="p">(</span><span class="n">label</span><span class="p">,</span><span class="n">fill_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Processes a labeled mask to keep only the largest connected component (CC) for each unique label in the mask,</span>
<span class="sd">    optionally filling holes within those components. This function is useful for cleaning segmentation results by </span>
<span class="sd">    removing smaller fragments of labels and ensuring continuity in the detected objects.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    label : ndarray</span>
<span class="sd">        An integer-labeled mask where each unique positive integer represents a separate object, and 0 represents the background.</span>
<span class="sd">    fill_holes : bool, optional</span>
<span class="sd">        If True, fills holes within the labeled objects before identifying the largest connected component.</span>
<span class="sd">        This can help in creating more robust and continuous object detections. Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A labeled mask similar in shape to the input `label`, but with only the largest connected component retained</span>
<span class="sd">        for each label, and all other components removed.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function is particularly useful when segmentation algorithms produce noisy results or when labels are</span>
<span class="sd">      fragmented. Cleaning up the labels to retain only the largest component can significantly improve the quality</span>
<span class="sd">      of the final analysis, especially in quantitative measurements where object integrity is crucial.</span>
<span class="sd">    - If using 3D data, the function will process each slice independently unless the mask is inherently volumetric,</span>
<span class="sd">      in which case 3D hole filling and labeling is applied.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels_clean</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label</span><span class="p">)[</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">!=</span><span class="mi">0</span><span class="p">]:</span>
        <span class="n">mskc</span> <span class="o">=</span> <span class="n">label</span><span class="o">==</span><span class="n">ic</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mskc</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">fill_holes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">mskc</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
                    <span class="n">mskc</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">mskc</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">mskc</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">iz</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">mskc</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="n">mskc</span><span class="p">[</span><span class="n">iz</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">binary_fill_holes</span><span class="p">(</span><span class="n">mskc</span><span class="p">[</span><span class="n">iz</span><span class="p">,:,:])</span>
            <span class="n">labelsc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mskc</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">largestCC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labelsc</span><span class="o">.</span><span class="n">flat</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labelsc</span> <span class="o">==</span> <span class="n">largestCC</span><span class="p">)</span>
            <span class="n">labels_clean</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="n">ic</span>
    <span class="k">return</span> <span class="n">labels_clean</span></div>


<div class="viewcode-block" id="get_feature_map">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_feature_map">[docs]</a>
<span class="k">def</span> <span class="nf">get_feature_map</span><span class="p">(</span><span class="n">features</span><span class="p">,</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Maps an array of features to their corresponding labels in a labeled image. Each feature is assigned to the region</span>
<span class="sd">    of the mask identified by the same label index. This function ensures that each discrete label in the labeled mask</span>
<span class="sd">    gets the corresponding feature value from the features array.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    features : ndarray</span>
<span class="sd">        An array of feature values where each entry corresponds to a label in the `labels` mask. The length of `features`</span>
<span class="sd">        must match the highest label value in the `labels` mask.</span>
<span class="sd">    labels : ndarray</span>
<span class="sd">        An integer-labeled mask where each unique positive integer represents a different region. Each region (label) will</span>
<span class="sd">        be assigned the corresponding feature value from the `features` array based on its label index.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        An array of the same shape as `labels` where each labeled region is filled with its corresponding feature value</span>
<span class="sd">        from the `features` array.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; labels = np.array([[1, 1, 0], [0, 2, 2], [2, 2, 0]])</span>
<span class="sd">    &gt;&gt;&gt; features = np.array([10, 20])</span>
<span class="sd">    &gt;&gt;&gt; feature_map = get_feature_map(features, labels)</span>
<span class="sd">    &gt;&gt;&gt; print(feature_map)</span>
<span class="sd">    [[10 10  0]</span>
<span class="sd">     [ 0 20 20]</span>
<span class="sd">     [20 20  0]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function is particularly useful in imaging and machine learning applications where each segmented region&#39;s</span>
<span class="sd">      properties need to be mapped back onto the original labeled mask for visualization or further analysis.</span>
<span class="sd">    - Ensure that the number of features matches the maximum label in the `labels` mask to avoid mismatches and errors.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the size of the `features` array does not match the highest label value in the `labels` mask.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">features</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;feature size needs to match labels&#39;</span><span class="p">)</span>
    <span class="n">fmap</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span> <span class="c1">#size filtering</span>
        <span class="n">mskc</span> <span class="o">=</span> <span class="n">labels</span><span class="o">==</span><span class="n">ic</span>
        <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mskc</span><span class="p">)</span>
        <span class="n">fmap</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="n">features</span><span class="p">[</span><span class="n">ic</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">fmap</span></div>


<div class="viewcode-block" id="get_voronoi_masks_fromcenters">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_voronoi_masks_fromcenters">[docs]</a>
<span class="k">def</span> <span class="nf">get_voronoi_masks_fromcenters</span><span class="p">(</span><span class="n">nuc_centers</span><span class="p">,</span><span class="n">imgM</span><span class="p">,</span><span class="n">selection</span><span class="o">=</span><span class="s1">&#39;closest&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates Voronoi masks from provided nucleus centers within a given image mask. The function assigns each pixel</span>
<span class="sd">    to the nearest nucleus center, creating distinct regions (Voronoi tessellation). Optionally, the user can choose</span>
<span class="sd">    to select the largest or the closest connected component within each Voronoi region as the final mask.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    nuc_centers : ndarray</span>
<span class="sd">        An array of nucleus center coordinates where each row represents a center (z, y, x) for 3D or (y, x) for 2D.</span>
<span class="sd">    imgM : ndarray</span>
<span class="sd">        A binary image mask defining the area within which the Voronoi tessellation is to be computed. True values indicate</span>
<span class="sd">        the region of interest where tessellation is applicable.</span>
<span class="sd">    selection : str, optional</span>
<span class="sd">        Method for selecting the final mask within each tessellated region. Options include:</span>
<span class="sd">        - &#39;closest&#39;: Selects the connected component closest to the nucleus center.</span>
<span class="sd">        - &#39;largest&#39;: Selects the largest connected component within the tessellated region.</span>
<span class="sd">        Default is &#39;closest&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A labeled mask with the same dimensions as `imgM`. Each pixel&#39;s value corresponds to the region number it belongs to,</span>
<span class="sd">        with 0 representing background or areas outside the regions of interest.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; nuc_centers = np.array([[10, 10], [30, 30]])</span>
<span class="sd">    &gt;&gt;&gt; imgM = np.zeros((50, 50), dtype=bool)</span>
<span class="sd">    &gt;&gt;&gt; imgM[5:45, 5:45] = True  # Define an area of interest</span>
<span class="sd">    &gt;&gt;&gt; voronoi_masks = get_voronoi_masks_fromcenters(nuc_centers, imgM, selection=&#39;largest&#39;)</span>
<span class="sd">    &gt;&gt;&gt; print(voronoi_masks.shape)</span>
<span class="sd">    (50, 50)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function is useful in cell imaging where cells are identified by their nuclei, and each cell&#39;s region needs</span>
<span class="sd">      to be delineated based on the proximity to these nuclei.</span>
<span class="sd">    - The Voronoi tessellation is constrained by the binary mask `imgM`, which means that no tessellation occurs outside</span>
<span class="sd">      the specified mask area.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the dimensions of `nuc_centers` do not match the dimensions of `imgM` or if `selection` is not a recognized option.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">indBackground</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">imgM</span><span class="p">))</span>
    <span class="n">nuc_clusters</span><span class="o">=</span><span class="n">pyemma</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span><span class="n">nuc_centers</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">imgM</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">nx</span><span class="o">=</span><span class="n">imgM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">ny</span><span class="o">=</span><span class="n">imgM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">voronoi_masks</span><span class="o">=</span><span class="n">nuc_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="k">if</span> <span class="n">imgM</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">nz</span><span class="o">=</span><span class="n">imgM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span><span class="n">nx</span><span class="o">=</span><span class="n">imgM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span> <span class="n">ny</span><span class="o">=</span><span class="n">imgM</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">zz</span><span class="p">,</span><span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nz</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
        <span class="n">voronoi_masks</span><span class="o">=</span><span class="n">nuc_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">zz</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nz</span><span class="p">,</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">voronoi_masks</span><span class="p">[</span><span class="n">indBackground</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">masks_cyto</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voronoi_masks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voronoi_masks</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">mskc</span> <span class="o">=</span> <span class="n">voronoi_masks</span><span class="o">==</span><span class="n">ic</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mskc</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">labelsc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mskc</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">centers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">mskc</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="n">labelsc</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labelsc</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>
            <span class="n">nuc_center</span><span class="o">=</span><span class="n">nuc_centers</span><span class="p">[</span><span class="n">ic</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">dists</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centers</span><span class="o">-</span><span class="n">nuc_center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">closestCC</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
            <span class="n">largestCC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labelsc</span><span class="o">.</span><span class="n">flat</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">closestCC</span> <span class="o">!=</span> <span class="n">largestCC</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; nchunks: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; closest: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">closestCC</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; largest: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">largestCC</span><span class="p">))</span>
            <span class="n">largestCC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labelsc</span><span class="o">.</span><span class="n">flat</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span><span class="o">+</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">selection</span><span class="o">==</span><span class="s1">&#39;closest&#39;</span><span class="p">:</span>
                <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labelsc</span> <span class="o">==</span> <span class="n">closestCC</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">selection</span><span class="o">==</span><span class="s1">&#39;largest&#39;</span><span class="p">:</span>
                <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labelsc</span> <span class="o">==</span> <span class="n">largestCC</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">indc</span><span class="o">=</span><span class="n">indc</span>
            <span class="n">masks_cyto</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="n">ic</span>
    <span class="k">return</span> <span class="n">masks_cyto</span></div>


<div class="viewcode-block" id="make_odd">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.make_odd">[docs]</a>
<span class="k">def</span> <span class="nf">make_odd</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Converts a number to the nearest odd integer. If the number is even, it will be increased to the next odd number.</span>
<span class="sd">    If the number is odd, it will be returned as is.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    x : float or int</span>
<span class="sd">        The number to be converted to the nearest odd integer.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        The nearest odd integer.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; print(make_odd(4))</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; print(make_odd(5))</span>
<span class="sd">    5</span>
<span class="sd">    &gt;&gt;&gt; print(make_odd(2.7))</span>
<span class="sd">    3</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function can be used where algorithm parameters such as kernel sizes need to be odd numbers (e.g., for</span>
<span class="sd">      median filtering or convolution operations in image processing).</span>
<span class="sd">    - The function works by rounding up to the next integer if the input is not an integer, ensuring the result is odd.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">x</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">x</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span></div>


<div class="viewcode-block" id="get_intensity_centers">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_intensity_centers">[docs]</a>
<span class="k">def</span> <span class="nf">get_intensity_centers</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">msk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">footprint_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">rcut</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">smooth_sigma</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">pad_zeros</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Identifies centers of intensity within an image, optionally constrained by a mask. This function is useful for </span>
<span class="sd">    detecting features like local maxima that represent points of interest within an image, such as cell centers in </span>
<span class="sd">    microscopy images.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The image in which intensity centers are to be identified.</span>
<span class="sd">    msk : ndarray, optional</span>
<span class="sd">        A boolean mask of the same shape as `img` that specifies regions within which centers should be identified.</span>
<span class="sd">        If None, the entire image is considered.</span>
<span class="sd">    footprint_shape : tuple, optional</span>
<span class="sd">        The size of the neighborhood considered for the local maximum. Should be a tuple corresponding to the image </span>
<span class="sd">        dimensions. If None, a minimal footprint of shape (1,1,...) for each dimension is used.</span>
<span class="sd">    rcut : float, optional</span>
<span class="sd">        The minimum allowed distance between centers. If centers are closer than this value, they will be merged.</span>
<span class="sd">        If None, no merging is performed.</span>
<span class="sd">    smooth_sigma : float or sequence of floats, optional</span>
<span class="sd">        The standard deviation for Gaussian smoothing applied to the image before identifying centers. This helps </span>
<span class="sd">        to reduce noise and improve the robustness of center detection.</span>
<span class="sd">    pad_zeros : bool, optional</span>
<span class="sd">        If True, the image will be padded with zeros on all sides by the width specified in `footprint_shape`.</span>
<span class="sd">        This helps to handle edge effects during local maximum detection.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        An array of coordinates for the detected intensity centers.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; img = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])</span>
<span class="sd">    &gt;&gt;&gt; centers = get_intensity_centers(img, smooth_sigma=1, footprint_shape=(1, 1))</span>
<span class="sd">    &gt;&gt;&gt; print(centers)</span>
<span class="sd">    [[2 2]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function is particularly useful for preprocessing steps in image analysis where features need to be extracted</span>
<span class="sd">      from local intensity variations.</span>
<span class="sd">    - Adjusting `rcut` and `smooth_sigma` according to the scale and noise characteristics of the image can significantly</span>
<span class="sd">      affect the accuracy and reliability of the detected centers.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">msk</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">msk</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">img</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">bool</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">footprint_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">sigma</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="n">footprint_shape</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">pad_zeros</span><span class="o">==</span><span class="kc">True</span><span class="p">:</span>
        <span class="n">img_copy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">footprint_shape</span><span class="p">))))</span>
        <span class="n">img_copy</span><span class="p">[</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="o">-</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="o">-</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">img</span>
        <span class="n">img</span><span class="o">=</span><span class="n">img_copy</span>
        <span class="n">msk_copy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">msk</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">+</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">footprint_shape</span><span class="p">))))</span>
        <span class="n">msk_copy</span><span class="p">[</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="o">-</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span><span class="o">-</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span><span class="o">-</span><span class="n">footprint_shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">=</span><span class="n">msk</span>
        <span class="n">msk</span><span class="o">=</span><span class="n">msk_copy</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">smooth_sigma</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img</span><span class="o">=</span><span class="n">skimage</span><span class="o">.</span><span class="n">filters</span><span class="o">.</span><span class="n">gaussian</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">sigma</span><span class="o">=</span><span class="n">smooth_sigma</span><span class="p">)</span>
    <span class="n">local_maxi</span> <span class="o">=</span> <span class="n">peak_local_max</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">footprint</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">footprint_shape</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)),</span> <span class="n">labels</span><span class="o">=</span><span class="n">msk</span><span class="p">,</span><span class="n">exclude_border</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rcut</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">close_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">imax</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">local_maxi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">dists</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">local_maxi</span><span class="o">-</span><span class="n">local_maxi</span><span class="p">[</span><span class="n">imax</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">dists</span><span class="o">&lt;</span><span class="n">rcut</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">indclose</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">dists</span><span class="o">&lt;</span><span class="n">rcut</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">mean_loc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">local_maxi</span><span class="p">[</span><span class="n">indclose</span><span class="p">,:],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
                <span class="n">local_maxi</span><span class="p">[</span><span class="n">imax</span><span class="p">,:]</span><span class="o">=</span><span class="n">mean_loc</span>
                <span class="n">indclose</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">indclose</span><span class="p">,</span><span class="n">imax</span><span class="p">)</span>
                <span class="n">close_inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">close_inds</span><span class="p">,</span><span class="n">indclose</span><span class="p">)</span>
                <span class="n">local_maxi</span><span class="p">[</span><span class="n">indclose</span><span class="p">,:]</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">maxsize</span>
                <span class="c1">#print(f&#39;{imax} close to {indclose}&#39;)</span>
        <span class="n">indkeep</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">local_maxi</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">),</span><span class="n">close_inds</span><span class="p">)</span>
        <span class="n">local_maxi</span><span class="o">=</span><span class="n">local_maxi</span><span class="p">[</span><span class="n">indkeep</span><span class="p">,:]</span>
        <span class="n">local_maxi</span><span class="o">=</span><span class="n">local_maxi</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">footprint_shape</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">local_maxi</span></div>


<div class="viewcode-block" id="save_for_viewing">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.save_for_viewing">[docs]</a>
<span class="k">def</span> <span class="nf">save_for_viewing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">fname</span><span class="p">,</span><span class="n">metadata</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves data and optional metadata to a specified file using serialization. The function uses Python&#39;s pickle module</span>
<span class="sd">    to serialize the data and metadata into a single file. It allows for optional overwriting of existing files.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data : any serializable object</span>
<span class="sd">        The primary data to be saved. This can be any object that pickle can serialize.</span>
<span class="sd">    fname : str</span>
<span class="sd">        The file name or path where the data will be saved. If only a name is provided, the file will be saved in the </span>
<span class="sd">        current working directory.</span>
<span class="sd">    metadata : dict, optional</span>
<span class="sd">        Additional metadata to be saved along with the main data. This should be a dictionary containing the metadata.</span>
<span class="sd">    overwrite : bool, optional</span>
<span class="sd">        If True, will overwrite the existing file without any warnings. If False, the function will not overwrite </span>
<span class="sd">        an existing file and will return 1 if the file already exists.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Returns 0 if the file was successfully saved. Returns 1 if the file already exists and overwrite is False.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data = {&#39;a&#39;: 1, &#39;b&#39;: 2}</span>
<span class="sd">    &gt;&gt;&gt; metadata = {&#39;description&#39;: &#39;Sample data&#39;}</span>
<span class="sd">    &gt;&gt;&gt; save_for_viewing(data, &#39;example.pkl&#39;, metadata=metadata)</span>
<span class="sd">    0</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function is particularly useful for saving intermediate processing stages in data analysis pipelines where</span>
<span class="sd">      both data and contextual metadata are important.</span>
<span class="sd">    - Care should be taken with the `overwrite` parameter to avoid unintentional data loss.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        Raises an exception if there are issues during the file opening or writing process not related to overwriting</span>
<span class="sd">        existing files.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">data_object</span><span class="o">=</span><span class="p">[</span><span class="n">data</span><span class="p">,</span><span class="n">metadata</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
        <span class="n">objFileHandler</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;wb&#39;</span><span class="p">)</span>
        <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">objFileHandler</span><span class="p">,</span><span class="n">protocol</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">objFileHandler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">objFileHandler</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;xb&#39;</span><span class="p">)</span>
            <span class="n">pickle</span><span class="o">.</span><span class="n">dump</span><span class="p">(</span><span class="n">data</span><span class="p">,</span><span class="n">objFileHandler</span><span class="p">,</span><span class="n">protocol</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
            <span class="n">objFileHandler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="mi">0</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;file may exist, use overwrite=True&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="load_for_viewing">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.load_for_viewing">[docs]</a>
<span class="k">def</span> <span class="nf">load_for_viewing</span><span class="p">(</span><span class="n">fname</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Loads data and optional metadata from a specified file that was saved using Python&#39;s pickle serialization. </span>
<span class="sd">    This function is useful for retrieving saved datasets and their associated metadata for further processing or analysis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    fname : str</span>
<span class="sd">        The file name or path from which the data will be loaded. If only a name is provided, it assumes the file is </span>
<span class="sd">        in the current working directory.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    list or int</span>
<span class="sd">        Returns a list containing the data and metadata if the file is successfully loaded. Returns 1 if there was an </span>
<span class="sd">        error during the loading process.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; datalist = load_for_viewing(&#39;example.pkl&#39;)</span>
<span class="sd">    &gt;&gt;&gt; data, metadata = datalist[0], datalist[1]</span>
<span class="sd">    &gt;&gt;&gt; print(metadata)</span>
<span class="sd">    {&#39;description&#39;: &#39;Sample data&#39;}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - Ensure that the file specified exists and was written in the appropriate format by `save_for_viewing` or </span>
<span class="sd">      another function using Python&#39;s pickle module.</span>
<span class="sd">    - This function attempts to handle exceptions gracefully and will notify the user if the load operation fails.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        Raises an exception if the file cannot be opened, if reading the file fails, or if the data cannot be </span>
<span class="sd">        deserialized. Specific errors during the loading process are not caught explicitly but will prompt a general </span>
<span class="sd">        failure message.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">objFileHandler</span><span class="o">=</span><span class="nb">open</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span><span class="s1">&#39;rb&#39;</span><span class="p">)</span>
        <span class="n">datalist</span><span class="o">=</span><span class="n">pickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">states_object</span><span class="p">)</span>
        <span class="n">objFileHandler</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">datalist</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;load fail&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="get_voronoi_masks">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_voronoi_masks">[docs]</a>
<span class="k">def</span> <span class="nf">get_voronoi_masks</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span><span class="n">imgM</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates Voronoi masks based on the centers of mass of labeled regions within an image. This function is </span>
<span class="sd">    typically used in image segmentation tasks where each label represents a distinct object or region, and the </span>
<span class="sd">    goal is to create a Voronoi diagram to partition the space among the nearest labels.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : ndarray</span>
<span class="sd">        A 2D array where each unique non-zero integer represents a distinct labeled region.</span>
<span class="sd">    imgM : ndarray, optional</span>
<span class="sd">        A binary mask defining the foreground of the image. If None, the entire image is considered as the foreground.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D array of the same shape as `labels`, where each cell contains the label of the nearest labeled region,</span>
<span class="sd">        forming Voronoi regions.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; labels = np.array([[0, 0, 1], [0, 2, 0], [3, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; voronoi_masks = get_voronoi_masks(labels)</span>
<span class="sd">    &gt;&gt;&gt; print(voronoi_masks)</span>
<span class="sd">    [[2 2 1]</span>
<span class="sd">     [2 2 1]</span>
<span class="sd">     [3 3 3]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function uses Euclidean distance to determine the nearest labeled center for each pixel.</span>
<span class="sd">    - Voronoi masks are useful for delineating boundaries between adjacent regions based on proximity to their</span>
<span class="sd">      respective centers of mass.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        Raises an exception if there is an error in calculating the centers of mass or assigning Voronoi regions.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">imgM</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;no foreground mask provided (imgM), using entire image&#39;</span><span class="p">)</span>
        <span class="n">imgM</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">0</span>
    <span class="n">indBackground</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_not</span><span class="p">(</span><span class="n">imgM</span><span class="p">))</span>
    <span class="n">nuc_centers</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">imgM</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">))</span>
    <span class="n">nuc_centers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">nuc_centers</span><span class="p">)</span>
    <span class="n">nuc_clusters</span><span class="o">=</span><span class="n">pyemma</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">clustering</span><span class="o">.</span><span class="n">AssignCenters</span><span class="p">(</span><span class="n">nuc_centers</span><span class="p">,</span> <span class="n">metric</span><span class="o">=</span><span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="n">nx</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span> <span class="n">ny</span><span class="o">=</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">xx</span><span class="p">,</span><span class="n">yy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">nx</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ny</span><span class="p">),</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">)</span>
    <span class="n">voronoi_masks</span><span class="o">=</span><span class="n">nuc_clusters</span><span class="o">.</span><span class="n">assign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xx</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">yy</span><span class="o">.</span><span class="n">flatten</span><span class="p">()])</span><span class="o">.</span><span class="n">T</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    <span class="n">voronoi_masks</span><span class="p">[</span><span class="n">indBackground</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="n">masks_cyto</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">voronoi_masks</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">voronoi_masks</span><span class="p">))</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">mskc</span> <span class="o">=</span> <span class="n">voronoi_masks</span><span class="o">==</span><span class="n">ic</span>
        <span class="n">labelsc</span> <span class="o">=</span> <span class="n">ndimage</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">mskc</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">centers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">mskc</span><span class="p">,</span><span class="n">labels</span><span class="o">=</span><span class="n">labelsc</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labelsc</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>
        <span class="n">nuc_center</span><span class="o">=</span><span class="n">nuc_centers</span><span class="p">[</span><span class="n">ic</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dists</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">centers</span><span class="o">-</span><span class="n">nuc_center</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">closestCC</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">largestCC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labelsc</span><span class="o">.</span><span class="n">flat</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span><span class="o">+</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">closestCC</span> <span class="o">!=</span> <span class="n">largestCC</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;cell: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; nchunks: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">centers</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; closest: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">closestCC</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; largest: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">largestCC</span><span class="p">))</span>
        <span class="n">largestCC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">bincount</span><span class="p">(</span><span class="n">labelsc</span><span class="o">.</span><span class="n">flat</span><span class="p">)[</span><span class="mi">1</span><span class="p">:])</span><span class="o">+</span><span class="mi">1</span>
        <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labelsc</span> <span class="o">==</span> <span class="n">closestCC</span><span class="p">)</span>
        <span class="n">npixc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labelsc</span> <span class="o">==</span> <span class="n">closestCC</span><span class="p">)</span>
        <span class="n">masks_cyto</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="n">ic</span>
    <span class="k">return</span> <span class="n">masks_cyto</span></div>


<div class="viewcode-block" id="get_cyto_minus_nuc_labels">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_cyto_minus_nuc_labels">[docs]</a>
<span class="k">def</span> <span class="nf">get_cyto_minus_nuc_labels</span><span class="p">(</span><span class="n">labels_cyto</span><span class="p">,</span><span class="n">labels_nuc</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generates new cytoplasmic labels where nuclear labels are excluded. This function adjusts cytoplasmic</span>
<span class="sd">    labels to ensure they do not overlap with nuclear labels by dilating nuclear areas and subtracting them</span>
<span class="sd">    from corresponding cytoplasmic regions. This method helps in distinguishing between nuclear and </span>
<span class="sd">    cytoplasmic components of a cell, often necessary for detailed cellular analysis.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels_cyto : ndarray</span>
<span class="sd">        A 2D array where each integer represents a unique cytoplasmic region.</span>
<span class="sd">    labels_nuc : ndarray</span>
<span class="sd">        A 2D array of the same shape as `labels_cyto`, where each integer represents a unique nuclear region.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D array of the same shape as `labels_cyto`, containing the refined cytoplasmic labels with nuclear</span>
<span class="sd">        regions excluded.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; labels_cyto = np.array([[1, 1, 0], [1, 1, 0], [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; labels_nuc = np.array([[0, 1, 0], [0, 1, 0], [0, 0, 0]])</span>
<span class="sd">    &gt;&gt;&gt; labels_cyto_new = get_cyto_minus_nuc_labels(labels_cyto, labels_nuc)</span>
<span class="sd">    &gt;&gt;&gt; print(labels_cyto_new)</span>
<span class="sd">    [[1 0 0]</span>
<span class="sd">     [1 0 0]</span>
<span class="sd">     [0 0 0]]</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function ensures that nuclear regions are excluded from the cytoplasmic labels by first dilating</span>
<span class="sd">      the nuclear masks and then eroding them before subtracting from the cytoplasmic masks.</span>
<span class="sd">    - The output labels for cytoplasmic areas are adjusted to ensure no overlap with nuclear regions.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    Exception</span>
<span class="sd">        Raises an exception if there is an error during the label processing steps.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">labels_cyto_new</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">labels_cyto</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels_nuc</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">mskc_cyto</span><span class="o">=</span><span class="n">labels_cyto</span><span class="o">==</span><span class="n">ic</span>
        <span class="n">mskc_nuc</span><span class="o">=</span><span class="n">labels_nuc</span><span class="o">==</span><span class="n">ic</span>
        <span class="n">mskc_cyto</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mskc_cyto</span><span class="p">,</span><span class="n">mskc_nuc</span><span class="p">)</span> <span class="c1">#make sure cyto masks include nuc masks</span>
        <span class="n">mskc_cyto</span><span class="o">=</span><span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_dilation</span><span class="p">(</span><span class="n">mskc_cyto</span><span class="p">)</span>
        <span class="n">mskc_nuc</span><span class="o">=</span><span class="n">skimage</span><span class="o">.</span><span class="n">morphology</span><span class="o">.</span><span class="n">binary_erosion</span><span class="p">(</span><span class="n">mskc_nuc</span><span class="p">)</span>
        <span class="n">mskc_cyto</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_or</span><span class="p">(</span><span class="n">mskc_cyto</span><span class="p">,</span><span class="n">mskc_nuc</span><span class="p">)</span> <span class="c1">#make sure cyto masks include nuc masks</span>
        <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mskc_cyto</span><span class="p">)</span>
        <span class="n">labels_cyto_new</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="n">ic</span>
    <span class="n">ind_nuc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels_nuc</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">labels_cyto_new</span><span class="p">[</span><span class="n">ind_nuc</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">return</span> <span class="n">labels_cyto_new</span></div>


<div class="viewcode-block" id="get_cell_intensities">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_cell_intensities">[docs]</a>
<span class="k">def</span> <span class="nf">get_cell_intensities</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">labels</span><span class="p">,</span><span class="n">averaging</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">is_3D</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the sum or average intensity for each cell in a labeled image or image stack. This function</span>
<span class="sd">    handles both 2D and 3D images and can operate on multi-channel data, summing or averaging the intensities</span>
<span class="sd">    for each label in each channel.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The image or image stack from which to calculate intensities. Can be 2D, 3D, or higher dimensions</span>
<span class="sd">        if channels are involved.</span>
<span class="sd">    labels : ndarray</span>
<span class="sd">        An integer array of the same shape as `img` where each unique non-zero value indicates a distinct</span>
<span class="sd">        cell region.</span>
<span class="sd">    averaging : bool, optional</span>
<span class="sd">        If True, calculate the mean intensity for each cell. If False, calculate the total intensity.</span>
<span class="sd">        Default is False.</span>
<span class="sd">    is_3D : bool, optional</span>
<span class="sd">        Set to True if `img` includes 3D spatial data (as opposed to 2D images with multiple channels).</span>
<span class="sd">        Default is False.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 1D array of intensities for each cell. If `img` includes multiple channels, the result will be</span>
<span class="sd">        a 2D array with one row per cell and one column per channel.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; img = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])</span>
<span class="sd">    &gt;&gt;&gt; labels = np.array([[1, 1], [2, 2]])</span>
<span class="sd">    &gt;&gt;&gt; get_cell_intensities(img, labels, averaging=True)</span>
<span class="sd">    array([2.5, 6.5])</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - If `averaging` is False, the function sums the pixel values for each cell; if True, it averages them.</span>
<span class="sd">    - The function handles multi-channel images correctly for both 2D and 3D cases, adjusting its behavior</span>
<span class="sd">      based on the `is_3D` parameter.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">ncells</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
    <span class="n">cell_intensities</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncells</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_3D</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">cell_intensities</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncells</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">indcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">i</span><span class="p">)</span> <span class="c1">#picks out image pixels where each single-cell is labeled</span>
            <span class="k">for</span> <span class="n">ichannel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">averaging</span><span class="p">:</span>
                    <span class="n">cell_intensities</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ichannel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">indcell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indcell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ichannel</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_intensities</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ichannel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">indcell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indcell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">ichannel</span><span class="p">])</span>
    <span class="k">if</span> <span class="n">is_3D</span> <span class="ow">and</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="o">&gt;</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">cell_intensities</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ncells</span><span class="p">,</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncells</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">indcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">i</span><span class="p">)</span> <span class="c1">#picks out image pixels where each single-cell is labeled</span>
            <span class="k">for</span> <span class="n">ichannel</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">3</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">averaging</span><span class="p">:</span>
                    <span class="n">cell_intensities</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ichannel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">indcell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indcell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indcell</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ichannel</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">cell_intensities</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">ichannel</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">indcell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">indcell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">indcell</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">ichannel</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cell_intensities</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">ncells</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">ncells</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">indcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">labels</span><span class="o">==</span><span class="n">i</span><span class="p">)</span> <span class="c1">#picks out image pixels where each single-cell is labeled</span>
            <span class="k">if</span> <span class="n">averaging</span><span class="p">:</span>
                <span class="n">cell_intensities</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">indcell</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cell_intensities</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">img</span><span class="p">[</span><span class="n">indcell</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">cell_intensities</span></div>


<div class="viewcode-block" id="get_registrations">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_registrations">[docs]</a>
<span class="k">def</span> <span class="nf">get_registrations</span><span class="p">(</span><span class="n">imgs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Apply the pystackreg library&#39;s StackReg algorithm to compute translations needed to register a stack of images along the Z-axis. This function assumes the stack is in the form (Z, X, Y) and uses the &#39;previous&#39; image as a reference for registration.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imgs : ndarray</span>
<span class="sd">        A 3D numpy array representing a stack of 2D images. The stack&#39;s first dimension corresponds to the Z-axis, and each slice (X, Y) is a 2D image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        A 2D numpy array with shape (NZ, 3), where NZ is the number of images in the stack. Each row contains three values:</span>
<span class="sd">        - the radial angle (currently unused and set to 0),</span>
<span class="sd">        - the x-translation,</span>
<span class="sd">        - the y-translation.</span>
<span class="sd">        These translations are computed to register each image with respect to the previous one in the stack.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The radial angle computation is commented out in the current implementation and could be included for more complex transformations such as rotation. The function primarily outputs translations in the x and y directions as computed by the StackReg algorithm.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; imgs = np.random.rand(10, 256, 256)  # Simulated stack of 10 images</span>
<span class="sd">    &gt;&gt;&gt; registrations = get_registrations(imgs)</span>
<span class="sd">    &gt;&gt;&gt; print(registrations)</span>
<span class="sd">    array([[ 0. , 5.1, -3.2],</span>
<span class="sd">           [ 0. , 2.3, -1.5],</span>
<span class="sd">           ...,</span>
<span class="sd">           [ 0. , 0.2, -0.1]])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">nimg</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tSet</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nimg</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
    <span class="n">sr</span> <span class="o">=</span> <span class="n">StackReg</span><span class="p">(</span><span class="n">StackReg</span><span class="o">.</span><span class="n">TRANSLATION</span><span class="p">)</span>
    <span class="n">tmats</span> <span class="o">=</span> <span class="n">sr</span><span class="o">.</span><span class="n">register_stack</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">reference</span><span class="o">=</span><span class="s1">&#39;previous&#39;</span><span class="p">)</span>
    <span class="n">nframes</span><span class="o">=</span><span class="n">tmats</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">iframe</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nframes</span><span class="p">):</span>
        <span class="n">tmatrix</span><span class="o">=</span><span class="n">tmats</span><span class="p">[</span><span class="n">iframe</span><span class="p">,:,:]</span>
        <span class="c1">#tSet[iframe,0]=np.arctan2(-tmatrix[0,1],tmatrix[0,0])</span>
        <span class="n">tSet</span><span class="p">[</span><span class="n">iframe</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">tmatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">tSet</span><span class="p">[</span><span class="n">iframe</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">tmatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;frame &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iframe</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; transx: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tSet</span><span class="p">[</span><span class="n">iframe</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39; transy: &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">tSet</span><span class="p">[</span><span class="n">iframe</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">tSet</span> <span class="c1">#stack translations</span></div>


<div class="viewcode-block" id="get_tf_matrix_2d">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_tf_matrix_2d">[docs]</a>
<span class="k">def</span> <span class="nf">get_tf_matrix_2d</span><span class="p">(</span><span class="n">t</span><span class="p">,</span><span class="n">img</span><span class="p">,</span><span class="n">s</span><span class="o">=</span><span class="mf">1.</span><span class="p">):</span>
    <span class="n">nx</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ny</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">centerx</span><span class="o">=</span><span class="n">nx</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">centery</span><span class="o">=</span><span class="n">ny</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">th</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">trans</span><span class="o">=</span><span class="n">t</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">tmatrix</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
    <span class="n">tmatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>
    <span class="n">tmatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=-</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>
    <span class="n">tmatrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=-</span><span class="n">centerx</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">+</span><span class="n">centery</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">+</span><span class="n">centerx</span><span class="o">+</span><span class="n">trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">tmatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>
    <span class="n">tmatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)</span>
    <span class="n">tmatrix</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=-</span><span class="n">centerx</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">-</span><span class="n">centery</span><span class="o">*</span><span class="n">s</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">th</span><span class="p">)</span><span class="o">+</span><span class="n">centery</span><span class="o">+</span><span class="n">trans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tmatrix</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="mf">1.0</span>
    <span class="k">return</span> <span class="n">tmatrix</span></div>


<div class="viewcode-block" id="transform_image">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.transform_image">[docs]</a>
<span class="k">def</span> <span class="nf">transform_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">tf_matrix</span><span class="p">,</span><span class="n">inverse_tform</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">pad_dims</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="o">**</span><span class="n">ndimage_args</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies a geometric transformation to an image using a specified transformation matrix.</span>
<span class="sd">    It can handle 2D and 3D transformations, supports padding, and can invert the transformation.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The image to be transformed. Can be 2D or 3D.</span>
<span class="sd">    tf_matrix : ndarray</span>
<span class="sd">        The transformation matrix, which must be either 3x3 for 2D transformations or 4x4 for 3D.</span>
<span class="sd">    inverse_tform : bool, optional</span>
<span class="sd">        If True, the inverse of the transformation matrix is applied. Default is False.</span>
<span class="sd">    pad_dims : tuple, optional</span>
<span class="sd">        Dimensions for padding the image before applying the transformation. Expected format is</span>
<span class="sd">        (pad_before, pad_after) for each axis.</span>
<span class="sd">    **ndimage_args : dict</span>
<span class="sd">        Additional keyword arguments passed to `scipy.ndimage.affine_transform`.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    img_tf : ndarray</span>
<span class="sd">        The transformed image, with the same data type as the input image.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If an invalid transformation matrix is provided or if the image array is flat (1D).</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; img = np.random.rand(100, 100)</span>
<span class="sd">    &gt;&gt;&gt; tf_matrix = np.array([[1, 0, 10], [0, 1, -10], [0, 0, 1]])</span>
<span class="sd">    &gt;&gt;&gt; transformed_img = transform_image(img, tf_matrix)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">tf_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span> <span class="ow">or</span> <span class="n">tf_matrix</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
        <span class="k">pass</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;provide valid transformation matrix&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="k">if</span> <span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="o">==</span><span class="mi">1</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;reshape flat array to image first&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">issubdtype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">integer</span><span class="p">):</span>
        <span class="k">if</span> <span class="s1">&#39;ndimage_args&#39;</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">():</span>
            <span class="k">if</span> <span class="s1">&#39;order&#39;</span> <span class="ow">in</span> <span class="n">ndimage_args</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ndimage_args</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;with integer arrays spline order of 0 recommended, </span><span class="si">{</span><span class="n">ndimage_args</span><span class="p">[</span><span class="s2">&quot;order&quot;</span><span class="p">]</span><span class="si">}</span><span class="s1"> requested&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ndimage_args</span><span class="p">[</span><span class="s1">&#39;order&#39;</span><span class="p">]</span><span class="o">=</span><span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ndimage_args</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;order&#39;</span><span class="p">:</span> <span class="mi">0</span><span class="p">}</span>
    <span class="n">tform</span> <span class="o">=</span> <span class="n">tf</span><span class="o">.</span><span class="n">EuclideanTransform</span><span class="p">(</span><span class="n">matrix</span><span class="o">=</span><span class="n">tf_matrix</span><span class="p">,</span><span class="n">dimensionality</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">pad_dims</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">img</span><span class="o">=</span><span class="n">pad_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="o">*</span><span class="n">pad_dims</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">inverse_tform</span><span class="p">:</span>
        <span class="n">img_tf</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">inverse</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">ndimage_args</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">img_tf</span><span class="o">=</span><span class="n">ndimage</span><span class="o">.</span><span class="n">affine_transform</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">tform</span><span class="o">.</span><span class="n">params</span><span class="p">,</span> <span class="o">**</span><span class="n">ndimage_args</span><span class="p">)</span>
    <span class="n">img_tf</span><span class="o">=</span><span class="n">img_tf</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">img</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_tf</span></div>


<div class="viewcode-block" id="pad_image">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.pad_image">[docs]</a>
<span class="k">def</span> <span class="nf">pad_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="o">*</span><span class="n">maxdims</span><span class="p">,</span><span class="n">padvalue</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pads an image to the specified dimensions using a constant value, with optional padding value specification. </span>
<span class="sd">    The function ensures the new image has central alignment relative to the original image dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The image array to be padded. Can be 2D or 3D.</span>
<span class="sd">    *maxdims : int</span>
<span class="sd">        Variable length argument list specifying the target dimensions for padding. The number of dimensions</span>
<span class="sd">        provided should match the dimensionality of `img`.</span>
<span class="sd">    padvalue : int or float, optional</span>
<span class="sd">        The value used to fill in the padding areas. Default is 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The padded image array, now resized to `maxdims`. If the dimensions of `maxdims` are less than or equal</span>
<span class="sd">        to the original dimensions, the image will be trimmed instead.</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    ValueError</span>
<span class="sd">        If the number of dimensions provided in `maxdims` does not match the dimensionality of `img`.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; img = np.array([[1, 2], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; padded_img = pad_image(img, 4, 4)</span>
<span class="sd">    &gt;&gt;&gt; print(padded_img)</span>
<span class="sd">    [[0 0 0 0]</span>
<span class="sd">     [0 1 2 0]</span>
<span class="sd">     [0 3 4 0]</span>
<span class="sd">     [0 0 0 0]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1">#print(maxdims)</span>
    <span class="n">ndim</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">maxdims</span><span class="p">)</span>
    <span class="n">img_ndim</span><span class="o">=</span><span class="n">img</span><span class="o">.</span><span class="n">ndim</span>
    <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="n">img_ndim</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;maxdims and img dim must match&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">1</span>
    <span class="n">npads</span><span class="o">=</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="n">ndim</span>
    <span class="k">for</span> <span class="n">idim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">ndim</span><span class="p">):</span>
        <span class="n">npads</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">((</span><span class="n">maxdims</span><span class="p">[</span><span class="n">idim</span><span class="p">]</span><span class="o">-</span><span class="n">img</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idim</span><span class="p">])</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">img</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">img</span><span class="p">,((</span><span class="n">npads</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">npads</span><span class="p">[</span><span class="mi">0</span><span class="p">]),(</span><span class="n">npads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">npads</span><span class="p">[</span><span class="mi">1</span><span class="p">])),</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span><span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="n">padvalue</span><span class="p">,</span><span class="n">padvalue</span><span class="p">))</span>
        <span class="n">img</span><span class="o">=</span><span class="n">img</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxdims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">:</span><span class="n">maxdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
    <span class="k">if</span> <span class="n">ndim</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">img</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">img</span><span class="p">,((</span><span class="n">npads</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">npads</span><span class="p">[</span><span class="mi">0</span><span class="p">]),(</span><span class="n">npads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">npads</span><span class="p">[</span><span class="mi">1</span><span class="p">]),(</span><span class="n">npads</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span><span class="n">npads</span><span class="p">[</span><span class="mi">2</span><span class="p">])),</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span><span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="n">padvalue</span><span class="p">,</span><span class="n">padvalue</span><span class="p">))</span>
        <span class="n">img</span><span class="o">=</span><span class="n">img</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">maxdims</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mi">0</span><span class="p">:</span><span class="n">maxdims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="mi">0</span><span class="p">:</span><span class="n">maxdims</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="k">return</span> <span class="n">img</span></div>


<div class="viewcode-block" id="get_registration_expansions">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_registration_expansions">[docs]</a>
<span class="k">def</span> <span class="nf">get_registration_expansions</span><span class="p">(</span><span class="n">tf_matrix_set</span><span class="p">,</span><span class="o">*</span><span class="n">imgdims</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the new padded dimensions for an image based on the translations found in a set of transformation matrices.</span>
<span class="sd">    Adjusts the transformation matrices to centralize the image after applying translations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tf_matrix_set : ndarray</span>
<span class="sd">        An array of transformation matrices of shape (N, D+1, D+1) where N is the number of frames and D is the number of dimensions.</span>
<span class="sd">    *imgdims : int</span>
<span class="sd">        Variable length argument list specifying the original dimensions of the images (Z, Y, X) or (Y, X).</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    tuple</span>
<span class="sd">        A tuple containing:</span>
<span class="sd">        - tf_matrix_set : ndarray, the adjusted transformation matrices centered based on the maximum translation.</span>
<span class="sd">        - pad_dims : tuple, the new dimensions for padding the image to accommodate all translations.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; tf_matrix_set = np.array([[[1, 0, 10], [0, 1, 20], [0, 0, 1]],</span>
<span class="sd">    ...                           [[1, 0, -5], [0, 1, 15], [0, 0, 1]]])</span>
<span class="sd">    &gt;&gt;&gt; imgdims = (100, 200)  # Y, X dimensions</span>
<span class="sd">    &gt;&gt;&gt; adjusted_tf, pad_dims = get_registration_expansions(tf_matrix_set, *imgdims)</span>
<span class="sd">    &gt;&gt;&gt; print(pad_dims)</span>
<span class="sd">    (105, 225)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The function automatically adjusts the translation vectors in tf_matrix_set to ensure the entire image remains</span>
<span class="sd">      visible within the new dimensions after transformation.</span>
<span class="sd">    - The calculated `pad_dims` is large enough to fit the original image plus the maximum translation offsets.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">tSet</span><span class="o">=</span><span class="n">tf_matrix_set</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">tSet</span><span class="o">=</span><span class="n">tSet</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tSet</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">max_trans</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tSet</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgdims</span><span class="p">)</span><span class="o">==</span><span class="mi">2</span><span class="p">:</span>
        <span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">])</span>
        <span class="n">tSet</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">tSet</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">pad_dims</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">imgdims</span><span class="p">)</span><span class="o">==</span><span class="mi">3</span><span class="p">:</span>
        <span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">,(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">/</span><span class="mf">2.</span><span class="p">])</span>
        <span class="n">tSet</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">tSet</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">tSet</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">/</span><span class="mf">2.</span>
        <span class="n">pad_dims</span><span class="o">=</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span><span class="nb">int</span><span class="p">(</span><span class="n">imgdims</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="n">max_trans</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">tf_matrix_set</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">][:,</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span>
    <span class="k">return</span> <span class="n">tf_matrix_set</span><span class="p">,</span><span class="n">pad_dims</span></div>


<div class="viewcode-block" id="expand_registered_images">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.expand_registered_images">[docs]</a>
<span class="k">def</span> <span class="nf">expand_registered_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span><span class="n">tSet</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Applies transformations to a stack of images and expands them so that they align according to the provided transformation set.</span>
<span class="sd">    This function is useful for aligning images based on calculated translations and optionally rotations.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imgs : ndarray or list of ndarrays</span>
<span class="sd">        A stack of images where each image has dimensions (Z, X, Y). If a list is provided, it will be converted to an ndarray.</span>
<span class="sd">    tSet : ndarray</span>
<span class="sd">        An array of transformations for each image. Each transformation is a tuple or list of (radial angle, x-translation, y-translation),</span>
<span class="sd">        where angle is in degrees and translations are in pixels.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    ndarray</span>
<span class="sd">        An ndarray containing the expanded and registered image stack. The dimensions of the output images will be adjusted to</span>
<span class="sd">        accommodate the maximum translation offsets to ensure all images fit within the new dimensions.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    &gt;&gt;&gt; import numpy as np</span>
<span class="sd">    &gt;&gt;&gt; imgs = [np.random.rand(100, 100) for _ in range(10)]  # Create a list of random images</span>
<span class="sd">    &gt;&gt;&gt; tSet = np.array([[0, 10, -5] for _ in range(10)])  # Example transformations</span>
<span class="sd">    &gt;&gt;&gt; registered_imgs = expand_registered_images(imgs, tSet)</span>
<span class="sd">    &gt;&gt;&gt; print(registered_imgs.shape)</span>
<span class="sd">    (10, 105, 100)  # Output dimensions may vary based on transformations</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - The transformations are applied using an affine transformation, where translations are adjusted to ensure no image content is lost.</span>
<span class="sd">    - The function automatically pads images based on the maximum translations specified in `tSet` to prevent image cropping.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">list</span><span class="p">:</span>
        <span class="n">imgs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
    <span class="n">nimg</span><span class="o">=</span><span class="n">imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">tSet</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">nimg</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;transformations and image stack do not match&#39;</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="n">tSet</span><span class="o">=</span><span class="n">tSet</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">tSet</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">maxdx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">maxdy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">nx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:])[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ny</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">imgs</span><span class="p">[</span><span class="mi">0</span><span class="p">,:,:])[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">maxd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">nx</span><span class="o">+</span><span class="n">maxdx</span><span class="p">,</span><span class="n">ny</span><span class="o">+</span><span class="n">maxdy</span><span class="p">]))</span>
    <span class="n">imgst</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">nimg</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">maxdx</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">nx</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">maxdy</span><span class="o">/</span><span class="mi">2</span><span class="o">+</span><span class="n">ny</span><span class="p">)))</span>
    <span class="n">center</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([(</span><span class="n">nx</span><span class="o">+</span><span class="n">maxdx</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">,(</span><span class="n">ny</span><span class="o">+</span><span class="n">maxdy</span><span class="p">)</span><span class="o">/</span><span class="mf">2.</span><span class="p">])</span>
    <span class="n">tSet</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">maxdx</span><span class="o">/</span><span class="mf">2.</span>
    <span class="n">tSet</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">=</span><span class="n">tSet</span><span class="p">[:,</span><span class="mi">2</span><span class="p">]</span><span class="o">-</span><span class="n">maxdy</span><span class="o">/</span><span class="mf">2.</span>
    <span class="k">for</span> <span class="n">iS</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nimg</span><span class="p">):</span>
        <span class="n">img</span><span class="o">=</span><span class="n">imgs</span><span class="p">[</span><span class="n">iS</span><span class="p">,:,:]</span>
        <span class="n">img</span><span class="o">=</span><span class="n">pad_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="nb">int</span><span class="p">(</span><span class="n">nx</span><span class="o">+</span><span class="n">maxdx</span><span class="o">/</span><span class="mi">2</span><span class="p">),</span><span class="nb">int</span><span class="p">(</span><span class="n">ny</span><span class="o">+</span><span class="n">maxdy</span><span class="o">/</span><span class="mi">2</span><span class="p">))</span>
        <span class="n">img</span><span class="o">=</span><span class="n">transform_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">tSet</span><span class="p">[</span><span class="n">iS</span><span class="p">])</span>
        <span class="n">imgst</span><span class="p">[</span><span class="n">iS</span><span class="p">,:,:]</span><span class="o">=</span><span class="n">img</span>
    <span class="k">return</span> <span class="n">imgst</span></div>


<div class="viewcode-block" id="create_h5">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.create_h5">[docs]</a>
<span class="k">def</span> <span class="nf">create_h5</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">dic</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates an HDF5 file and stores data from a dictionary into it under a specified group. The function checks if the file</span>
<span class="sd">    already exists and handles it based on the &#39;overwrite&#39; parameter.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The name of the file to create. This should include the path if the file is not to be created in the current directory.</span>
<span class="sd">    dic : dict</span>
<span class="sd">        The dictionary containing the data to be stored. This dictionary will be saved in the HDF5 file under the &#39;/metadata/&#39; group.</span>
<span class="sd">    overwrite : bool, optional</span>
<span class="sd">        If True, if the file exists it will be overwritten. If False and the file exists, the function will return an error and not overwrite the file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    int</span>
<span class="sd">        Returns 0 if the file was created and data was successfully saved. Returns 1 if an error occurred, such as if the file already exists and</span>
<span class="sd">        &#39;overwrite&#39; is False, or if there is an issue in writing the data to the file.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; data = {&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: &#39;value2&#39;}</span>
<span class="sd">    &gt;&gt;&gt; result = create_h5(&#39;data.h5&#39;, data, overwrite=False)</span>
<span class="sd">    &gt;&gt;&gt; print(result)  # If file does not exist or overwrite is True</span>
<span class="sd">    0</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    - This function uses the &#39;utilities.save_dict_to_h5&#39; to save the dictionary into the HDF5 file.</span>
<span class="sd">    - It is important to handle exceptions during the file operation to avoid partial writes or file corruption.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">filename</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1"> already exists!&#39;</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
            <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">utilities</span><span class="o">.</span><span class="n">save_dict_to_h5</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span><span class="n">f</span><span class="p">,</span><span class="s1">&#39;/metadata/&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">0</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">error</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;error saving </span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">error</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
        <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="mi">1</span></div>


<div class="viewcode-block" id="save_frame_h5">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.save_frame_h5">[docs]</a>
<span class="k">def</span> <span class="nf">save_frame_h5</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="n">frame</span><span class="p">,</span><span class="n">img</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">msks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">fmsk</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">timestamp</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Saves data related to a specific frame into an HDF5 file. This function can handle images, masks, foreground masks, and features.</span>
<span class="sd">    Each type of data is saved into a distinct dataset within the file. Existing data can be overwritten if specified.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">        The name of the HDF5 file to which the data will be saved.</span>
<span class="sd">    frame : int</span>
<span class="sd">        The frame number associated with the data to be saved.</span>
<span class="sd">    img : ndarray, optional</span>
<span class="sd">        The image data to save. If provided, it will be saved under &#39;/images/img_&lt;frame&gt;/image&#39;.</span>
<span class="sd">    msks : ndarray, optional</span>
<span class="sd">        The mask data to save. If provided, it will be saved under &#39;/images/img_&lt;frame&gt;/mask&#39;.</span>
<span class="sd">    fmsk : ndarray, optional</span>
<span class="sd">        The foreground mask data to save. If provided, it will be saved under &#39;/images/img_&lt;frame&gt;/fmsk&#39;.</span>
<span class="sd">    features : ndarray, optional</span>
<span class="sd">        The features data to save. If provided, it will be saved under &#39;/images/img_&lt;frame&gt;/features&#39;.</span>
<span class="sd">    overwrite : bool, optional</span>
<span class="sd">        Whether to overwrite existing datasets. If False and a dataset exists, it will not overwrite and will print a message.</span>
<span class="sd">    timestamp : float, optional</span>
<span class="sd">        The timestamp to associate with the data. If not provided, the frame number is used as the timestamp.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; img_data = np.random.rand(256, 256)</span>
<span class="sd">    &gt;&gt;&gt; mask_data = np.random.randint(0, 2, (256, 256))</span>
<span class="sd">    &gt;&gt;&gt; save_frame_h5(&#39;example.h5&#39;, frame=1, img=img_data, msks=mask_data)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function opens the HDF5 file in append mode (&#39;a&#39;), which allows adding new data without deleting existing data.</span>
<span class="sd">    Each type of data is stored in a specific dataset structured as &#39;/images/img_&lt;frame&gt;/&lt;datatype&gt;&#39;.</span>
<span class="sd">    If overwrite is True and the dataset already exists, it will delete the old dataset before creating a new one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">iS</span><span class="o">=</span><span class="n">frame</span>
    <span class="k">if</span> <span class="n">timestamp</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">timestamp</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">frame</span><span class="p">)</span>
    <span class="n">f</span><span class="o">=</span><span class="n">h5py</span><span class="o">.</span><span class="n">File</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span><span class="s1">&#39;a&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">img</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dsetName</span><span class="o">=</span><span class="s2">&quot;/images/img_</span><span class="si">%d</span><span class="s2">/image&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">img</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;image &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; exists</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">img</span><span class="p">))</span>
                <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">img</span>
                <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    ...overwritten</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">msks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dsetName</span><span class="o">=</span><span class="s2">&quot;/images/img_</span><span class="si">%d</span><span class="s2">/mask&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">msks</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>
            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">msks</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;mask &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; exists</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">msks</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int16&#39;</span><span class="p">)</span>
                <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">msks</span>
                <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    ...overwritten</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">fmsk</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dsetName</span><span class="o">=</span><span class="s2">&quot;/images/img_</span><span class="si">%d</span><span class="s2">/fmsk&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fmsk</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fmsk</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;fmsk &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; exists</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">fmsk</span><span class="p">),</span><span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>
                <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">fmsk</span>
                <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    ...overwritten</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">features</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dsetName</span><span class="o">=</span><span class="s2">&quot;/images/img_</span><span class="si">%d</span><span class="s2">/features&quot;</span> <span class="o">%</span> <span class="nb">int</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">features</span><span class="p">))</span>
            <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">features</span>
            <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;features &#39;</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">iS</span><span class="p">)</span><span class="o">+</span><span class="s1">&#39; exists</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overwrite</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">f</span><span class="p">[</span><span class="n">dsetName</span><span class="p">]</span>
                <span class="n">dset</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">create_dataset</span><span class="p">(</span><span class="n">dsetName</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">features</span><span class="p">))</span>
                <span class="n">dset</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">features</span>
                <span class="n">dset</span><span class="o">.</span><span class="n">attrs</span><span class="p">[</span><span class="s1">&#39;time&#39;</span><span class="p">]</span><span class="o">=</span><span class="n">timestamp</span>
                <span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    ...overwritten</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">f</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="get_cell_centers">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_cell_centers">[docs]</a>
<span class="k">def</span> <span class="nf">get_cell_centers</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the centers of mass for labeled regions in an image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    labels : ndarray</span>
<span class="sd">        An array where each labeled region (cell) is marked with a distinct integer. </span>
<span class="sd">        The background should be labeled as 0.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    centers : ndarray</span>
<span class="sd">        An array of coordinates representing the centers of mass for each labeled region.</span>
<span class="sd">        Each row corresponds to a label, and the columns correspond to the coordinates along each dimension.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function returns the center of mass for each distinct label found in the `labels` array.</span>
<span class="sd">    The function will return an empty array if there are no labels greater than zero.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; labels = np.array([[0, 0, 1, 1], [0, 0, 1, 1], [2, 2, 3, 3], [2, 2, 3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; centers = get_cell_centers(labels)</span>
<span class="sd">    &gt;&gt;&gt; print(centers)</span>
<span class="sd">    [[2.5, 2.5], [3. , 0.5], [3. , 2.5]]</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">labels</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">):</span>
        <span class="n">centers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ndimage</span><span class="o">.</span><span class="n">measurements</span><span class="o">.</span><span class="n">center_of_mass</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones_like</span><span class="p">(</span><span class="n">labels</span><span class="p">),</span><span class="n">labels</span><span class="o">=</span><span class="n">labels</span><span class="p">,</span><span class="n">index</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">centers</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span><span class="n">labels</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">centers</span></div>


<div class="viewcode-block" id="get_nndist_sum">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_nndist_sum">[docs]</a>
<span class="k">def</span> <span class="nf">get_nndist_sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">tshift</span><span class="p">,</span><span class="n">centers1</span><span class="p">,</span><span class="n">centers2</span><span class="p">,</span><span class="n">rcut</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculates the sum of the nearest neighbor distances between two sets of points, potentially shifted by a vector, </span>
<span class="sd">    with an optional distance cutoff to consider only close points.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    tshift : ndarray</span>
<span class="sd">        Translation vector to apply to the first set of centers before calculating distances.</span>
<span class="sd">    centers1 : ndarray</span>
<span class="sd">        Array of coordinates for the first set of points.</span>
<span class="sd">    centers2 : ndarray</span>
<span class="sd">        Array of coordinates for the second set of points.</span>
<span class="sd">    rcut : float, optional</span>
<span class="sd">        Cutoff distance beyond which points are not considered as neighbors. If not provided,</span>
<span class="sd">        it will default to infinity, considering all points.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nnd : float</span>
<span class="sd">        The sum of the nearest neighbor distances after considering the translation and cutoff.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function is particularly useful in optimization problems where one needs to minimize </span>
<span class="sd">    the distance between two configurations of points subject to translations. The distance matrix </span>
<span class="sd">    calculations are optimized by only considering points within a specified cutoff.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; centers1 = np.array([[1, 1], [2, 2], [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; centers2 = np.array([[1, 2], [2, 3], [3, 4]])</span>
<span class="sd">    &gt;&gt;&gt; tshift = np.array([1, 1])</span>
<span class="sd">    &gt;&gt;&gt; rcut = 5</span>
<span class="sd">    &gt;&gt;&gt; nnd = get_nndist_sum(tshift, centers1, centers2, rcut)</span>
<span class="sd">    &gt;&gt;&gt; print(nnd)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rcut</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Setting distance cutoff to infinite. Consider using a distance cutoff of the size of the diagonal of the image to vastly speed up calculation.&#39;</span><span class="p">)</span>
    <span class="n">inds_tshift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dmat</span><span class="p">([</span><span class="n">centers1</span><span class="p">[</span><span class="n">ind1</span><span class="p">,:]</span><span class="o">+</span><span class="n">tshift</span><span class="p">],</span><span class="n">centers2</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">rcut</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nnd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dmat</span><span class="p">(</span><span class="n">centers1</span><span class="o">+</span><span class="n">tshift</span><span class="p">,</span><span class="n">centers2</span><span class="p">[</span><span class="n">inds_tshift</span><span class="p">,:])</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dmat</span><span class="p">(</span><span class="n">centers2</span><span class="p">[</span><span class="n">inds_tshift</span><span class="p">,:],</span><span class="n">centers1</span><span class="o">+</span><span class="n">tshift</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">nnd</span></div>


<div class="viewcode-block" id="get_pair_rdf_fromcenters">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_pair_rdf_fromcenters">[docs]</a>
<span class="k">def</span> <span class="nf">get_pair_rdf_fromcenters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">centers</span><span class="p">,</span><span class="n">rbins</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">nr</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span><span class="n">rmax</span><span class="o">=</span><span class="mi">500</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate the radial distribution function (RDF) from a set of center points.</span>
<span class="sd">    The RDF provides a measure of the density distribution of a set of points as a function of distance.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    centers : ndarray</span>
<span class="sd">        Array containing the coordinates of the center points for which the RDF is to be calculated.</span>
<span class="sd">    rbins : ndarray, optional</span>
<span class="sd">        Array of radii to define the bins for RDF calculation. If None, bins are automatically generated.</span>
<span class="sd">    nr : int, optional</span>
<span class="sd">        Number of bins if rbins is not provided. Default is 50.</span>
<span class="sd">    rmax : float, optional</span>
<span class="sd">        Maximum radius to consider if rbins is not provided. Default is 500.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    rbins : ndarray</span>
<span class="sd">        The radii at which the RDF is evaluated, corresponding to the bin edges.</span>
<span class="sd">    paircorrx : ndarray</span>
<span class="sd">        Radial distribution function values corresponding to `rbins`.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The radial distribution function g(r) describes how density varies as a function of distance from a reference particle,</span>
<span class="sd">    and it is typically normalized such that g(r) approaches 1 at large distances.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; centers = np.array([[1, 1], [2, 2], [3, 3]])</span>
<span class="sd">    &gt;&gt;&gt; rbins, rdf = get_pair_rdf_fromcenters(centers)</span>
<span class="sd">    &gt;&gt;&gt; print(rbins)</span>
<span class="sd">    &gt;&gt;&gt; print(rdf)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">rbins</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">rbins</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mf">1.e-6</span><span class="p">,</span><span class="n">rmax</span><span class="p">,</span><span class="n">nr</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">rbins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
        <span class="n">rbins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">=</span><span class="n">rbins</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mf">1.e-8</span>
    <span class="n">nr</span><span class="o">=</span><span class="n">rbins</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">paircorrx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nr</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">dmatr</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_dmat</span><span class="p">(</span><span class="n">centers</span><span class="p">,</span><span class="n">centers</span><span class="p">)</span>
    <span class="n">indr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">digitize</span><span class="p">(</span><span class="n">dmatr</span><span class="p">,</span><span class="n">rbins</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nr</span><span class="p">):</span>
        <span class="n">paircorrx</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span><span class="o">=</span><span class="n">paircorrx</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">indr</span><span class="o">==</span><span class="n">ir</span><span class="p">)</span>
    <span class="n">drbins</span><span class="o">=</span><span class="n">rbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span><span class="o">-</span><span class="n">rbins</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">rbins</span><span class="o">=</span><span class="n">rbins</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
    <span class="n">paircorrx</span><span class="o">=</span><span class="n">paircorrx</span><span class="p">[</span><span class="mi">1</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">V</span><span class="o">=</span><span class="mf">0.0</span>
    <span class="n">nc</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">for</span> <span class="n">ir</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nr</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">norm</span><span class="o">=</span><span class="mf">2.</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="n">rbins</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span><span class="o">*</span><span class="n">drbins</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span>
        <span class="n">V</span><span class="o">=</span><span class="n">V</span><span class="o">+</span><span class="n">norm</span>
        <span class="n">nc</span><span class="o">=</span><span class="n">nc</span><span class="o">+</span><span class="n">paircorrx</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span>
        <span class="n">paircorrx</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span><span class="o">=</span><span class="n">paircorrx</span><span class="p">[</span><span class="n">ir</span><span class="p">]</span><span class="o">/</span><span class="n">norm</span>
    <span class="n">paircorrx</span><span class="o">=</span><span class="n">paircorrx</span><span class="o">*</span><span class="n">V</span><span class="o">/</span><span class="n">nc</span>
    <span class="k">return</span> <span class="n">rbins</span><span class="p">,</span><span class="n">paircorrx</span></div>


<div class="viewcode-block" id="dist_to_contact">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.dist_to_contact">[docs]</a>
<span class="k">def</span> <span class="nf">dist_to_contact</span><span class="p">(</span><span class="n">r</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">d0</span><span class="p">,</span><span class="n">n</span><span class="o">=</span><span class="mi">6</span><span class="p">,</span><span class="n">m</span><span class="o">=</span><span class="mi">12</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a contact potential value based on distance, using a Lennard-Jones-like formula.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r : float or ndarray</span>
<span class="sd">        The radial distance or distances at which the potential is evaluated. Can be a single value or an array.</span>
<span class="sd">    r0 : float</span>
<span class="sd">        Characteristic distance scale, typically representing the distance beyond which the potential significantly decreases.</span>
<span class="sd">    d0 : float</span>
<span class="sd">        Offset distance, representing a threshold below which the potential is set to 1 (indicating maximum interaction).</span>
<span class="sd">    n : int, optional</span>
<span class="sd">        Power of the repulsive component of the potential. Default is 6.</span>
<span class="sd">    m : int, optional</span>
<span class="sd">        Power of the attractive component of the potential. Default is 12.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    c : float or ndarray</span>
<span class="sd">        Computed potential values at each distance `r`. If `r` is an array, `c` will be an array of the same size.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This function computes a value based on the generalized Lennard-Jones potential form:</span>
<span class="sd">    c(r) = (1 - w^n) / (1 - w^m) if r &gt;= d0,</span>
<span class="sd">    c(r) = 1 if r &lt; d0,</span>
<span class="sd">    where w = (r - d0) / r0.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; dist_to_contact(5, 1, 3)</span>
<span class="sd">    0.25</span>

<span class="sd">    &gt;&gt;&gt; r = np.array([1, 2, 3, 4, 5])</span>
<span class="sd">    &gt;&gt;&gt; dist_to_contact(r, 1, 3)</span>
<span class="sd">    array([1.   , 1.   , 1.   , 0.75 , 0.25])</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isscalar</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">r</span><span class="o">&lt;</span><span class="n">d0</span><span class="p">:</span>
            <span class="n">c</span><span class="o">=</span><span class="mf">1.</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">w</span><span class="o">=</span><span class="p">(</span><span class="n">r</span><span class="o">-</span><span class="n">d0</span><span class="p">)</span><span class="o">/</span><span class="n">r0</span>
            <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="n">n</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">w</span><span class="o">**</span><span class="n">m</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">c</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">indc</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span><span class="o">&lt;</span><span class="n">d0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">inds</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">r</span><span class="o">&gt;=</span><span class="n">d0</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">c</span><span class="p">[</span><span class="n">indc</span><span class="p">]</span><span class="o">=</span><span class="mf">1.</span>
        <span class="n">w</span><span class="o">=</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">-</span><span class="n">d0</span><span class="p">)</span><span class="o">/</span><span class="n">r0</span>
        <span class="n">c</span><span class="p">[</span><span class="n">inds</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">((</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">n</span><span class="p">)),(</span><span class="mi">1</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">power</span><span class="p">(</span><span class="n">w</span><span class="p">,</span><span class="n">m</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">c</span></div>


<div class="viewcode-block" id="get_contactsum_dev">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.get_contactsum_dev">[docs]</a>
<span class="k">def</span> <span class="nf">get_contactsum_dev</span><span class="p">(</span><span class="n">centers1</span><span class="p">,</span><span class="n">centers2</span><span class="p">,</span><span class="n">img2</span><span class="p">,</span><span class="n">rp1</span><span class="p">,</span><span class="n">nt</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span><span class="n">savefile</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Calculate a grid-based sum of contact deviations for center points translated across an image.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    centers1 : ndarray</span>
<span class="sd">        Array of original center points (x, y coordinates).</span>
<span class="sd">    centers2 : ndarray</span>
<span class="sd">        Array of target center points for comparison (x, y coordinates).</span>
<span class="sd">    img2 : ndarray</span>
<span class="sd">        The image data used for setting the boundary conditions for translations.</span>
<span class="sd">    rp1 : float</span>
<span class="sd">        Interaction potential radius to determine the contact potential calculation.</span>
<span class="sd">    nt : int, optional</span>
<span class="sd">        Number of translations along each axis, if None it defaults to 1/20th of the image dimension.</span>
<span class="sd">    savefile : str, optional</span>
<span class="sd">        Path to save the resulting deviation grid as a NumPy binary file.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    nncs_dev : ndarray</span>
<span class="sd">        A grid of normalized deviations of contact sums from their local average across the translation space.</span>

<span class="sd">    Description</span>
<span class="sd">    -----------</span>
<span class="sd">    This function creates a grid of potential translation points across the image. For each point in this grid,</span>
<span class="sd">    it shifts the &#39;centers1&#39; coordinates and calculates the minimum distances to &#39;centers2&#39; within the confines</span>
<span class="sd">    of the translated box. It then calculates a contact potential using these distances and compares the sum</span>
<span class="sd">    to the local average to assess deviations in potential interactions. This can help in understanding how</span>
<span class="sd">    interactions vary spatially within an image. The function optionally saves the output grid to a file for</span>
<span class="sd">    further analysis.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    # Example of using the function to calculate contact deviations:</span>
<span class="sd">    &gt;&gt;&gt; centers1 = np.array([[10, 10], [20, 20], [30, 30]])</span>
<span class="sd">    &gt;&gt;&gt; centers2 = np.array([[15, 15], [25, 25], [35, 35]])</span>
<span class="sd">    &gt;&gt;&gt; img = np.zeros((100, 100))</span>
<span class="sd">    &gt;&gt;&gt; rp1 = 10</span>
<span class="sd">    &gt;&gt;&gt; deviations = get_contactsum_dev(centers1, centers2, img, rp1, nt=10)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">nt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nt</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="n">img2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">20</span><span class="p">)</span>
    <span class="n">txSet</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">img2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">nt</span><span class="p">)</span>
    <span class="n">tySet</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">img2</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">nt</span><span class="p">)</span>
    <span class="n">xxt</span><span class="p">,</span><span class="n">yyt</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="n">txSet</span><span class="p">,</span><span class="n">tySet</span><span class="p">)</span>
    <span class="n">xxt</span><span class="o">=</span><span class="n">xxt</span><span class="o">.</span><span class="n">flatten</span><span class="p">();</span> <span class="n">yyt</span><span class="o">=</span><span class="n">yyt</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">d0</span><span class="o">=</span><span class="n">rp1</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">r0</span><span class="o">=</span><span class="n">rp1</span><span class="o">/</span><span class="mi">2</span>
    <span class="n">ndx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">centers1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">centers1</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ndy</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">centers1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">centers1</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">nncs</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">nt</span><span class="o">*</span><span class="n">nt</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i1</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nt</span><span class="o">*</span><span class="n">nt</span><span class="p">):</span>
        <span class="n">tshift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">xxt</span><span class="p">[</span><span class="n">i1</span><span class="p">],</span><span class="n">yyt</span><span class="p">[</span><span class="n">i1</span><span class="p">]])</span>
        <span class="c1">#inds_tshift=np.where(self.get_dmat([tshift],centers2)[0]&lt;rcut)[0]</span>
        <span class="n">ctx</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">centers2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="n">tshift</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">centers2</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="n">tshift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="n">ndx</span><span class="p">)</span>
        <span class="n">cty</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">centers2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="n">tshift</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">centers2</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;</span><span class="n">tshift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="n">ndy</span><span class="p">)</span>
        <span class="n">inds_tshift</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">ctx</span><span class="p">,</span><span class="n">cty</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">inds_tshift</span><span class="o">.</span><span class="n">size</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="n">nncs</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">r1</span><span class="o">=</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_dmat</span><span class="p">(</span><span class="n">centers1</span><span class="o">+</span><span class="n">tshift</span><span class="p">,</span><span class="n">centers2</span><span class="p">[</span><span class="n">inds_tshift</span><span class="p">,:])</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">c1</span><span class="o">=</span><span class="n">dist_to_contact</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">d0</span><span class="p">)</span>
            <span class="n">r2</span><span class="o">=</span><span class="n">utilities</span><span class="o">.</span><span class="n">get_dmat</span><span class="p">(</span><span class="n">centers2</span><span class="p">[</span><span class="n">inds_tshift</span><span class="p">,:],</span><span class="n">centers1</span><span class="o">+</span><span class="n">tshift</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">c2</span><span class="o">=</span><span class="n">dist_to_contact</span><span class="p">(</span><span class="n">r1</span><span class="p">,</span><span class="n">r0</span><span class="p">,</span><span class="n">d0</span><span class="p">)</span>
            <span class="n">nncs</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">c1</span><span class="p">)</span><span class="o">/</span><span class="n">c1</span><span class="o">.</span><span class="n">size</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">nansum</span><span class="p">(</span><span class="n">c2</span><span class="p">)</span><span class="o">/</span><span class="n">c2</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i1</span><span class="o">%</span><span class="mi">1000</span><span class="o">==</span><span class="mi">0</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;grid </span><span class="si">{</span><span class="n">i1</span><span class="si">}</span><span class="s1"> of </span><span class="si">{</span><span class="n">nt</span><span class="o">*</span><span class="n">nt</span><span class="si">}</span><span class="s1">, tx: </span><span class="si">{</span><span class="n">tshift</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> ty: </span><span class="si">{</span><span class="n">tshift</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">:</span><span class="s1">.2f</span><span class="si">}</span><span class="s1"> nncs: </span><span class="si">{</span><span class="n">nncs</span><span class="p">[</span><span class="n">i1</span><span class="p">]</span><span class="si">:</span><span class="s1">.4e</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
    <span class="n">local_av</span><span class="o">=</span><span class="n">generic_filter</span><span class="p">(</span><span class="n">nncs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nt</span><span class="p">,</span><span class="n">nt</span><span class="p">),</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span><span class="n">size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">rp1</span><span class="p">))</span>
    <span class="n">nncs_dev</span><span class="o">=</span><span class="n">nncs</span><span class="o">-</span><span class="n">local_av</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">nncs_dev</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">nncs_dev</span><span class="p">)]</span><span class="o">=</span><span class="mi">0</span>
    <span class="k">if</span> <span class="n">savefile</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">savefile</span><span class="p">,</span><span class="n">nncs_dev</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">nncs_dev</span></div>


<div class="viewcode-block" id="crop_image">
<a class="viewcode-back" href="../../celltraj.html#celltraj.imageprep.crop_image">[docs]</a>
<span class="k">def</span> <span class="nf">crop_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span><span class="n">tshift</span><span class="p">,</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Crop and resize an image based on specified translation shifts and dimensions.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    img : ndarray</span>
<span class="sd">        The original image to be cropped.</span>
<span class="sd">    tshift : tuple or ndarray</span>
<span class="sd">        A tuple or array indicating the x and y translation shifts where cropping should start.</span>
<span class="sd">    nx : int</span>
<span class="sd">        The desired width of the cropped image.</span>
<span class="sd">    ny : int</span>
<span class="sd">        The desired height of the cropped image.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    img_cropped : ndarray</span>
<span class="sd">        The cropped and resized image.</span>

<span class="sd">    Description</span>
<span class="sd">    -----------</span>
<span class="sd">    This function crops the image starting from a point defined by `tshift` (top-left corner of the crop)</span>
<span class="sd">    and extends the crop to the specified width (`nx`) and height (`ny`). After cropping, it resizes the</span>
<span class="sd">    cropped portion back to the dimensions (`nx`, `ny`) using an anti-aliasing filter to maintain the quality.</span>

<span class="sd">    Example</span>
<span class="sd">    -------</span>
<span class="sd">    # Example of using the function to crop and resize an image:</span>
<span class="sd">    &gt;&gt;&gt; img = np.random.rand(100, 100)  # Create a random image of size 100x100</span>
<span class="sd">    &gt;&gt;&gt; tshift = (10, 10)  # Start the crop 10 pixels down and right</span>
<span class="sd">    &gt;&gt;&gt; nx, ny = 50, 50  # Dimensions of the cropped and resized image</span>
<span class="sd">    &gt;&gt;&gt; cropped_img = crop_image(img, tshift, nx, ny)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">img_cropped</span><span class="o">=</span><span class="n">img</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">tshift</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">tshift</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">+</span><span class="n">nx</span><span class="p">,:]</span>
    <span class="n">img_cropped</span><span class="o">=</span><span class="n">img_cropped</span><span class="p">[:,</span><span class="nb">int</span><span class="p">(</span><span class="n">tshift</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span><span class="nb">int</span><span class="p">(</span><span class="n">tshift</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="n">ny</span><span class="p">]</span>
    <span class="n">img_cropped</span><span class="o">=</span><span class="n">resize</span><span class="p">(</span><span class="n">img_cropped</span><span class="p">,(</span><span class="n">nx</span><span class="p">,</span><span class="n">ny</span><span class="p">),</span><span class="n">anti_aliasing</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">img_cropped</span></div>



</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Jeremy Copperman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>