

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="./">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>celltraj package &mdash; celltraj 0.1.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=e59714d7" />

  
      <script src="_static/jquery.js?v=5d32c60e"></script>
      <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="_static/documentation_options.js?v=a58bc63e"></script>
      <script src="_static/doctools.js?v=9a2dae69"></script>
      <script src="_static/sphinx_highlight.js?v=dc90522c"></script>
      <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            celltraj
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="readme.html">celltraj</a></li>
<li class="toctree-l1"><a class="reference internal" href="installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="api.html">API reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">celltraj</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">celltraj package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/celltraj.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="celltraj-package">
<h1>celltraj package<a class="headerlink" href="#celltraj-package" title="Link to this heading"></a></h1>
<section id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Link to this heading"></a></h2>
</section>
<section id="module-celltraj.celltraj_1apr21">
<span id="celltraj-celltraj-1apr21-module"></span><h2>celltraj.celltraj_1apr21 module<a class="headerlink" href="#module-celltraj.celltraj_1apr21" title="Link to this heading"></a></h2>
<p>Main module.</p>
<dl class="py class">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">celltraj.celltraj_1apr21.</span></span><span class="sig-name descname"><span class="pre">cellTraj</span></span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Some cell trajectory analysis and embedding tools.</p>
<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.afft">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">afft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.afft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.afft" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.align_image">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">align_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.align_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.align_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.assemble_dmat">
<span class="sig-name descname"><span class="pre">assemble_dmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symmetrize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.assemble_dmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.assemble_dmat" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.cluster_cells">
<span class="sig-name descname"><span class="pre">cluster_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.cluster_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.cluster_cells" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.cluster_trajectories">
<span class="sig-name descname"><span class="pre">cluster_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.cluster_trajectories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.cluster_trajectories" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.dist">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.dist" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.dist_with_masks">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dist_with_masks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.dist_with_masks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.dist_with_masks" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.explore_2D_celltraj">
<span class="sig-name descname"><span class="pre">explore_2D_celltraj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_segs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.explore_2D_celltraj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.explore_2D_celltraj" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.explore_2D_celltraj_nn">
<span class="sig-name descname"><span class="pre">explore_2D_celltraj_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_segs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.explore_2D_celltraj_nn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.explore_2D_celltraj_nn" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.explore_2D_img">
<span class="sig-name descname"><span class="pre">explore_2D_img</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.explore_2D_img"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.explore_2D_img" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.explore_2D_nn">
<span class="sig-name descname"><span class="pre">explore_2D_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nvis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.explore_2D_nn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.explore_2D_nn" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.featBoundary">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">featBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.featBoundary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.featBoundary" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.featBoundaryCB">
<span class="sig-name descname"><span class="pre">featBoundaryCB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmsk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.featBoundaryCB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.featBoundaryCB" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.featHaralick">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">featHaralick</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.featHaralick"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.featHaralick" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.featZernike">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">featZernike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.featZernike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.featZernike" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_all_trajectories">
<span class="sig-name descname"><span class="pre">get_all_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_all_trajectories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_all_trajectories" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_border_profile">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_border_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_border_profile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_border_profile" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_borders">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_borders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_borders"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_borders" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_bunch_clusters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_bunch_clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bmsk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_bunch_clusters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_bunch_clusters" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_cc_cs_border">
<span class="sig-name descname"><span class="pre">get_cc_cs_border</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_cc_cs_border"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_cc_cs_border" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_cell_blocks">
<span class="sig-name descname"><span class="pre">get_cell_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_cell_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_cell_blocks" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_cell_bunches">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cell_bunches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmsk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunchcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_cell_bunches"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_cell_bunches" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_cell_data">
<span class="sig-name descname"><span class="pre">get_cell_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_cell_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_cell_data" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_cell_images">
<span class="sig-name descname"><span class="pre">get_cell_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_cell_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_cell_images" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_cell_trajectory">
<span class="sig-name descname"><span class="pre">get_cell_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_cell_trajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_cell_trajectory" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_cellborder_images">
<span class="sig-name descname"><span class="pre">get_cellborder_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_cellborder_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_cellborder_images" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_clean_mask">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_clean_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_clean_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_clean_mask" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_dmat">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_dmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_dmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_dmat" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_dmatF_row">
<span class="sig-name descname"><span class="pre">get_dmatF_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_dmatF_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_dmatF_row" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_dmatRT_row">
<span class="sig-name descname"><span class="pre">get_dmatRT_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_dmatRT_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_dmatRT_row" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_dx_alpha">
<span class="sig-name descname"><span class="pre">get_dx_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_dx_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_dx_alpha" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_dx_rdf">
<span class="sig-name descname"><span class="pre">get_dx_rdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_dx_rdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_dx_rdf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_dx_tcf">
<span class="sig-name descname"><span class="pre">get_dx_tcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_dx_tcf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_dx_tcf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_dx_theta">
<span class="sig-name descname"><span class="pre">get_dx_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_dx_theta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_dx_theta" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_embedding">
<span class="sig-name descname"><span class="pre">get_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_fmaskSet">
<span class="sig-name descname"><span class="pre">get_fmaskSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_fmaskSet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_fmaskSet" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_fmask_data">
<span class="sig-name descname"><span class="pre">get_fmask_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_fmask_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_fmask_data" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_frames">
<span class="sig-name descname"><span class="pre">get_frames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_frames"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_frames" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_imageSet">
<span class="sig-name descname"><span class="pre">get_imageSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_imageSet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_imageSet" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_imageSet_trans">
<span class="sig-name descname"><span class="pre">get_imageSet_trans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_imageSet_trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_imageSet_trans" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_image_data">
<span class="sig-name descname"><span class="pre">get_image_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_image_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_image_data" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_lineage_bunch_overlap">
<span class="sig-name descname"><span class="pre">get_lineage_bunch_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distcutb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlapcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunchcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clustervisual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_lineage_bunch_overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_lineage_bunch_overlap" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_lineage_mindist">
<span class="sig-name descname"><span class="pre">get_lineage_mindist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">65.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_lineage_mindist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_lineage_mindist" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_minRT">
<span class="sig-name descname"><span class="pre">get_minRT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">37</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.141592653589793</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">80</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_minRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_minRT" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_pair_cluster_rdf">
<span class="sig-name descname"><span class="pre">get_pair_cluster_rdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_indsA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_indsB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_pair_cluster_rdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_pair_cluster_rdf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_pair_distRT">
<span class="sig-name descname"><span class="pre">get_pair_distRT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_pair_distRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_pair_distRT" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_pair_rdf">
<span class="sig-name descname"><span class="pre">get_pair_rdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_indsA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_indsB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_pair_rdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_pair_rdf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_path_entropy_2point">
<span class="sig-name descname"><span class="pre">get_path_entropy_2point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_stays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_path_entropy_2point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_path_entropy_2point" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_pca">
<span class="sig-name descname"><span class="pre">get_pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_pca"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_pca" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_pca_fromdata">
<span class="sig-name descname"><span class="pre">get_pca_fromdata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_pca_fromdata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_pca_fromdata" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_scaled_sigma">
<span class="sig-name descname"><span class="pre">get_scaled_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_scaled_sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_scaled_sigma" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_stack_trans">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_stack_trans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_stack_trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_stack_trans" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_traj_segments">
<span class="sig-name descname"><span class="pre">get_traj_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seg_length</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_traj_segments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_traj_segments" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_trajectory_embedding">
<span class="sig-name descname"><span class="pre">get_trajectory_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neigen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_trajectory_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_trajectory_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_trajectory_steps">
<span class="sig-name descname"><span class="pre">get_trajectory_steps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xtraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_trajectory_steps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_trajectory_steps" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_transition_matrix">
<span class="sig-name descname"><span class="pre">get_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_transition_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_transition_matrix" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.get_unique_trajectories">
<span class="sig-name descname"><span class="pre">get_unique_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.get_unique_trajectories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.get_unique_trajectories" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileSpecifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modelName</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.initialize" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.pad_image">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pad_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxedge</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.pad_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.pad_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.plot_embedding">
<span class="sig-name descname"><span class="pre">plot_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.plot_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.plot_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.plot_pca">
<span class="sig-name descname"><span class="pre">plot_pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.plot_pca"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.plot_pca" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.prepare_cell_features">
<span class="sig-name descname"><span class="pre">prepare_cell_features</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.prepare_cell_features"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.prepare_cell_features" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.prepare_cell_images">
<span class="sig-name descname"><span class="pre">prepare_cell_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">znormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.prepare_cell_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.prepare_cell_images" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.prune_embedding">
<span class="sig-name descname"><span class="pre">prune_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.prune_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.prune_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.save_all">
<span class="sig-name descname"><span class="pre">save_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.save_all"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.save_all" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.save_dmat_row">
<span class="sig-name descname"><span class="pre">save_dmat_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dmat_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.save_dmat_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.save_dmat_row" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.seq_in_seq">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">seq_in_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.seq_in_seq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.seq_in_seq" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.show_cells">
<span class="sig-name descname"><span class="pre">show_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.show_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.show_cells" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.show_cells_from_image">
<span class="sig-name descname"><span class="pre">show_cells_from_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellblocks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.show_cells_from_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.show_cells_from_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.show_image_pair">
<span class="sig-name descname"><span class="pre">show_image_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.show_image_pair"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.show_image_pair" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.transform_image">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">transform_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.transform_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.transform_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.celltraj_1apr21.cellTraj.znorm">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">znorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/celltraj_1apr21.html#cellTraj.znorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.celltraj_1apr21.cellTraj.znorm" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-celltraj.cli">
<span id="celltraj-cli-module"></span><h2>celltraj.cli module<a class="headerlink" href="#module-celltraj.cli" title="Link to this heading"></a></h2>
<p>Console script for celltraj.</p>
</section>
<section id="module-celltraj.features">
<span id="celltraj-features-module"></span><h2>celltraj.features module<a class="headerlink" href="#module-celltraj.features" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.apply3d">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">apply3d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">function2d</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">function2d_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#apply3d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.apply3d" title="Link to this definition"></a></dt>
<dd><p>Applies a 2D function across each slice of a 3D image stack or directly to a 2D image, allowing for
specific operations like filtering or transformation to be uniformly applied across all spatial slices.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The input image which can be either 2D or 3D. If the image is 3D, the function is applied slice by slice.</p></li>
<li><p><strong>function2d</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">callable</span></code>) – A function that is applied to each 2D slice of the image. This function must accept an image as its
first argument and can accept additional named arguments.</p></li>
<li><p><strong>dtype</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">data-type</span></code>, <em>optional</em>) – The desired data-type for the output image. If None, the dtype of <cite>img</cite> is used. Specifying a dtype can be
useful for managing memory or computational requirements.</p></li>
<li><p><strong>**function2d_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – Additional keyword arguments to pass to <cite>function2d</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>img_processed</strong> – The image resulting from the application of <cite>function2d</cite> to each slice of <cite>img</cite> or directly to <cite>img</cite> if it is 2D.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># Example 3D image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">apply3d</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>  <span class="c1"># Apply np.mean across axis 0 of each 2D slice</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(5, 100)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is particularly useful for processing 3D data where an operation is intended to be
repeated across each 2D section. For example, applying edge detection or blurring slice-by-slice.</p></li>
<li><p>The performance of this function depends on the complexity of <cite>function2d</cite> and the size of the image.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>img</cite> is not 2D or 3D, or if <cite>function2d</cite> cannot be applied as specified.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.boundaryCB_FFT">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">boundaryCB_FFT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmsk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#boundaryCB_FFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.boundaryCB_FFT" title="Link to this definition"></a></dt>
<dd><p>Computes the Fourier Transform of boundary data for a mask distinguishing between core-cell
and cell-surrounding regions, encoding the shape information in frequency space.</p>
<p>This function identifies boundaries within a mask and differentiates between core-cell (cc) and
cell-surrounding (cs) regions. It then calculates the Fourier Transform of these boundary
classifications relative to a center, capturing the spatial distribution of core and surrounding
areas.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where the non-zero region defines the cells.</p></li>
<li><p><strong>fmsk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A foreground mask, used to define foreground regions for identifying core and surrounding cell regions.</p></li>
<li><p><strong>ncomp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of components to return from the Fourier Transform (default is 15).</p></li>
<li><p><strong>center</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – The center of the image from which to calculate radial coordinates. If None, it defaults to the image center.</p></li>
<li><p><strong>nth</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of angular steps to interpolate over the [0, 2π] interval, default is 256.</p></li>
<li><p><strong>bordersize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The size of the border around cells to consider for differentiation between core and surrounding areas, default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rtha</strong> – An array containing the first <cite>ncomp</cite> normalized magnitudes of the Fourier components of the boundary data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msk</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmsk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">msk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmsk</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">65</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fft_result</span> <span class="o">=</span> <span class="n">boundaryCB_FFT</span><span class="p">(</span><span class="n">msk</span><span class="p">,</span> <span class="n">fmsk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fft_result</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(15,)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function first distinguishes between core-cell and cell-surrounding regions using morphological operations.</p></li>
<li><p>It then maps these regions onto a polar coordinate system centered on <cite>center</cite> and computes the FFT of this radial
binary function, which describes the presence of core-cell versus cell-surrounding regions as a function of angle.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – If there is an error during processing, possibly due to issues with input data shapes or computation failures.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.boundaryFFT">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">boundaryFFT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#boundaryFFT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.boundaryFFT" title="Link to this definition"></a></dt>
<dd><p>Computes the normalized Fast Fourier Transform (FFT) of the boundary of a mask. The boundary is first
represented in polar coordinates (radius as a function of angle), and the FFT is used to capture the
frequency components of this boundary representation, providing a spectral description of the shape.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where the non-zero region defines the shape whose boundary will be analyzed.</p></li>
<li><p><strong>ncomp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of Fourier components to return. Default is 15.</p></li>
<li><p><strong>center</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – The center of the mask from which radial distances are measured. If None, the geometric center
of the mask is used.</p></li>
<li><p><strong>nth</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of points to interpolate along the boundary before computing the FFT. More points
can improve the smoothness of the interpolation. Default is 256.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>rtha</strong> – An array of the first <cite>ncomp</cite> normalized magnitudes of the Fourier components of the boundary.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Exception</strong> – If there is an error in computing the Fourier transform, possibly due to issues with the boundary
    extraction or interpolation.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msk</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Define a square region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fft_components</span> <span class="o">=</span> <span class="n">boundaryFFT</span><span class="p">(</span><span class="n">msk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">fft_components</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(15,)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function first identifies the boundary pixels of the mask using image processing techniques.</p></li>
<li><p>It then converts these boundary coordinates into polar coordinates centered around <cite>center</cite>.</p></li>
<li><p>After sorting and unique filtering of angular coordinates, it interpolates the radial distance as
a function of angle and computes the FFT, returning the normalized magnitudes of its components.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.featBoundary">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">featBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#featBoundary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.featBoundary" title="Link to this definition"></a></dt>
<dd><p>Calculates boundary-based Fourier Transform features for specified regions within an image.
This function applies a Fourier Transform to the boundaries of regions defined by <cite>regionmask</cite>
to capture the shape characteristics in the frequency domain.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where non-zero values indicate the region of interest whose boundary is analyzed.
The mask can be either 2D or 3D.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The intensity image corresponding to <cite>regionmask</cite>. This parameter is currently not used in the
function but is included for compatibility with other feature extraction functions.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>xf</strong> – An array of Fourier Transform features of the boundary. If the regionmask is 3D, the function
returns the mean of the Fourier Transform features computed across all slices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Define a square region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># Not used in this function</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_features</span> <span class="o">=</span> <span class="n">featBoundary</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">boundary_features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(15,)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function computes boundary features by first extracting the boundary of the masked region using
image processing techniques and then applying a Fourier Transform to describe the shape in the
frequency domain.</p></li>
<li><p>If no valid region is found in <cite>regionmask</cite> (i.e., all values are zero), the function returns an array
of zeros with a length defined by the number of components used in the <cite>boundaryFFT</cite> function.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the <cite>regionmask</cite> is empty or does not contain any regions to process.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.featBoundaryCB">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">featBoundaryCB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#featBoundaryCB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.featBoundaryCB" title="Link to this definition"></a></dt>
<dd><p>Computes boundary-based Fourier Transform features for a region mask distinguishing between core-cell
and surrounding areas by using intensity to define active regions. This function applies a binary erosion
to the region mask to refine the core region and then calculates the Fourier Transform features based on
the refined mask and intensity data. Currently there is no way to pass parameters to the boundaryCB_FFT function.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask indicating the presence of cells. This mask is eroded to focus more on the core region of cells.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An intensity image where non-zero values indicate active regions. This is used to distinguish between
core-cell and surrounding areas.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>xf</strong> – An array containing the Fourier Transform features of the boundary data between core and surrounding
regions. If the input <cite>regionmask</cite> is 3D, the function returns the mean of features computed across
all slices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_features</span> <span class="o">=</span> <span class="n">featBoundaryCB</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">boundary_features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(15,)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function first applies a binary erosion to the <cite>regionmask</cite> to slightly reduce the region size, aiming
to focus more on the core regions.</p></li>
<li><p>It then uses these regions along with intensity data to calculate Fourier Transform features that describe
the spatial relationship between core-cell areas and their surrounding based on intensity.</p></li>
<li><p>Visualization commands within the function (commented out) can be enabled for debugging or understanding
the process by visual inspection.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.featHaralick">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">featHaralick</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#featHaralick"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.featHaralick" title="Link to this definition"></a></dt>
<dd><p>Computes Haralick texture features for a specified region within an image, offering a statistical
view of texture based on the image’s gray-level co-occurrence matrix (GLCM).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where non-zero values define the region of interest for feature calculation.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The intensity image corresponding to <cite>regionmask</cite>. Texture features are calculated from this image
within the boundaries defined by <cite>regionmask</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>xf</strong> – An array of computed Haralick features. If <cite>regionmask</cite> is 3-dimensional, returns the mean of the features
calculated for each slice. If <cite>regionmask</cite> is 2-dimensional, returns the Haralick features for that single slice.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Defining a square region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">haralick_features</span> <span class="o">=</span> <span class="n">featHaralick</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">haralick_features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(13,)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Haralick features are calculated using Mahotas library functions based on the GLCM of the image.</p></li>
<li><p>The intensity image is quantized into several levels which are then used to compute the GLCM.</p></li>
<li><p>Feature 5 (sum average) is normalized by dividing by the number of quantization levels to match the scale of other features.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the <cite>regionmask</cite> and <cite>intensity</cite> arrays do not match in dimensions or if other processing errors occur.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.featNucBoundary">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">featNucBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#featNucBoundary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.featNucBoundary" title="Link to this definition"></a></dt>
<dd><p>Computes Fourier Transform features from the boundaries of a specified region within an intensity image.
This function is primarily used to analyze the structural properties of nuclear boundaries in biological
imaging data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask indicating the presence of nuclear regions. The mask can be 2D or 3D.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The intensity image corresponding to <cite>regionmask</cite>, which is binarized within the function to
delineate boundaries more clearly.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>xf</strong> – An array containing Fourier Transform features derived from the boundary of the specified region.
If no valid region or intensity is detected, an array of NaNs is returned.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Define a square region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>  <span class="c1"># Random intensity image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">features</span> <span class="o">=</span> <span class="n">featNucBoundary</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(15,)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If the regionmask is 3D and contains multiple slices, the function calculates the Fourier Transform features for
slices with non-zero intensity, then averages these features across the active slices.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>regionmask</cite> and <cite>intensity</cite> do not have the same dimensions or if they are neither 2D nor 3D arrays.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.featSize">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">featSize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#featSize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.featSize" title="Link to this definition"></a></dt>
<dd><p>Calculates the size of a region specified by a mask.</p>
<p>This function computes the total number of pixels (or voxels) within a region defined by a non-zero mask.
The intensity parameter is included for compatibility with skimage’s regionprops, which requires this
parameter signature even if it’s not used in the computation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where non-zero values indicate the region of interest.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The intensity image; not used in this function but required for consistency with
regionprops function signatures.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>size</strong> – The total count of non-zero pixels in the regionmask, representing the size of the region.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>  <span class="c1"># Example intensity array (not used)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">size</span> <span class="o">=</span> <span class="n">featSize</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
<span class="go">3</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.featZernike">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">featZernike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#featZernike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.featZernike" title="Link to this definition"></a></dt>
<dd><p>Calculates the Zernike moments for a specified region within an image, quantifying the region’s shape and texture.
This method uses Zernike polynomials to create a set of features that are invariant to rotation, making them
particularly useful for shape analysis in image processing tasks.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where non-zero values define the region of interest. The function computes Zernike moments
for this specified region.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An intensity image corresponding to <cite>regionmask</cite>. The function calculates moments based on the intensities
within the region defined by <cite>regionmask</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>xf</strong> – An array of computed Zernike moments. If <cite>regionmask</cite> is 3-dimensional, returns the mean of Zernike moments
calculated for each slice. If <cite>regionmask</cite> is 2-dimensional, returns the Zernike moments for that single slice.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Defining a square region</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">zernike_features</span> <span class="o">=</span> <span class="n">featZernike</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">zernike_features</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(91,)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Zernike moments are calculated using a radius determined by the average dimensions of the <cite>regionmask</cite>.</p></li>
<li><p>The intensity values outside the regionmask are set to zero, and the intensities within the region are normalized
before calculation to improve accuracy.</p></li>
<li><p>This function is useful for characterizing the morphological features of cellular structures or other similar
objects in biomedical images.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the <cite>regionmask</cite> and <cite>intensity</cite> arrays do not match in dimensions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.get_cc_cs_border">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">get_cc_cs_border</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#get_cc_cs_border"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.get_cc_cs_border" title="Link to this definition"></a></dt>
<dd><p>Identifies core-cell (cc) and cell-surrounding (cs) borders within a given cell mask by applying
morphological operations and boundary detection.</p>
<p>This function defines two regions within a cell mask: the core-cell border, which is far enough from the
background to be considered central, and the cell-surrounding border, which is close to the background.
Morphological erosion and dilation are used to refine these borders.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mskcell</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask indicating the presence of cells.</p></li>
<li><p><strong>fmskcell</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask indicating foreground regions likely to include cells; this mask is modified by
morphological operations to define borders.</p></li>
<li><p><strong>bordersize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The size of the border around cell regions to consider in the analysis. Default is 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>ccborder</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where <cite>1</cite> indicates core-cell borders.</p></li>
<li><p><strong>csborder</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where <cite>1</cite> indicates cell-surrounding borders.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mskcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mskcell</span><span class="p">[</span><span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">,</span> <span class="mi">30</span><span class="p">:</span><span class="mi">70</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmskcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">mskcell</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmskcell</span><span class="p">[</span><span class="mi">35</span><span class="p">:</span><span class="mi">65</span><span class="p">,</span> <span class="mi">35</span><span class="p">:</span><span class="mi">65</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ccborder</span><span class="p">,</span> <span class="n">csborder</span> <span class="o">=</span> <span class="n">get_cc_cs_border</span><span class="p">(</span><span class="n">mskcell</span><span class="p">,</span> <span class="n">fmskcell</span><span class="p">,</span> <span class="n">bordersize</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ccborder</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">csborder</span><span class="o">.</span><span class="n">sum</span><span class="p">())</span>
<span class="go">(900, 100)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function first finds the boundaries of the <cite>mskcell</cite> using the inner boundary mode.</p></li>
<li><p>It then applies sequential erosion and dilation to <cite>fmskcell</cite> to adjust the extent of the foreground mask.</p></li>
<li><p>Distances from the boundaries to the background are calculated to segregate core-cell and cell-surrounding regions.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the input masks are not of the same shape or if other processing errors occur.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.get_contact_boundaries">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">get_contact_boundaries</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#get_contact_boundaries"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.get_contact_boundaries" title="Link to this definition"></a></dt>
<dd><p>Identifies contact boundaries within labeled regions, highlighting the edges where different labels meet.
This function can apply a dilation operation to expand the regions before comparing them, which helps in
identifying contact areas even if they are not immediately adjacent.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A labeled image where each unique integer (non-zero) represents a distinct region.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The radius of the structuring element used for dilation, which can expand the boundaries of the labels
to identify near-contact areas. Default is 10.</p></li>
<li><p><strong>boundary_only</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, the function will return only the boundaries of the contact areas. If False, it will return
the entire area affected by the dilation process where contacts occur. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>msk_contact</strong> – A binary mask indicating the areas where different labels are in contact. If <cite>boundary_only</cite> is True,
this mask will only cover the actual boundaries; otherwise, it covers the dilated areas where contacts
occur.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">                       [1, 1, 0, 2, 2],</span>
<span class="go">                       [1, 1, 0, 0, 0],</span>
<span class="go">                       [0, 3, 3, 3, 0]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contact_msk</span> <span class="o">=</span> <span class="n">get_contact_boundaries</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">boundary_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">contact_msk</span><span class="p">)</span>
<span class="go">[[False False False False False]</span>
<span class="go"> [False False False False False]</span>
<span class="go"> [False False  True  True False]</span>
<span class="go"> [False  True  True  True  True]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is particularly useful in cell imaging where identifying the boundaries between cells
can help in analyzing cell interactions and morphology.</p></li>
<li><p>The dilation process helps to identify contacts even if cells (or other labeled regions) are not
physically touching but are within a close proximity defined by <cite>radius</cite>.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>labels</cite> is not a 2D or 3D ndarray.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.get_contact_labels">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">get_contact_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#get_contact_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.get_contact_labels" title="Link to this definition"></a></dt>
<dd><p>Identifies and returns labels that are in contact with each label in a segmented image. This function
uses morphological dilation to find neighboring regions and constructs a mask that indicates the labels
which each region is in contact with.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A labeled image where each unique positive integer represents a different segmented region.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The radius of the structuring element used for dilation. This determines how far out from the original
label’s boundaries the function will look to identify contacts. Default is 10.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>contact_labels</strong> – An image of the same shape as <cite>labels0</cite> where each pixel in a contact region contains the label of the
neighboring region it is in contact with. Pixels not in contact with different labels remain zero.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span>
<span class="go">                       [1, 1, 1, 2, 2, 2],</span>
<span class="go">                       [1, 1, 0, 0, 2, 2],</span>
<span class="go">                       [0, 0, 0, 0, 0, 0],</span>
<span class="go">                       [3, 3, 3, 3, 4, 4],</span>
<span class="go">                       [3, 3, 3, 3, 4, 4]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">contact_labels</span> <span class="o">=</span> <span class="n">get_contact_labels</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">contact_labels</span><span class="p">)</span>
<span class="go">[[0 0 0 0 0 0]</span>
<span class="go"> [0 0 2 1 0 0]</span>
<span class="go"> [0 0 0 0 0 0]</span>
<span class="go"> [0 0 0 0 0 0]</span>
<span class="go"> [0 0 0 4 3 0]</span>
<span class="go"> [0 0 0 4 3 0]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses dilation to expand each label’s area and then checks for overlaps with other labels.</p></li>
<li><p>It works for both 2D and 3D images.</p></li>
<li><p>The resulting contact_labels map only shows where different labels meet; the rest of the area remains zero.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>labels0</cite> is not 2D or 3D, or if there are issues with dilation or label matching.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.get_neighbor_feature_map">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">get_neighbor_feature_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neighbor_function=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contact_labels=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**neighbor_function_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#get_neighbor_feature_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.get_neighbor_feature_map" title="Link to this definition"></a></dt>
<dd><p>Constructs a map where each cell’s pixels are annotated with a feature value that quantifies some aspect of
its relationship with neighboring cells. This is typically used in image analysis to evaluate how cells or
segments interact with each other based on defined criteria.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A labeled image where each unique positive integer represents a distinct region or cell.</p></li>
<li><p><strong>neighbor_function</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">callable</span></code>) – A function that computes a feature value given two labels. This function should accept at least two arguments,
the labels of two neighboring regions, and return a scalar value that quantifies some aspect of their relationship.</p></li>
<li><p><strong>contact_labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A precomputed array the same shape as <cite>labels</cite> where each cell in a contact region contains the label of the
neighboring region it is in contact with. If None, it will be computed within this function using <cite>get_contact_labels</cite>.</p></li>
<li><p><strong>dtype</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">data-type</span></code>, <em>optional</em>) – The desired data-type for the output feature map. Default is np.float64.</p></li>
<li><p><strong>**neighbor_function_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – Additional keyword arguments to pass to <cite>neighbor_function</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>neighbor_feature_map</strong> – An image of the same shape as <cite>labels</cite> where each pixel in a contact region is annotated with the feature value
computed by <cite>neighbor_function</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p><cite>neighbor_function</cite> should be chosen based on the specific analysis required, e.g., calculating the distance,
overlap, or other relational metrics between neighboring regions.</p></li>
<li><p>If <cite>contact_labels</cite> is not provided, the function calculates it internally, which may increase computational time.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>labels</cite> does not have at least one dimension or if <cite>neighbor_function</cite> is not provided.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.get_pca_fromdata">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">get_pca_fromdata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#get_pca_fromdata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.get_pca_fromdata" title="Link to this definition"></a></dt>
<dd><p>A wrapper for sklearn Principal Component Analysis (PCA) on the provided dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(n_samples</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">n_features)</span></code>) – The data matrix on which to perform PCA. Each row corresponds to a sample, and each column corresponds to a feature.</p></li>
<li><p><strong>dim</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The specific number of principal components to retain. If -1, <cite>dim</cite> is ignored and <cite>var_cutoff</cite> is used instead.</p></li>
<li><p><strong>var_cutoff</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The proportion of variance to retain. If <cite>dim</cite> is not -1, this parameter is ignored, and <cite>dim</cite> components are kept.
Otherwise, the number of components is chosen to retain the specified variance proportion.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Xpca</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The transformed data in the principal component space.</p></li>
<li><p><strong>pca</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">PCA</span> <span class="pre">object</span></code>) – The PCA object from sklearn that contains the variance and principal component information.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>var_cutoff</cite> is used and set to less than 1, PCA selects the minimum number of principal components such that
at least the specified variance proportion is retained.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>var_cutoff</cite> is not between 0 and 1, or if <cite>dim</cite> is less than -1 or more than the number of features in the data.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.meanIntensity">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">meanIntensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#meanIntensity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.meanIntensity" title="Link to this definition"></a></dt>
<dd><p>Calculates the mean intensity of a specified region in an image, based on a given mask.</p>
<p>This function computes the mean value of pixel intensities within the area defined by the mask, where
the mask contains non-zero values indicating the region of interest. The function handles regions without
valid pixels (i.e., all zero mask or masked pixels) by returning NaN for those cases.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary mask where non-zero values delineate the region of interest over which the mean intensity is calculated.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The intensity image where each pixel’s value represents its intensity, typically derived from grayscale or other types of imaging.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>mean_intensity</strong> – The average intensity across all pixels within the region defined by <cite>regionmask</cite>. Returns NaN if the mask does not cover any valid pixels.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>  <span class="c1"># Example intensity array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_intensity</span> <span class="o">=</span> <span class="n">meanIntensity</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mean_intensity</span><span class="p">)</span>
<span class="go">4.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.features.totalIntensity">
<span class="sig-prename descclassname"><span class="pre">celltraj.features.</span></span><span class="sig-name descname"><span class="pre">totalIntensity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">regionmask</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/features.html#totalIntensity"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.features.totalIntensity" title="Link to this definition"></a></dt>
<dd><p>Computes the total intensity of a specified region within an image, using a mask to define the region.</p>
<p>This function sums the intensities of all pixels that fall within the region of interest specified by the mask.
Pixels in the mask with non-zero values are considered part of the region. It is robust against NaN values in
the intensity array, ignoring them in the sum.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>regionmask</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary or boolean mask where non-zero or True values indicate the pixels to be included in the total intensity calculation.</p></li>
<li><p><strong>intensity</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of the same shape as <cite>regionmask</cite> containing intensity values for each pixel.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>total_intensity</strong> – The sum of the intensities of the pixels identified by <cite>regionmask</cite>. If all relevant pixels are NaN, returns 0.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">regionmask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">intensity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>  <span class="c1"># Example intensity array</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">total_intensity</span> <span class="o">=</span> <span class="n">totalIntensity</span><span class="p">(</span><span class="n">regionmask</span><span class="p">,</span> <span class="n">intensity</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">total_intensity</span><span class="p">)</span>
<span class="go">2.0</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-celltraj.imageprep">
<span id="celltraj-imageprep-module"></span><h2>celltraj.imageprep module<a class="headerlink" href="#module-celltraj.imageprep" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.clean_labeled_mask">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">clean_labeled_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">masks_nuc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_borders</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_padding</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">edge_buffer</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'largest'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_map</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">test_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#clean_labeled_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.clean_labeled_mask" title="Link to this definition"></a></dt>
<dd><p>Cleans up a labeled mask by removing small or large objects based on size thresholds, handling image borders,
and optionally filling holes within the objects. This function can also trim padding around the image and
filter objects based on a secondary map.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>masks_nuc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An integer-labeled mask where each unique positive integer represents a separate object, and 0 represents the background.</p></li>
<li><p><strong>remove_borders</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, removes objects touching the image border. Default is False.</p></li>
<li><p><strong>remove_padding</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, removes padding around the image, focusing the mask on the central region. Default is False.</p></li>
<li><p><strong>edge_buffer</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Defines a buffer zone around the edges when removing border-touching objects. Default is 0.</p></li>
<li><p><strong>minsize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The minimum size threshold for objects to be retained. Objects smaller than this are removed. Default is None, which disables this filter.</p></li>
<li><p><strong>maxsize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The maximum size threshold for objects. Objects larger than this are removed. Default is None, which disables this filter.</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, print details about object removal. Default is False.</p></li>
<li><p><strong>fill_holes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, fills holes within each labeled object. Default is True.</p></li>
<li><p><strong>selection</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – The method for selecting objects within a connected component. Supported values are ‘largest’ to keep only the largest object. Default is ‘largest’.</p></li>
<li><p><strong>test_map</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An additional map used to test objects for a secondary criterion, such as intensity thresholding. Default is None.</p></li>
<li><p><strong>test_cut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The cutoff value used along with <cite>test_map</cite> to decide whether an object should be retained. Default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A cleaned labeled mask with the same shape as <cite>masks_nuc</cite>, where retained objects are relabeled consecutively starting from 1, and background remains 0.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labeled_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cleaned_mask</span> <span class="o">=</span> <span class="n">clean_labeled_mask</span><span class="p">(</span><span class="n">labeled_mask</span><span class="p">,</span> <span class="n">minsize</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">fill_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cleaned_mask</span><span class="p">)</span>
<span class="go">[[0 1 1]</span>
<span class="go"> [1 0 0]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function is useful for post-processing segmentation outputs where removal of noise and small artifacts is necessary.</p></li>
<li><p>If <cite>remove_padding</cite> is used, ensure that the indices provided match the actual data layout to avoid misalignment.</p></li>
<li><p>Combining <cite>test_map</cite> and <cite>test_cut</cite> allows for sophisticated filtering based on specific measurement criteria, such as fluorescence intensity or other cell properties.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.create_h5">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">create_h5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#create_h5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.create_h5" title="Link to this definition"></a></dt>
<dd><p>Creates an HDF5 file and stores data from a dictionary into it under a specified group. The function checks if the file
already exists and handles it based on the ‘overwrite’ parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the file to create. This should include the path if the file is not to be created in the current directory.</p></li>
<li><p><strong>dic</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – The dictionary containing the data to be stored. This dictionary will be saved in the HDF5 file under the ‘/metadata/’ group.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, if the file exists it will be overwritten. If False and the file exists, the function will return an error and not overwrite the file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns 0 if the file was created and data was successfully saved. Returns 1 if an error occurred, such as if the file already exists and
‘overwrite’ is False, or if there is an issue in writing the data to the file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;key1&#39;</span><span class="p">:</span> <span class="s1">&#39;value1&#39;</span><span class="p">,</span> <span class="s1">&#39;key2&#39;</span><span class="p">:</span> <span class="s1">&#39;value2&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">result</span> <span class="o">=</span> <span class="n">create_h5</span><span class="p">(</span><span class="s1">&#39;data.h5&#39;</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="p">)</span>  <span class="c1"># If file does not exist or overwrite is True</span>
<span class="go">0</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function uses the ‘utilities.save_dict_to_h5’ to save the dictionary into the HDF5 file.</p></li>
<li><p>It is important to handle exceptions during the file operation to avoid partial writes or file corruption.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.crop_image">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">crop_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tshift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nx</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ny</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#crop_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.crop_image" title="Link to this definition"></a></dt>
<dd><p>Crop and resize an image based on specified translation shifts and dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The original image to be cropped.</p></li>
<li><p><strong>tshift</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A tuple or array indicating the x and y translation shifts where cropping should start.</p></li>
<li><p><strong>nx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The desired width of the cropped image.</p></li>
<li><p><strong>ny</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The desired height of the cropped image.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>img_cropped</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The cropped and resized image.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Description</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">-----------</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">This</span> <span class="pre">function</span> <span class="pre">crops</span> <span class="pre">the</span> <span class="pre">image</span> <span class="pre">starting</span> <span class="pre">from</span> <span class="pre">a</span> <span class="pre">point</span> <span class="pre">defined</span> <span class="pre">by</span> <span class="pre">`tshift</span></code> (top-left corner` of <code class="xref py py-class docutils literal notranslate"><span class="pre">the</span> <span class="pre">crop)</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">and</span> <span class="pre">extends</span> <span class="pre">the</span> <span class="pre">crop</span></code> to <code class="xref py py-class docutils literal notranslate"><span class="pre">the</span> <span class="pre">specified</span> <span class="pre">width</span> <span class="pre">(`nx</span></code>)` and <code class="xref py py-class docutils literal notranslate"><span class="pre">height</span> <span class="pre">(`ny</span></code>). After cropping`, <code class="xref py py-class docutils literal notranslate"><span class="pre">it</span> <span class="pre">resizes</span> <span class="pre">the</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">cropped</span> <span class="pre">portion</span> <span class="pre">back</span></code> to <code class="xref py py-class docutils literal notranslate"><span class="pre">the</span> <span class="pre">dimensions</span> <span class="pre">(`nx`</span></code>, <cite>ny</cite>) using an anti-aliasing filter to <code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span> <span class="pre">the</span> <span class="pre">quality.</span></code></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p># Example of using the function to crop and resize an image:
&gt;&gt;&gt; img = np.random.rand(100, 100)  # Create a random image of size 100x100
&gt;&gt;&gt; tshift = (10, 10)  # Start the crop 10 pixels down and right
&gt;&gt;&gt; nx, ny = 50, 50  # Dimensions of the cropped and resized image
&gt;&gt;&gt; cropped_img = crop_image(img, tshift, nx, ny)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.dist_to_contact">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">dist_to_contact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#dist_to_contact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.dist_to_contact" title="Link to this definition"></a></dt>
<dd><p>Calculate a contact potential value based on distance, using a Lennard-Jones-like formula.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The radial distance or distances at which the potential is evaluated. Can be a single value or an array.</p></li>
<li><p><strong>r0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Characteristic distance scale, typically representing the distance beyond which the potential significantly decreases.</p></li>
<li><p><strong>d0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Offset distance, representing a threshold below which the potential is set to 1 (indicating maximum interaction).</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Power of the repulsive component of the potential. Default is 6.</p></li>
<li><p><strong>m</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Power of the attractive component of the potential. Default is 12.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>c</strong> – Computed potential values at each distance <cite>r</cite>. If <cite>r</cite> is an array, <cite>c</cite> will be an array of the same size.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function computes a value based on the generalized Lennard-Jones potential form:
c(r) = (1 - w^n) / (1 - w^m) if r &gt;= d0,
c(r) = 1 if r &lt; d0,
where w = (r - d0) / r0.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">dist_to_contact</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">0.25</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dist_to_contact</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="go">array([1.   , 1.   , 1.   , 0.75 , 0.25])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.expand_registered_images">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">expand_registered_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tSet</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#expand_registered_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.expand_registered_images" title="Link to this definition"></a></dt>
<dd><p>Applies transformations to a stack of images and expands them so that they align according to the provided transformation set.
This function is useful for aligning images based on calculated translations and optionally rotations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>) – A stack of images where each image has dimensions (Z, X, Y). If a list is provided, it will be converted to an ndarray.</p></li>
<li><p><strong>tSet</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of transformations for each image. Each transformation is a tuple or list of (radial angle, x-translation, y-translation),
where angle is in degrees and translations are in pixels.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An ndarray containing the expanded and registered image stack. The dimensions of the output images will be adjusted to
accommodate the maximum translation offsets to ensure all images fit within the new dimensions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgs</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)]</span>  <span class="c1"># Create a list of random images</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tSet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">]</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">10</span><span class="p">)])</span>  <span class="c1"># Example transformations</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">registered_imgs</span> <span class="o">=</span> <span class="n">expand_registered_images</span><span class="p">(</span><span class="n">imgs</span><span class="p">,</span> <span class="n">tSet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">registered_imgs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(10, 105, 100)  # Output dimensions may vary based on transformations</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The transformations are applied using an affine transformation, where translations are adjusted to ensure no image content is lost.</p></li>
<li><p>The function automatically pads images based on the maximum translations specified in <cite>tSet</cite> to prevent image cropping.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_cell_centers">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_cell_centers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_cell_centers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_cell_centers" title="Link to this definition"></a></dt>
<dd><p>Calculates the centers of mass for labeled regions in an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array where each labeled region (cell) is marked with a distinct integer.
The background should be labeled as 0.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>centers</strong> – An array of coordinates representing the centers of mass for each labeled region.
Each row corresponds to a label, and the columns correspond to the coordinates along each dimension.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function returns the center of mass for each distinct label found in the <cite>labels</cite> array.
The function will return an empty array if there are no labels greater than zero.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="n">get_cell_centers</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
<span class="go">[[2.5, 2.5], [3. , 0.5], [3. , 2.5]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_cell_intensities">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_cell_intensities</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">averaging</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_3D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_cell_intensities"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_cell_intensities" title="Link to this definition"></a></dt>
<dd><p>Calculate the sum or average intensity for each cell in a labeled image or image stack. This function
handles both 2D and 3D images and can operate on multi-channel data, summing or averaging the intensities
for each label in each channel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The image or image stack from which to calculate intensities. Can be 2D, 3D, or higher dimensions
if channels are involved.</p></li>
<li><p><strong>labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An integer array of the same shape as <cite>img</cite> where each unique non-zero value indicates a distinct
cell region.</p></li>
<li><p><strong>averaging</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, calculate the mean intensity for each cell. If False, calculate the total intensity.
Default is False.</p></li>
<li><p><strong>is_3D</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Set to True if <cite>img</cite> includes 3D spatial data (as opposed to 2D images with multiple channels).
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 1D array of intensities for each cell. If <cite>img</cite> includes multiple channels, the result will be
a 2D array with one row per cell and one column per channel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]],</span> <span class="p">[[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_cell_intensities</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">averaging</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([2.5, 6.5])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If <cite>averaging</cite> is False, the function sums the pixel values for each cell; if True, it averages them.</p></li>
<li><p>The function handles multi-channel images correctly for both 2D and 3D cases, adjusting its behavior
based on the <cite>is_3D</cite> parameter.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_contactsum_dev">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_contactsum_dev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">centers1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rp1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">savefile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_contactsum_dev"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_contactsum_dev" title="Link to this definition"></a></dt>
<dd><p>Calculate a grid-based sum of contact deviations for center points translated across an image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>centers1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of original center points (x, y coordinates).</p></li>
<li><p><strong>centers2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of target center points for comparison (x, y coordinates).</p></li>
<li><p><strong>img2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The image data used for setting the boundary conditions for translations.</p></li>
<li><p><strong>rp1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Interaction potential radius to determine the contact potential calculation.</p></li>
<li><p><strong>nt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of translations along each axis, if None it defaults to 1/20th of the image dimension.</p></li>
<li><p><strong>savefile</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Path to save the resulting deviation grid as a NumPy binary file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>nncs_dev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A grid of normalized deviations of contact sums from their local average across the translation space.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Description</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">-----------</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">This</span> <span class="pre">function</span> <span class="pre">creates</span> <span class="pre">a</span> <span class="pre">grid</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">potential</span> <span class="pre">translation</span> <span class="pre">points</span> <span class="pre">across</span> <span class="pre">the</span> <span class="pre">image.</span> <span class="pre">For</span> <span class="pre">each</span> <span class="pre">point</span> <span class="pre">in</span> <span class="pre">this</span> <span class="pre">grid,</span></code></p></li>
<li><p>it shifts the <code class="docutils literal notranslate"><span class="pre">'centers1'</span></code> coordinates and <code class="xref py py-class docutils literal notranslate"><span class="pre">calculates</span> <span class="pre">the</span> <span class="pre">minimum</span> <span class="pre">distances</span></code> to <code class="docutils literal notranslate"><span class="pre">'centers2'</span></code> within the confines</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">of</span> <span class="pre">the</span> <span class="pre">translated</span> <span class="pre">box.</span> <span class="pre">It</span> <span class="pre">then</span> <span class="pre">calculates</span> <span class="pre">a</span> <span class="pre">contact</span> <span class="pre">potential</span> <span class="pre">using</span> <span class="pre">these</span> <span class="pre">distances</span></code> and <code class="xref py py-class docutils literal notranslate"><span class="pre">compares</span> <span class="pre">the</span> <span class="pre">sum</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">to</span> <span class="pre">the</span> <span class="pre">local</span> <span class="pre">average</span></code> to <code class="xref py py-class docutils literal notranslate"><span class="pre">assess</span> <span class="pre">deviations</span> <span class="pre">in</span> <span class="pre">potential</span> <span class="pre">interactions.</span> <span class="pre">This</span> <span class="pre">can</span> <span class="pre">help</span> <span class="pre">in</span> <span class="pre">understanding</span> <span class="pre">how</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">interactions</span> <span class="pre">vary</span> <span class="pre">spatially</span> <span class="pre">within</span> <span class="pre">an</span> <span class="pre">image.</span> <span class="pre">The</span> <span class="pre">function</span> <span class="pre">optionally</span> <span class="pre">saves</span> <span class="pre">the</span> <span class="pre">output</span> <span class="pre">grid</span></code> to <code class="xref py py-class docutils literal notranslate"><span class="pre">a</span> <span class="pre">file</span> <span class="pre">for</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">further</span> <span class="pre">analysis.</span></code></p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Example</p>
<p># Example of using the function to calculate contact deviations:
&gt;&gt;&gt; centers1 = np.array([[10, 10], [20, 20], [30, 30]])
&gt;&gt;&gt; centers2 = np.array([[15, 15], [25, 25], [35, 35]])
&gt;&gt;&gt; img = np.zeros((100, 100))
&gt;&gt;&gt; rp1 = 10
&gt;&gt;&gt; deviations = get_contactsum_dev(centers1, centers2, img, rp1, nt=10)</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_cyto_minus_nuc_labels">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_cyto_minus_nuc_labels</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels_cyto</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_nuc</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_cyto_minus_nuc_labels"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_cyto_minus_nuc_labels" title="Link to this definition"></a></dt>
<dd><p>Generates new cytoplasmic labels where nuclear labels are excluded. This function adjusts cytoplasmic
labels to ensure they do not overlap with nuclear labels by dilating nuclear areas and subtracting them
from corresponding cytoplasmic regions. This method helps in distinguishing between nuclear and
cytoplasmic components of a cell, often necessary for detailed cellular analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels_cyto</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array where each integer represents a unique cytoplasmic region.</p></li>
<li><p><strong>labels_nuc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array of the same shape as <cite>labels_cyto</cite>, where each integer represents a unique nuclear region.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array of the same shape as <cite>labels_cyto</cite>, containing the refined cytoplasmic labels with nuclear
regions excluded.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels_cyto</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_nuc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_cyto_new</span> <span class="o">=</span> <span class="n">get_cyto_minus_nuc_labels</span><span class="p">(</span><span class="n">labels_cyto</span><span class="p">,</span> <span class="n">labels_nuc</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">labels_cyto_new</span><span class="p">)</span>
<span class="go">[[1 0 0]</span>
<span class="go"> [1 0 0]</span>
<span class="go"> [0 0 0]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function ensures that nuclear regions are excluded from the cytoplasmic labels by first dilating
the nuclear masks and then eroding them before subtracting from the cytoplasmic masks.</p></li>
<li><p>The output labels for cytoplasmic areas are adjusted to ensure no overlap with nuclear regions.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – Raises an exception if there is an error during the label processing steps.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_feature_map">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_feature_map</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">features</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_feature_map"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_feature_map" title="Link to this definition"></a></dt>
<dd><p>Maps an array of features to their corresponding labels in a labeled image. Each feature is assigned to the region
of the mask identified by the same label index. This function ensures that each discrete label in the labeled mask
gets the corresponding feature value from the features array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>features</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of feature values where each entry corresponds to a label in the <cite>labels</cite> mask. The length of <cite>features</cite>
must match the highest label value in the <cite>labels</cite> mask.</p></li>
<li><p><strong>labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An integer-labeled mask where each unique positive integer represents a different region. Each region (label) will
be assigned the corresponding feature value from the <cite>features</cite> array based on its label index.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of the same shape as <cite>labels</cite> where each labeled region is filled with its corresponding feature value
from the <cite>features</cite> array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">feature_map</span> <span class="o">=</span> <span class="n">get_feature_map</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">feature_map</span><span class="p">)</span>
<span class="go">[[10 10  0]</span>
<span class="go"> [ 0 20 20]</span>
<span class="go"> [20 20  0]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is particularly useful in imaging and machine learning applications where each segmented region’s
properties need to be mapped back onto the original labeled mask for visualization or further analysis.</p></li>
<li><p>Ensure that the number of features matches the maximum label in the <cite>labels</cite> mask to avoid mismatches and errors.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the size of the <cite>features</cite> array does not match the highest label value in the <cite>labels</cite> mask.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_images">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filelist</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_images" title="Link to this definition"></a></dt>
<dd><p>Reads a list of image files and loads them into memory as arrays. This function is useful for batch processing
images for analysis or input into machine learning models.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>filelist</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A list containing the file paths of images to be loaded. Each element in the list should be a string
specifying the full path to an image file.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of image arrays, where each array corresponds to an image file from <cite>filelist</cite>. The format and
dimensions of each image array depend on the image file format and its content.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filelist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;path/to/image1.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;path/to/image2.png&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">images</span> <span class="o">=</span> <span class="n">get_images</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">images</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(&lt;class &#39;numpy.ndarray&#39;&gt;, (height, width, channels))</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function uses <cite>skimage.io.imread</cite> to load images, which supports various image formats including
JPEG, PNG, and TIFF among others.</p></li>
<li><p>The function directly reads images into memory, which may consume a lot of resources for large image
files or long lists of images.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>IOError</strong> – If any file in the list cannot be opened or read. This could be due to the file not existing, being
    unreadable, or being corrupted.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_intensity_centers">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_intensity_centers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">footprint_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">smooth_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_zeros</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_intensity_centers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_intensity_centers" title="Link to this definition"></a></dt>
<dd><p>Identifies centers of intensity within an image, optionally constrained by a mask. This function is useful for
detecting features like local maxima that represent points of interest within an image, such as cell centers in
microscopy images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The image in which intensity centers are to be identified.</p></li>
<li><p><strong>msk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A boolean mask of the same shape as <cite>img</cite> that specifies regions within which centers should be identified.
If None, the entire image is considered.</p></li>
<li><p><strong>footprint_shape</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>, <em>optional</em>) – The size of the neighborhood considered for the local maximum. Should be a tuple corresponding to the image
dimensions. If None, a minimal footprint of shape (1,1,…) for each dimension is used.</p></li>
<li><p><strong>rcut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The minimum allowed distance between centers. If centers are closer than this value, they will be merged.
If None, no merging is performed.</p></li>
<li><p><strong>smooth_sigma</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">sequence</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">floats</span></code>, <em>optional</em>) – The standard deviation for Gaussian smoothing applied to the image before identifying centers. This helps
to reduce noise and improve the robustness of center detection.</p></li>
<li><p><strong>pad_zeros</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, the image will be padded with zeros on all sides by the width specified in <cite>footprint_shape</cite>.
This helps to handle edge effects during local maximum detection.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of coordinates for the detected intensity centers.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="p">[</span><span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="n">get_intensity_centers</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">smooth_sigma</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">footprint_shape</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
<span class="go">[[2 2]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function is particularly useful for preprocessing steps in image analysis where features need to be extracted
from local intensity variations.</p></li>
<li><p>Adjusting <cite>rcut</cite> and <cite>smooth_sigma</cite> according to the scale and noise characteristics of the image can significantly
affect the accuracy and reliability of the detected centers.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_label_largestcc">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_label_largestcc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_label_largestcc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_label_largestcc" title="Link to this definition"></a></dt>
<dd><p>Processes a labeled mask to keep only the largest connected component (CC) for each unique label in the mask,
optionally filling holes within those components. This function is useful for cleaning segmentation results by
removing smaller fragments of labels and ensuring continuity in the detected objects.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>label</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An integer-labeled mask where each unique positive integer represents a separate object, and 0 represents the background.</p></li>
<li><p><strong>fill_holes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, fills holes within the labeled objects before identifying the largest connected component.
This can help in creating more robust and continuous object detections. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A labeled mask similar in shape to the input <cite>label</cite>, but with only the largest connected component retained
for each label, and all other components removed.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is particularly useful when segmentation algorithms produce noisy results or when labels are
fragmented. Cleaning up the labels to retain only the largest component can significantly improve the quality
of the final analysis, especially in quantitative measurements where object integrity is crucial.</p></li>
<li><p>If using 3D data, the function will process each slice independently unless the mask is inherently volumetric,
in which case 3D hole filling and labeling is applied.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_labeled_mask">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_labeled_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">b_imgr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgM</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_watershed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_holes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist_footprint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_labeled_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_labeled_mask" title="Link to this definition"></a></dt>
<dd><p>Processes a binary image to label connected components, optionally applying the watershed algorithm to
separate closely touching objects. This function can also fill holes within binary objects and mask out
areas from an exclusion mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>b_imgr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary image where True represents the foreground (objects to label) and False represents the background.</p></li>
<li><p><strong>imgM</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An exclusion mask where True values specify areas to ignore during labeling, such as known noise or artifacts.
If provided, any foreground in these areas will be set to False. Default is None.</p></li>
<li><p><strong>apply_watershed</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to apply the watershed algorithm to separate overlapping or touching objects using a distance transform.
Default is False.</p></li>
<li><p><strong>fill_holes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, fills holes within the binary objects. This is often useful for cleaning up segmentation artifacts.
Default is True.</p></li>
<li><p><strong>dist_footprint</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The size of the footprint used for the distance transform if applying the watershed. Specifies the connectivity
of the neighborhood used in the local maximum detection. Default is None, which uses a 3x3 square.</p></li>
<li><p><strong>zscale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The scaling factor for z-dimension in volumetric data (3D). It compensates for the difference in resolution
between xy-plane and z-axis and is used only if the image is three-dimensional. Default is None.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A labeled image where each unique integer (starting from 1) corresponds to a separate object, with 0 representing
the background.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labeled_mask</span> <span class="o">=</span> <span class="n">get_labeled_mask</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">apply_watershed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">fill_holes</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dist_footprint</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">labeled_mask</span><span class="p">))</span>
<span class="go">[0 1 2 3 ...]  # Example of labels found in the mask</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The watershed algorithm can help in separating objects that touch each other but requires careful setting of the
<cite>dist_footprint</cite> and <cite>zscale</cite> in case of volumetric data.</p></li>
<li><p>Exclusion masks are useful in experiments where certain areas need to be systematically ignored, such as damaged
regions on a slide or expected artifacts.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_mask_2channel_ilastik">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_mask_2channel_ilastik</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_ilastik</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fore_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holefill_area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">growthcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_mask_2channel_ilastik"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_mask_2channel_ilastik" title="Link to this definition"></a></dt>
<dd><p>Processes a pixel classification output from Ilastik to generate a binary mask for a specified foreground
channel. This function includes options to fill holes, apply morphological operations, and threshold the
probability maps to create a final binary mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>file_ilastik</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The path to the HDF5 file containing the Ilastik classification output.</p></li>
<li><p><strong>fore_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The index of the channel in the Ilastik output that represents the foreground probability. Default is 0.</p></li>
<li><p><strong>holefill_area</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The minimum area threshold for opening and closing operations to fill holes in the foreground mask.
If 0, no hole filling is performed. Default is 0.</p></li>
<li><p><strong>growthcycles</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of cycles of dilation followed by erosion to grow and then shrink the foreground mask.
This can help in smoothing the mask edges. Default is 0, which means no growth or erosion cycles.</p></li>
<li><p><strong>pcut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The probability cutoff threshold to convert the probability map to a binary mask. Values above this
threshold will be considered foreground. Default is 0.8.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D binary mask where pixels classified as foreground based on the specified channel and probability
threshold are marked as True, and all other pixels are False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">binary_mask</span> <span class="o">=</span> <span class="n">get_mask_2channel_ilastik</span><span class="p">(</span><span class="s1">&#39;output_from_ilastik.h5&#39;</span><span class="p">,</span> <span class="n">fore_channel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">holefill_area</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">growthcycles</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pcut</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">binary_mask</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(1024, 1024)  # Example shape for a typical output mask</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses skimage’s morphological operations for hole filling and size adjustments, which are
highly effective in post-processing segmentation masks.</p></li>
<li><p>Appropriate tuning of <cite>holefill_area</cite>, <cite>growthcycles</cite>, and <cite>pcut</cite> parameters is crucial for achieving
optimal segmentation results based on the specific characteristics of the image data.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_masks">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_masks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">masklist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fore_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">holefill_area</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">growthcycles</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.8</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_masks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_masks" title="Link to this definition"></a></dt>
<dd><p>Processes a list of Ilastik prediction files to generate binary masks based on specified foreground channels
and other morphological processing parameters. This function is useful for batch processing multiple segmentation
outputs, applying uniform post-processing steps such as hole filling, growth cycles, and probability thresholding.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>masklist</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A list of file paths to Ilastik prediction outputs (HDF5 files).</p></li>
<li><p><strong>fore_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The index of the channel in the Ilastik output that represents the foreground probabilities. Default is 0.</p></li>
<li><p><strong>holefill_area</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The minimum area threshold for opening and closing operations to fill holes in the masks. If set to 0,
no hole filling is performed. Default is 0.</p></li>
<li><p><strong>growthcycles</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of dilation followed by erosion cycles applied to the masks to enhance mask boundaries.
Default is 0, meaning no growth or erosion cycles are applied.</p></li>
<li><p><strong>pcut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The probability threshold above which a pixel is considered as foreground (mask is set to True). Default is 0.8.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of 2D binary masks where each mask corresponds to the processed output of each file in <cite>masklist</cite>.
Each mask has pixels marked as True for foreground and False for background based on the provided parameters.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">mask_files</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;path/to/ilastik_output1.h5&#39;</span><span class="p">,</span> <span class="s1">&#39;path/to/ilastik_output2.h5&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">masks</span> <span class="o">=</span> <span class="n">get_masks</span><span class="p">(</span><span class="n">mask_files</span><span class="p">,</span> <span class="n">fore_channel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">holefill_area</span><span class="o">=</span><span class="mi">500</span><span class="p">,</span> <span class="n">growthcycles</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">pcut</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">masks</span><span class="p">),</span> <span class="n">masks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">2, (1024, 1024)  # Assuming the masks are from 1024x1024 pixel images</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is particularly useful in large-scale image processing workflows where consistent mask processing
across multiple images or conditions is required.</p></li>
<li><p>Ensure that all files in <cite>masklist</cite> are accessible and properly formatted as Ilastik output HDF5 files.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileNotFoundError</strong> – If any file in <cite>masklist</cite> does not exist or cannot be read.</p></li>
<li><p><strong>ValueError</strong> – If <cite>pcut</cite> is not between 0 and 1, or other parameter constraints are violated.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_nndist_sum">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_nndist_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tshift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_nndist_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_nndist_sum" title="Link to this definition"></a></dt>
<dd><p>Calculates the sum of the nearest neighbor distances between two sets of points, potentially shifted by a vector,
with an optional distance cutoff to consider only close points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tshift</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Translation vector to apply to the first set of centers before calculating distances.</p></li>
<li><p><strong>centers1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of coordinates for the first set of points.</p></li>
<li><p><strong>centers2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of coordinates for the second set of points.</p></li>
<li><p><strong>rcut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Cutoff distance beyond which points are not considered as neighbors. If not provided,
it will default to infinity, considering all points.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>nnd</strong> – The sum of the nearest neighbor distances after considering the translation and cutoff.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function is particularly useful in optimization problems where one needs to minimize
the distance between two configurations of points subject to translations. The distance matrix
calculations are optimized by only considering points within a specified cutoff.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">centers1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">centers2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tshift</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rcut</span> <span class="o">=</span> <span class="mi">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">nnd</span> <span class="o">=</span> <span class="n">get_nndist_sum</span><span class="p">(</span><span class="n">tshift</span><span class="p">,</span> <span class="n">centers1</span><span class="p">,</span> <span class="n">centers2</span><span class="p">,</span> <span class="n">rcut</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">nnd</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_pair_rdf_fromcenters">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_pair_rdf_fromcenters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_pair_rdf_fromcenters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_pair_rdf_fromcenters" title="Link to this definition"></a></dt>
<dd><p>Calculate the radial distribution function (RDF) from a set of center points.
The RDF provides a measure of the density distribution of a set of points as a function of distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>centers</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array containing the coordinates of the center points for which the RDF is to be calculated.</p></li>
<li><p><strong>rbins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of radii to define the bins for RDF calculation. If None, bins are automatically generated.</p></li>
<li><p><strong>nr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of bins if rbins is not provided. Default is 50.</p></li>
<li><p><strong>rmax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Maximum radius to consider if rbins is not provided. Default is 500.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rbins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The radii at which the RDF is evaluated, corresponding to the bin edges.</p></li>
<li><p><strong>paircorrx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Radial distribution function values corresponding to <cite>rbins</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The radial distribution function g(r) describes how density varies as a function of distance from a reference particle,
and it is typically normalized such that g(r) approaches 1 at large distances.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbins</span><span class="p">,</span> <span class="n">rdf</span> <span class="o">=</span> <span class="n">get_pair_rdf_fromcenters</span><span class="p">(</span><span class="n">centers</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rbins</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">rdf</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_registration_expansions">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_registration_expansions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tf_matrix_set</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">imgdims</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_registration_expansions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_registration_expansions" title="Link to this definition"></a></dt>
<dd><p>Calculate the new padded dimensions for an image based on the translations found in a set of transformation matrices.
Adjusts the transformation matrices to centralize the image after applying translations.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tf_matrix_set</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of transformation matrices of shape (N, D+1, D+1) where N is the number of frames and D is the number of dimensions.</p></li>
<li><p><strong>*imgdims</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Variable length argument list specifying the original dimensions of the images (Z, Y, X) or (Y, X).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A tuple containing:
- tf_matrix_set : ndarray, the adjusted transformation matrices centered based on the maximum translation.
- pad_dims : tuple, the new dimensions for padding the image to accommodate all translations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tf_matrix_set</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span>
<span class="gp">... </span>                          <span class="p">[[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgdims</span> <span class="o">=</span> <span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>  <span class="c1"># Y, X dimensions</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjusted_tf</span><span class="p">,</span> <span class="n">pad_dims</span> <span class="o">=</span> <span class="n">get_registration_expansions</span><span class="p">(</span><span class="n">tf_matrix_set</span><span class="p">,</span> <span class="o">*</span><span class="n">imgdims</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">pad_dims</span><span class="p">)</span>
<span class="go">(105, 225)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function automatically adjusts the translation vectors in tf_matrix_set to ensure the entire image remains
visible within the new dimensions after transformation.</p></li>
<li><p>The calculated <cite>pad_dims</cite> is large enough to fit the original image plus the maximum translation offsets.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_registrations">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_registrations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_registrations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_registrations" title="Link to this definition"></a></dt>
<dd><p>Apply the pystackreg library’s StackReg algorithm to compute translations needed to register a stack of images along the Z-axis. This function assumes the stack is in the form (Z, X, Y) and uses the ‘previous’ image as a reference for registration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>imgs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 3D numpy array representing a stack of 2D images. The stack’s first dimension corresponds to the Z-axis, and each slice (X, Y) is a 2D image.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D numpy array with shape (NZ, 3), where NZ is the number of images in the stack. Each row contains three values:
- the radial angle (currently unused and set to 0),
- the x-translation,
- the y-translation.
These translations are computed to register each image with respect to the previous one in the stack.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The radial angle computation is commented out in the current implementation and could be included for more complex transformations such as rotation. The function primarily outputs translations in the x and y directions as computed by the StackReg algorithm.</p>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">imgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>  <span class="c1"># Simulated stack of 10 images</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">registrations</span> <span class="o">=</span> <span class="n">get_registrations</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">registrations</span><span class="p">)</span>
<span class="go">array([[ 0. , 5.1, -3.2],</span>
<span class="go">       [ 0. , 2.3, -1.5],</span>
<span class="go">       ...,</span>
<span class="go">       [ 0. , 0.2, -0.1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_slide_image">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_slide_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">image_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">foverlap</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">histnorm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_slide_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_slide_image" title="Link to this definition"></a></dt>
<dd><p>Constructs a single composite image from a list of tiled images based on specified row and column
information, overlap, and optional histogram normalization. This function is useful for reconstructing
large images from smaller segmented parts, such as in digital microscopy or image stitching applications.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A list of 2D arrays, where each array is an image tile.</p></li>
<li><p><strong>nrows</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of rows in the tiled image layout. If None, it is assumed that the tiling is square,
and nrows is calculated as the square root of the number of images. Defaults to None.</p></li>
<li><p><strong>ncols</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of columns in the tiled image layout. If None and nrows is also None, ncols is set to
the same value as nrows, assuming a square layout. Defaults to None.</p></li>
<li><p><strong>image_inds</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A 2D array indicating the ordering of image tiles within the grid. If None, ordering is generated
by <cite>get_tile_order</cite>. Defaults to None.</p></li>
<li><p><strong>foverlap</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The fraction of overlap between adjacent images, expressed as a decimal between 0 and 1. Defaults to 0.</p></li>
<li><p><strong>histnorm</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, histogram stretching is applied to each tile before assembly to normalize contrast across
the slide. Defaults to True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array representing the assembled slide image from the given tiles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_list</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">16</span><span class="p">)]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">slide_image</span> <span class="o">=</span> <span class="n">get_slide_image</span><span class="p">(</span><span class="n">img_list</span><span class="p">,</span> <span class="n">nrows</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">ncols</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">foverlap</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">histnorm</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">slide_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(370, 370)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function adjusts the position of each tile based on the overlap specified and stitches them together
to form a larger image.</p></li>
<li><p>The images in <cite>imgs</cite> should be of the same dimensions. Variable dimensions across tiles may lead to
unexpected results.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the dimensions of the tiles in <cite>imgs</cite> do not match or if the number of provided images does not
    fit the specified <cite>nrows</cite> and <cite>ncols</cite> layout.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_tf_matrix_2d">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_tf_matrix_2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_tf_matrix_2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_tf_matrix_2d" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_tile_order">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_tile_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nrows</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">snake</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_tile_order"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_tile_order" title="Link to this definition"></a></dt>
<dd><p>Constructs an ordering matrix for assembling image tiles, often used to arrange microscope image tiles
into a single large image. This function generates a 2D array where each element represents the
positional index of a tile in a grid layout. The layout can be in a standard or snaked pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nrows</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of rows in the tile grid.</p></li>
<li><p><strong>ncols</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of columns in the tile grid.</p></li>
<li><p><strong>snake</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, the order of tiles will alternate directions across rows to form a snaking pattern.
Specifically, odd-numbered rows (0-indexed) will be flipped. Default is False, where tiles are
ordered in a standard left-to-right, top-to-bottom pattern.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array of integers, with each value representing the index of a tile. The dimensions of the
array are determined by <cite>nrows</cite> and <cite>ncols</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nrows</span> <span class="o">=</span> <span class="mi">3</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ncols</span> <span class="o">=</span> <span class="mi">4</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">get_tile_order</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">)</span>
<span class="go">array([[11, 10,  9,  8],</span>
<span class="go">       [ 7,  6,  5,  4],</span>
<span class="go">       [ 3,  2,  1,  0]])</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">get_tile_order</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">snake</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">array([[11, 10,  9,  8],</span>
<span class="go">       [ 4,  5,  6,  7],</span>
<span class="go">       [ 3,  2,  1,  0]])</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This ordering is particularly useful in scenarios where image tiles must be stitched together in a specific
sequence to correctly reconstruct the original scene, such as in microscopy imaging where individual
fields of view are captured in a grid pattern.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_voronoi_masks">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_voronoi_masks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgM</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_voronoi_masks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_voronoi_masks" title="Link to this definition"></a></dt>
<dd><p>Generates Voronoi masks based on the centers of mass of labeled regions within an image. This function is
typically used in image segmentation tasks where each label represents a distinct object or region, and the
goal is to create a Voronoi diagram to partition the space among the nearest labels.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array where each unique non-zero integer represents a distinct labeled region.</p></li>
<li><p><strong>imgM</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A binary mask defining the foreground of the image. If None, the entire image is considered as the foreground.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D array of the same shape as <cite>labels</cite>, where each cell contains the label of the nearest labeled region,
forming Voronoi regions.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voronoi_masks</span> <span class="o">=</span> <span class="n">get_voronoi_masks</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">voronoi_masks</span><span class="p">)</span>
<span class="go">[[2 2 1]</span>
<span class="go"> [2 2 1]</span>
<span class="go"> [3 3 3]]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses Euclidean distance to determine the nearest labeled center for each pixel.</p></li>
<li><p>Voronoi masks are useful for delineating boundaries between adjacent regions based on proximity to their
respective centers of mass.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – Raises an exception if there is an error in calculating the centers of mass or assigning Voronoi regions.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.get_voronoi_masks_fromcenters">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">get_voronoi_masks_fromcenters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nuc_centers</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgM</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">selection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'closest'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#get_voronoi_masks_fromcenters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.get_voronoi_masks_fromcenters" title="Link to this definition"></a></dt>
<dd><p>Generates Voronoi masks from provided nucleus centers within a given image mask. The function assigns each pixel
to the nearest nucleus center, creating distinct regions (Voronoi tessellation). Optionally, the user can choose
to select the largest or the closest connected component within each Voronoi region as the final mask.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nuc_centers</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of nucleus center coordinates where each row represents a center (z, y, x) for 3D or (y, x) for 2D.</p></li>
<li><p><strong>imgM</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary image mask defining the area within which the Voronoi tessellation is to be computed. True values indicate
the region of interest where tessellation is applicable.</p></li>
<li><p><strong>selection</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Method for selecting the final mask within each tessellated region. Options include:
- ‘closest’: Selects the connected component closest to the nucleus center.
- ‘largest’: Selects the largest connected component within the tessellated region.
Default is ‘closest’.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A labeled mask with the same dimensions as <cite>imgM</cite>. Each pixel’s value corresponds to the region number it belongs to,
with 0 representing background or areas outside the regions of interest.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">nuc_centers</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">30</span><span class="p">,</span> <span class="mi">30</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">50</span><span class="p">,</span> <span class="mi">50</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgM</span><span class="p">[</span><span class="mi">5</span><span class="p">:</span><span class="mi">45</span><span class="p">,</span> <span class="mi">5</span><span class="p">:</span><span class="mi">45</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># Define an area of interest</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">voronoi_masks</span> <span class="o">=</span> <span class="n">get_voronoi_masks_fromcenters</span><span class="p">(</span><span class="n">nuc_centers</span><span class="p">,</span> <span class="n">imgM</span><span class="p">,</span> <span class="n">selection</span><span class="o">=</span><span class="s1">&#39;largest&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">voronoi_masks</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(50, 50)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is useful in cell imaging where cells are identified by their nuclei, and each cell’s region needs
to be delineated based on the proximity to these nuclei.</p></li>
<li><p>The Voronoi tessellation is constrained by the binary mask <cite>imgM</cite>, which means that no tessellation occurs outside
the specified mask area.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the dimensions of <cite>nuc_centers</cite> do not match the dimensions of <cite>imgM</cite> or if <cite>selection</cite> is not a recognized option.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.histogram_stretch">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">histogram_stretch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">hp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">99</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#histogram_stretch"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.histogram_stretch" title="Link to this definition"></a></dt>
<dd><p>Performs histogram stretching on an input array or image to enhance the contrast by scaling the pixel
intensity values to the specified lower and upper percentile bounds. This method spreads out the most
frequent intensity values, improving the perceptual contrast of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The input image or array to be processed. This array should contain real numbers.</p></li>
<li><p><strong>lp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The lower percentile to use for scaling the histogram. Default is 1, which uses the 1st percentile.</p></li>
<li><p><strong>hp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The upper percentile to use for scaling the histogram. Default is 99, which uses the 99th percentile.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The histogram stretched version of <cite>img</cite> where pixel values are scaled between the values at the
<cite>lp</cite> and <cite>hp</cite> percentiles.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">150</span><span class="p">,</span> <span class="mi">200</span><span class="p">,</span> <span class="mi">250</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stretched_img</span> <span class="o">=</span> <span class="n">histogram_stretch</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">lp</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">hp</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">stretched_img</span><span class="p">)</span>
<span class="go">[ 0.   0.2  0.4  0.8  1. ]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is useful for enhancing features in an image that are difficult to see due to poor
contrast between high and low intensity.</p></li>
<li><p>If the specified percentiles result in a divide-by-zero (when <cite>plow</cite> is equal to <cite>phigh</cite>), the output
will contain NaNs.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>lp</cite> or <cite>hp</cite> are not within the range [0, 100] or if <cite>lp</cite> is greater than <cite>hp</cite>.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.list_images">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">list_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imagespecifier</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#list_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.list_images" title="Link to this definition"></a></dt>
<dd><p>Lists image files in a directory matching a specified pattern by executing a shell command.
This function constructs a command to list files using Unix ‘ls’ based on the given pattern,
which includes both the path and the file matching pattern (e.g., ‘/path/to/images/<a href="#id1"><span class="problematic" id="id2">*</span></a>.jpg’).
It then executes this command and parses the output to return a list of file names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>imagespecifier</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A string that specifies the directory and pattern to match for image files.
This should be a path including a wildcard expression to match files,
for example, ‘/path/to/images/<a href="#id3"><span class="problematic" id="id4">*</span></a>.png’.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list containing the names of files that match the specified pattern. If no files match,
the list will be empty.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">image_files</span> <span class="o">=</span> <span class="n">list_images</span><span class="p">(</span><span class="s1">&#39;/path/to/images/*.jpg&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">image_files</span><span class="p">)</span>
<span class="go">[&#39;image1.jpg&#39;, &#39;image2.jpg&#39;, ...]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function relies on the Unix ‘ls’ command, which makes it platform-specific and not portable to Windows
without modification.</p></li>
<li><p>The function requires that the shell used to execute commands has access to ‘ls’, which is typical for Unix-like
systems.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>OSError</strong> – If the ‘ls’ command fails or the specified directory does not exist or cannot be accessed.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.load_for_viewing">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">load_for_viewing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fname</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#load_for_viewing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.load_for_viewing" title="Link to this definition"></a></dt>
<dd><p>Loads data and optional metadata from a specified file that was saved using Python’s pickle serialization.
This function is useful for retrieving saved datasets and their associated metadata for further processing or analysis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>fname</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The file name or path from which the data will be loaded. If only a name is provided, it assumes the file is
in the current working directory.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns a list containing the data and metadata if the file is successfully loaded. Returns 1 if there was an
error during the loading process.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">datalist</span> <span class="o">=</span> <span class="n">load_for_viewing</span><span class="p">(</span><span class="s1">&#39;example.pkl&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">data</span><span class="p">,</span> <span class="n">metadata</span> <span class="o">=</span> <span class="n">datalist</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">datalist</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
<span class="go">{&#39;description&#39;: &#39;Sample data&#39;}</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Ensure that the file specified exists and was written in the appropriate format by <cite>save_for_viewing</cite> or
another function using Python’s pickle module.</p></li>
<li><p>This function attempts to handle exceptions gracefully and will notify the user if the load operation fails.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – Raises an exception if the file cannot be opened, if reading the file fails, or if the data cannot be
    deserialized. Specific errors during the loading process are not caught explicitly but will prompt a general
    failure message.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.load_ilastik">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">load_ilastik</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">file_ilastik</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#load_ilastik"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.load_ilastik" title="Link to this definition"></a></dt>
<dd><p>Loads pixel classification results from an HDF5 file generated by Ilastik. This function reads the dataset
containing pixel predictions and returns it as a numpy array.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>file_ilastik</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The path to the HDF5 file containing the Ilastik prediction data. This file typically contains
segmented or classified image data where each pixel is assigned a label.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A multi-dimensional array extracted from the Ilastik HDF5 file. The shape of the array is typically
2D (for image data) extended by the number of label classes predicted by Ilastik. Each slice along the
third dimension corresponds to a different label class.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">prediction</span> <span class="o">=</span> <span class="n">load_ilastik</span><span class="p">(</span><span class="s1">&#39;path/to/ilastik/output.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">prediction</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(1024, 1024, 3)  # Example shape, indicating an image of 1024x1024 pixels and 3 label classes</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function assumes that the dataset is stored under the key ‘exported_data’ in the HDF5 file, which is
the default output configuration for Ilastik predictions.</p></li>
<li><p>Users should ensure that the HDF5 file exists and is not corrupted before attempting to load it.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>OSError</strong> – If the file cannot be opened, possibly due to being nonexistent or corrupted.</p></li>
<li><p><strong>KeyError</strong> – If the expected dataset ‘exported_data’ is not found in the file.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.local_threshold">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">local_threshold</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">block_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">51</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_std</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#local_threshold"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.local_threshold" title="Link to this definition"></a></dt>
<dd><p>Applies a local thresholding algorithm to an image using adaptive threshold values computed from each pixel’s
local neighborhood, adjusted by a global threshold defined as a multiple of the image’s standard deviation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>imgr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The input image array for which local thresholding is to be performed. Typically, this should be a 2D grayscale image.</p></li>
<li><p><strong>block_size</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The size of the neighborhood block used for calculating the local threshold for each pixel. This value should be an odd integer.
Default is 51, which balances responsiveness to local variations with noise reduction.</p></li>
<li><p><strong>z_std</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The standard deviation multiplier to adjust the global thresholding offset. Default is 1.0, which sets the offset to one standard
deviation of the image’s intensity values.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A binary image of the same shape as <cite>imgr</cite>, where pixels are True if their intensity is greater than the local threshold value,
otherwise False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">imgr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="o">*</span> <span class="mi">255</span>  <span class="c1"># Create a random grayscale image</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">binary_image</span> <span class="o">=</span> <span class="n">local_threshold</span><span class="p">(</span><span class="n">imgr</span><span class="p">,</span> <span class="n">block_size</span><span class="o">=</span><span class="mi">51</span><span class="p">,</span> <span class="n">z_std</span><span class="o">=</span><span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">binary_image</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 100)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Local thresholding is particularly useful in images with varying lighting conditions where global thresholding might fail.</p></li>
<li><p>The <cite>block_size</cite> determines the adaptability of the thresholding algorithm to local changes in lighting and should be chosen
based on the specific spatial scale of features of interest.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>block_size</cite> is even, as an odd-sized block is required to have a central pixel.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.make_odd">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">make_odd</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#make_odd"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.make_odd" title="Link to this definition"></a></dt>
<dd><p>Converts a number to the nearest odd integer. If the number is even, it will be increased to the next odd number.
If the number is odd, it will be returned as is.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>x</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number to be converted to the nearest odd integer.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The nearest odd integer.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">make_odd</span><span class="p">(</span><span class="mi">4</span><span class="p">))</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">make_odd</span><span class="p">(</span><span class="mi">5</span><span class="p">))</span>
<span class="go">5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">make_odd</span><span class="p">(</span><span class="mf">2.7</span><span class="p">))</span>
<span class="go">3</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function can be used where algorithm parameters such as kernel sizes need to be odd numbers (e.g., for
median filtering or convolution operations in image processing).</p></li>
<li><p>The function works by rounding up to the next integer if the input is not an integer, ensuring the result is odd.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.organize_filelist_fov">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">organize_filelist_fov</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filelist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fov_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fov_len</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#organize_filelist_fov"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.organize_filelist_fov" title="Link to this definition"></a></dt>
<dd><p>Organizes a list of image files by sorting them according to the field of view (FOV) identifier
specified within each file name. This function is useful for grouping and sorting files that include
a numeric FOV identifier at a known position within their names.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filelist</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A list containing file names to be organized.</p></li>
<li><p><strong>fov_pos</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The position in the file name string where the FOV identifier begins. If not provided, the function
will request this parameter explicitly.</p></li>
<li><p><strong>fov_len</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of characters in the file name that make up the FOV identifier (default is 2).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of file names sorted by their FOV identifiers in ascending order.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filelist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;image_fov01.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;image_fov02.tif&#39;</span><span class="p">,</span> <span class="s1">&#39;image_fov10.tif&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_files</span> <span class="o">=</span> <span class="n">organize_filelist_fov</span><span class="p">(</span><span class="n">filelist</span><span class="p">,</span> <span class="n">fov_pos</span><span class="o">=</span><span class="mi">11</span><span class="p">,</span> <span class="n">fov_len</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sorted_files</span><span class="p">)</span>
<span class="go">[&#39;image_fov01.tif&#39;, &#39;image_fov02.tif&#39;, &#39;image_fov10.tif&#39;]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function assumes that the FOV identifiers in the file names are numeric and located in a fixed position.</p></li>
<li><p>It is crucial to correctly specify <cite>fov_pos</cite> and <cite>fov_len</cite> to ensure files are correctly identified and sorted.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>fov_pos</cite> is None, indicating the position of the FOV specifier was not set.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.organize_filelist_time">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">organize_filelist_time</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filelist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#organize_filelist_time"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.organize_filelist_time" title="Link to this definition"></a></dt>
<dd><p>Organizes a list of image files by sorting them based on timestamps contained in the filenames.
The expected timestamp format is “??d??h??m” (e.g., “02d11h30m” for 2 days, 11 hours, and 30 minutes).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filelist</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A list containing filenames to be organized, each containing a timestamp.</p></li>
<li><p><strong>time_pos</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The starting position in the filename where the timestamp pattern begins. If None, the function
searches for a timestamp anywhere in the filename.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of filenames sorted by their timestamps in ascending order.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">filelist</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;image_02d11h30m.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;image_01d05h00m.jpg&#39;</span><span class="p">,</span> <span class="s1">&#39;image_03d12h15m.jpg&#39;</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sorted_files</span> <span class="o">=</span> <span class="n">organize_filelist_time</span><span class="p">(</span><span class="n">filelist</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sorted_files</span><span class="p">)</span>
<span class="go">[&#39;image_01d05h00m.jpg&#39;, &#39;image_02d11h30m.jpg&#39;, &#39;image_03d12h15m.jpg&#39;]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function converts each timestamp into seconds to compare and sort them effectively.</p></li>
<li><p>It is essential that the timestamp format strictly follows the “??d??h??m” pattern for correct processing.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If no timestamp can be found in a filename, or if <cite>time_pos</cite> is provided but incorrect, leading to
    unsuccessful timestamp parsing.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.pad_image">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">pad_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">maxdims</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">padvalue</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#pad_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.pad_image" title="Link to this definition"></a></dt>
<dd><p>Pads an image to the specified dimensions using a constant value, with optional padding value specification.
The function ensures the new image has central alignment relative to the original image dimensions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The image array to be padded. Can be 2D or 3D.</p></li>
<li><p><strong>*maxdims</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Variable length argument list specifying the target dimensions for padding. The number of dimensions
provided should match the dimensionality of <cite>img</cite>.</p></li>
<li><p><strong>padvalue</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The value used to fill in the padding areas. Default is 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>img</strong> – The padded image array, now resized to <cite>maxdims</cite>. If the dimensions of <cite>maxdims</cite> are less than or equal
to the original dimensions, the image will be trimmed instead.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If the number of dimensions provided in <cite>maxdims</cite> does not match the dimensionality of <cite>img</cite>.</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">padded_img</span> <span class="o">=</span> <span class="n">pad_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">padded_img</span><span class="p">)</span>
<span class="go">[[0 0 0 0]</span>
<span class="go"> [0 1 2 0]</span>
<span class="go"> [0 3 4 0]</span>
<span class="go"> [0 0 0 0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.rescale_to_int">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">rescale_to_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxint=65535</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint16'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#rescale_to_int"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.rescale_to_int" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.save_for_viewing">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">save_for_viewing</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fname</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">metadata</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#save_for_viewing"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.save_for_viewing" title="Link to this definition"></a></dt>
<dd><p>Saves data and optional metadata to a specified file using serialization. The function uses Python’s pickle module
to serialize the data and metadata into a single file. It allows for optional overwriting of existing files.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">any</span> <span class="pre">serializable</span> <span class="pre">object</span></code>) – The primary data to be saved. This can be any object that pickle can serialize.</p></li>
<li><p><strong>fname</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The file name or path where the data will be saved. If only a name is provided, the file will be saved in the
current working directory.</p></li>
<li><p><strong>metadata</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <em>optional</em>) – Additional metadata to be saved along with the main data. This should be a dictionary containing the metadata.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, will overwrite the existing file without any warnings. If False, the function will not overwrite
an existing file and will return 1 if the file already exists.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns 0 if the file was successfully saved. Returns 1 if the file already exists and overwrite is False.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;a&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;description&#39;</span><span class="p">:</span> <span class="s1">&#39;Sample data&#39;</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_for_viewing</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s1">&#39;example.pkl&#39;</span><span class="p">,</span> <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function is particularly useful for saving intermediate processing stages in data analysis pipelines where
both data and contextual metadata are important.</p></li>
<li><p>Care should be taken with the <cite>overwrite</cite> parameter to avoid unintentional data loss.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Exception</strong> – Raises an exception if there are issues during the file opening or writing process not related to overwriting
    existing files.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.save_frame_h5">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">save_frame_h5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">filename</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmsk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">timestamp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#save_frame_h5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.save_frame_h5" title="Link to this definition"></a></dt>
<dd><p>Saves data related to a specific frame into an HDF5 file. This function can handle images, masks, foreground masks, and features.
Each type of data is saved into a distinct dataset within the file. Existing data can be overwritten if specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>filename</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the HDF5 file to which the data will be saved.</p></li>
<li><p><strong>frame</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The frame number associated with the data to be saved.</p></li>
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The image data to save. If provided, it will be saved under ‘/images/img_&lt;frame&gt;/image’.</p></li>
<li><p><strong>msks</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The mask data to save. If provided, it will be saved under ‘/images/img_&lt;frame&gt;/mask’.</p></li>
<li><p><strong>fmsk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The foreground mask data to save. If provided, it will be saved under ‘/images/img_&lt;frame&gt;/fmsk’.</p></li>
<li><p><strong>features</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The features data to save. If provided, it will be saved under ‘/images/img_&lt;frame&gt;/features’.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to overwrite existing datasets. If False and a dataset exists, it will not overwrite and will print a message.</p></li>
<li><p><strong>timestamp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The timestamp to associate with the data. If not provided, the frame number is used as the timestamp.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">img_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">(</span><span class="mi">256</span><span class="p">,</span> <span class="mi">256</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">save_frame_h5</span><span class="p">(</span><span class="s1">&#39;example.h5&#39;</span><span class="p">,</span> <span class="n">frame</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">img</span><span class="o">=</span><span class="n">img_data</span><span class="p">,</span> <span class="n">msks</span><span class="o">=</span><span class="n">mask_data</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>This function opens the HDF5 file in append mode (‘a’), which allows adding new data without deleting existing data.
Each type of data is stored in a specific dataset structured as ‘/images/img_&lt;frame&gt;/&lt;datatype&gt;’.
If overwrite is True and the dataset already exists, it will delete the old dataset before creating a new one.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.transform_image">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">transform_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tf_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_tform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pad_dims</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">ndimage_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#transform_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.transform_image" title="Link to this definition"></a></dt>
<dd><p>Applies a geometric transformation to an image using a specified transformation matrix.
It can handle 2D and 3D transformations, supports padding, and can invert the transformation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The image to be transformed. Can be 2D or 3D.</p></li>
<li><p><strong>tf_matrix</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The transformation matrix, which must be either 3x3 for 2D transformations or 4x4 for 3D.</p></li>
<li><p><strong>inverse_tform</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, the inverse of the transformation matrix is applied. Default is False.</p></li>
<li><p><strong>pad_dims</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code>, <em>optional</em>) – Dimensions for padding the image before applying the transformation. Expected format is
(pad_before, pad_after) for each axis.</p></li>
<li><p><strong>**ndimage_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – Additional keyword arguments passed to <cite>scipy.ndimage.affine_transform</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>img_tf</strong> – The transformed image, with the same data type as the input image.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If an invalid transformation matrix is provided or if the image array is flat (1D).</p>
</dd>
</dl>
<p class="rubric">Example</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">tf_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transformed_img</span> <span class="o">=</span> <span class="n">transform_image</span><span class="p">(</span><span class="n">img</span><span class="p">,</span> <span class="n">tf_matrix</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.imageprep.znorm">
<span class="sig-prename descclassname"><span class="pre">celltraj.imageprep.</span></span><span class="sig-name descname"><span class="pre">znorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/imageprep.html#znorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.imageprep.znorm" title="Link to this definition"></a></dt>
<dd><p>Performs variance normalization (Z-normalization) on an input array or image, scaling it by its mean and standard
deviation to achieve a mean of zero and a standard deviation of one.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>img</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The input array or image to be normalized. The input should be a real array where operations such as
mean and standard deviation can be computed.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The Z-normalized version of <cite>img</cite> where each element has been scaled by the mean and standard deviation
of the original array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">normalized_img</span> <span class="o">=</span> <span class="n">znorm</span><span class="p">(</span><span class="n">img</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">normalized_img</span><span class="p">)</span>
<span class="go">[-1.41421356 -0.70710678  0.          0.70710678  1.41421356]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function handles NaN values in the input by ignoring them in the computation of the mean and
standard deviation, which prevents NaN propagation but assumes NaNs are missing data points.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ZeroDivisionError</strong> – If the standard deviation of the input array is zero.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-celltraj.model">
<span id="celltraj-model-module"></span><h2>celltraj.model module<a class="headerlink" href="#module-celltraj.model" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.clean_clusters">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">clean_clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#clean_clusters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.clean_clusters" title="Link to this definition"></a></dt>
<dd><p>Clean clusters by removing isolated clusters based on connectivity in a transition probability matrix.</p>
<p>This function identifies the largest connected component in the cluster transition graph
and retains only the clusters that are part of this component. This is used to filter out clusters
that are not well connected to the main body of data, potentially representing outliers or noise.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>clusters</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>) – A clustering object with an attribute <cite>clustercenters</cite> which is an ndarray where each row
represents the center of a cluster.</p></li>
<li><p><strong>P</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A transition probability matrix where P[i, j] represents the probability of transitioning
from cluster i to cluster j.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A clustering object similar to the input but with cluster centers filtered to only include
those in the largest connected component of the transition graph.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">csr_matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">P</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">0.8</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">float</span><span class="p">)</span>  <span class="c1"># Random transition matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cleaned_clusters</span> <span class="o">=</span> <span class="n">clean_clusters</span><span class="p">(</span><span class="n">clusters</span><span class="p">,</span> <span class="n">P</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cleaned_clusters</span><span class="o">.</span><span class="n">clustercenters</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(n, 5)  # Where n is the number of clusters in the largest connected component</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_H_eigs">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_H_eigs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_H_eigs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_H_eigs" title="Link to this definition"></a></dt>
<dd><p>Calculates the eigenvalues and eigenvectors of the Hermitian matrix formed from a given Markov transition matrix.</p>
<p>The function constructs a Hermitian matrix, <cite>H</cite>, by symmetrizing the input matrix <cite>Mt</cite> and computes its eigenvalues
and eigenvectors. The Hermitian matrix is constructed as H = 0.5 * (Mt + Mt.T) + 0.5j * (Mt - Mt.T), where <cite>Mt.T</cite>
is the transpose of <cite>Mt</cite>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Mt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A square numpy array representing a Markov transition matrix from which the Hermitian matrix <cite>H</cite> is derived.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>w</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of real eigenvalues of the Hermitian matrix, sorted in ascending order.</p></li>
<li><p><strong>v</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of the corresponding eigenvectors, where each column corresponds to an eigenvalue in <cite>w</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">get_H_eigs</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Eigenvalues:&quot;</span><span class="p">,</span> <span class="n">eigenvalues</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Eigenvectors:&quot;</span><span class="p">,</span> <span class="n">eigenvectors</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function is designed to work with stochastic matrices, such as those used in Markov models, providing an alternative matrix decomposition with real eigenvalues and unambiguous sorting of components.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_avdx_clusters">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_avdx_clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mt</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_avdx_clusters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_avdx_clusters" title="Link to this definition"></a></dt>
<dd><p>Calculates the average directional changes between clusters weighted by transition probabilities, based on cluster embeddings and a transition matrix. The result captures the average directional movement expected from one cluster to another.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_clusters</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array containing the embedded coordinates of each cluster. Each row corresponds to a cluster and the columns to the coordinates in the reduced space.</p></li>
<li><p><strong>Mt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array (transition matrix) where each element (i, j) represents the probability of transitioning from cluster i to cluster j.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dx_clusters</strong> – A 2D array where each row represents a cluster and the columns contain the sum of weighted directional changes to all other clusters, indicating the net direction and magnitude of transitions for each cluster.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_clusters</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>  <span class="c1"># Example coordinates of clusters</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>  <span class="c1"># Example transition matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx_clusters</span> <span class="o">=</span> <span class="n">get_avdx_clusters</span><span class="p">(</span><span class="n">x_clusters</span><span class="p">,</span> <span class="n">Mt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">dx_clusters</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function is useful in analyzing the overall directional dynamics of a system where clusters represent different states or configurations, and the transition matrix describes the likelihood of transitions between these states.</p></li>
<li><p>This function assumes the transition matrix is properly normalized such that each row sums to one.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_committor">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_committor</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indTargets</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indSource</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_committor"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_committor" title="Link to this definition"></a></dt>
<dd><p>Computes the committor probabilities for a Markov state model, which represent the probability of reaching a set of target states before returning to any source state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Tmatrix</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array representing the transition probability matrix of the Markov state model, where <cite>Tmatrix[i, j]</cite> is the probability of transitioning from state <cite>i</cite> to state <cite>j</cite>.</p></li>
<li><p><strong>indTargets</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>) – An array of indices representing the target states, i.e., the states to which the committor probabilities are calculated.</p></li>
<li><p><strong>indSource</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>) – An array of indices representing the source states, which are treated as absorbing states for the calculation of committor probabilities.</p></li>
<li><p><strong>conv</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The convergence threshold for the iterative solution of the committor probabilities. The iteration stops when the change in probabilities between successive iterations is below this threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>q</strong> – An array of committor probabilities, where each entry <cite>q[i]</cite> gives the probability of reaching any of the target states before any of the source states, starting from state <cite>i</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indTargets</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">indSource</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">committor_probabilities</span> <span class="o">=</span> <span class="n">get_committor</span><span class="p">(</span><span class="n">Tmatrix</span><span class="p">,</span> <span class="n">indTargets</span><span class="p">,</span> <span class="n">indSource</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">committor_probabilities</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function modifies the transition matrix to make the source states absorbing and sets the target states to have a committor probability of 1.</p></li>
<li><p>The algorithm iteratively updates the committor probabilities until changes between iterations are less than the specified convergence threshold.</p></li>
<li><p>It is essential that the transition matrix is stochastic, and the sum of probabilities from each state equals 1.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_gaussianKernelM">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_gaussianKernelM</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_gaussianKernelM"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_gaussianKernelM" title="Link to this definition"></a></dt>
<dd><p>Computes a Gaussian kernel matrix scaled by a Mahalanobis distance between two observation matrices X and Y.
Each element of the kernel matrix represents the Gaussian kernel between samples from X and Y with scaling
matrix M and bandwidths h.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Observation matrix at time t, where each row is a sample and each column is a feature.</p></li>
<li><p><strong>Y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Observation matrix at time t+1, similar in structure to X.</p></li>
<li><p><strong>M</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Mahalanobis scaling matrix, a square matrix of dimensions equal to the number of features in X and Y,
used to scale the features for the distance calculation.</p></li>
<li><p><strong>h</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A vector of sigma scalings for the Gaussian kernel, typically computed using <cite>get_kernel_sigmas</cite>. The
length of h should match the number of features in X and Y.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>k</strong> – A matrix of dimensions (n_samples_X, n_samples_Y) where each element [i, j] is the Gaussian kernel
value between the i-th sample of X and the j-th sample of Y, scaled according to M and h.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">h</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span> <span class="o">=</span> <span class="n">get_gaussianKernelM</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">K</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(5, 6)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The function applies a Mahalanobis transformation to X and Y before computing the Euclidean distance
for the Gaussian kernel. This accounts for the correlation between different features and adjusts
distances accordingly. This is particularly useful in multivariate data analysis where feature scaling
and normalization are critical.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_kernel_sigmas">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_kernel_sigmas</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vector_sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_kernel_sigmas"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_kernel_sigmas" title="Link to this definition"></a></dt>
<dd><p>Computes a vector of bandwidths (sigmas) for each feature in the observation matrix X,
scaled by a Mahalanobis matrix M, which are used to scale observations in a kernel.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Observation matrix where each row is a sample and each column is a feature.</p></li>
<li><p><strong>M</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Mahalanobis scaling matrix, which is a square matrix of dimension equal to the number of features in X.</p></li>
<li><p><strong>s</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Bandwidth scaling factor, by default 0.05.</p></li>
<li><p><strong>vector_sigma</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns a vector of sigmas for each feature; otherwise, returns a single sigma based on the aggregate statistics.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>h</strong> – If <cite>vector_sigma</cite> is True, returns an array of bandwidths (sigmas) for each feature, otherwise a single float value representing the overall bandwidth.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmas</span> <span class="o">=</span> <span class="n">get_kernel_sigmas</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">sigmas</span><span class="p">)</span>
<span class="go">[value1, value2]  # Example output; actual values will depend on input data and parameters.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The function utilizes the Mahalanobis distance to adjust the typical Euclidean distance measure, taking into account the covariance among different features, thus scaling the input features in a way that reflects their statistical properties.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_kineticstates">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_kineticstates</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vkin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstates_final</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nstates_initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pcut_final</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.01</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_nstates_initial</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cluster_ninit</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_kineticstates"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_kineticstates" title="Link to this definition"></a></dt>
<dd><p>Determines kinetic states from dynamical motifs using an iterative k-means clustering approach, aiming to find a specified number of states with sufficient representation.
This function attempts to find a user-specified number of final kinetic states (<cite>nstates_final</cite>) by iteratively applying k-means clustering and increasing the number of clusters until the desired number of states with a probability above a certain threshold (<cite>pcut_final</cite>) is achieved or the maximum limit of states (<cite>max_states</cite>) is reached. It refines the clustering by merging less probable states into their nearest more probable states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vkin</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array of dynamical motifs, where each row corresponds to a sample and columns correspond to features.</p></li>
<li><p><strong>nstates_final</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The desired number of final states to achieve with sufficient sample representation.</p></li>
<li><p><strong>nstates_initial</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The initial number of states to start clustering. If None, it is set equal to <cite>nstates_final</cite>.</p></li>
<li><p><strong>pcut_final</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The probability cutoff to consider a state as sufficiently populated. States below this cutoff are considered sparsely populated and are merged.</p></li>
<li><p><strong>seed</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Seed for random number generator for reproducibility of k-means clustering.</p></li>
<li><p><strong>max_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The maximum number of states to try before stopping the clustering process.</p></li>
<li><p><strong>return_nstates_initial</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns the number of initial states along with the state labels.</p></li>
<li><p><strong>cluster_ninit</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of times the k-means algorithm will be run with different centroid seeds.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>stateSet</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of state labels for each sample in <cite>vkin</cite>.</p></li>
<li><p><strong>nstates_initial</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The initial number of states tried, returned only if <cite>return_nstates_initial</cite> is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vkin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># Randomly generated dynamical motifs</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="n">get_kineticstates</span><span class="p">(</span><span class="n">vkin</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">pcut_final</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span> <span class="n">max_states</span><span class="o">=</span><span class="mi">50</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">states</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function ensures that all final states have a probability greater than <cite>pcut_final</cite> by merging underpopulated states into their nearest populated neighbors.</p></li>
<li><p>The process is stochastic due to the initialization of k-means; thus, setting a seed can help in achieving reproducible results.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_koopman_eig">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_koopman_eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Y</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi_X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">psi_Y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_koopman_eig"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_koopman_eig" title="Link to this definition"></a></dt>
<dd><p>Computes the Koopman operator and its eigendecomposition, which describes the evolution of
observables in a dynamical system. This method utilizes a kernel-based approach to approximate
the forward map F(X) = Y using observations X and Y.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Observation matrix at initial time, with samples as rows and features as columns.</p></li>
<li><p><strong>Y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Observation matrix at a subsequent time, aligned with X.</p></li>
<li><p><strong>M</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Mahalanobis scaling matrix for distance computation in feature space. If None, the identity matrix is used.</p></li>
<li><p><strong>s</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Scaling factor for the bandwidth of the Gaussian kernel used in the computations.</p></li>
<li><p><strong>bta</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Regularization parameter for the least-squares solution to stabilize the inversion.</p></li>
<li><p><strong>h</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Bandwidths for the Gaussian kernel. If None, they are computed internally using the scaling factor s.</p></li>
<li><p><strong>psi_X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Precomputed Gaussian kernel matrix for X. If None, it is computed within the function.</p></li>
<li><p><strong>psi_Y</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Precomputed Gaussian kernel matrix for the transformation of X to Y. If None, it is computed within the function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>K</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Approximated Koopman operator matrix, which is the linear transformation matrix in the lifted space.</p></li>
<li><p><strong>Xi</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Left eigenvectors of the Koopman operator.</p></li>
<li><p><strong>Lam</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Eigenvalues (diagonal matrix) of the Koopman operator, representing the dynamics’ temporal evolution.</p></li>
<li><p><strong>W</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Right eigenvectors of the Koopman operator.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">X</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Y</span> <span class="o">=</span> <span class="n">X</span> <span class="o">+</span> <span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">normal</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Lam</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">get_koopman_eig</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">bta</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The computation involves:
- Constructing kernel matrices for X and Y using a Gaussian kernel with Mahalanobis distance scaling.
- Solving a regularized linear system to find the Koopman operator.
- Performing eigendecomposition on the Koopman operator to extract its spectral properties, which reveal</p>
<blockquote>
<div><p>the dynamics of the underlying system.</p>
</div></blockquote>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_koopman_inference_multiple">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_koopman_inference_multiple</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">starts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">steps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmodes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_koopman_inference_multiple"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_koopman_inference_multiple" title="Link to this definition"></a></dt>
<dd><p>Predicts future states of observables using the Koopman operator framework over multiple starting indices and time steps.</p>
<p>This function uses the precomputed Koopman eigenfunctions, modes, and eigenvalues to propagate an initial state
through the dynamical system defined by the Koopman operator. The prediction considers a set of initial points
and performs the evolution for a specified number of time steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>starts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of indices specifying the starting points for the predictions. Shape should be (n_starts,).</p></li>
<li><p><strong>steps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of future time steps to predict.</p></li>
<li><p><strong>phi_X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Koopman eigenfunctions, with shape (samples, samples).</p></li>
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Koopman modes of the observables, with shape (observables, samples).</p></li>
<li><p><strong>Lam</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Diagonal matrix of Koopman eigenvalues, with shape (samples, samples).</p></li>
<li><p><strong>nmodes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>, <em>optional</em>) – Number of modes to include in the prediction or indices of specific modes to use. Default is 2.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>X_pred</strong> – Predicted values of the observables for each start index and each time step, with shape (n_starts, steps, observables).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">starts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">10</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">])</span>  <span class="c1"># Example starting indices</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">steps</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># Predict 5 steps into the future</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">predictions</span> <span class="o">=</span> <span class="n">get_koopman_inference_multiple</span><span class="p">(</span><span class="n">starts</span><span class="p">,</span> <span class="n">steps</span><span class="p">,</span> <span class="n">phi_X</span><span class="p">,</span> <span class="n">V</span><span class="p">,</span> <span class="n">Lam</span><span class="p">,</span> <span class="n">nmodes</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">predictions</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 5, number_of_observables)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function assumes that <cite>phi_X</cite>, <cite>V</cite>, and <cite>Lam</cite> are derived from the same Koopman analysis and are consistent in dimensions.</p></li>
<li><p>The evolution is that of an ensemble of identical systems initiated from the same starting point.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_koopman_modes">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_koopman_modes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">psi_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">W</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X_obs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_koopman_modes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_koopman_modes" title="Link to this definition"></a></dt>
<dd><p>Computes the Koopman modes for specified observables using the Koopman operator’s eigendecomposition.
Koopman modes represent the spatial structures associated with the dynamics captured by the Koopman eigenfunctions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>psi_X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The kernel matrix corresponding to the data, usually derived from the Gaussian kernel of the observation matrix.
Shape should be (samples, samples).</p></li>
<li><p><strong>Xi</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Right eigenvectors of the Koopman operator matrix. Shape should be (samples, samples).</p></li>
<li><p><strong>W</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Left eigenvectors of the Koopman operator matrix. Shape should be (samples, samples).</p></li>
<li><p><strong>X_obs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Observables of interest corresponding to the observations. These could be the same as the original
observations or some function/feature of them. Shape should be (samples, observables).</p></li>
<li><p><strong>bta</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Regularization parameter for the least-squares problem, default is 1.e-5.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>phi_X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Koopman eigenfunctions, computed as the product of the kernel matrix and the right eigenvectors.
Shape is (samples, samples).</p></li>
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Koopman modes of the observables, indicating how each mode contributes to the observables.
Shape is (observables, samples).</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">psi_X</span> <span class="o">=</span> <span class="n">get_gaussianKernelM</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="n">h</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">K</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">Lam</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="n">get_koopman_eig</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">phi_X</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">get_koopman_modes</span><span class="p">(</span><span class="n">psi_X</span><span class="p">,</span> <span class="n">Xi</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">X</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The function solves a regularized linear system to stabilize the inversion when calculating the Koopman modes.
The modes are useful for understanding complex dynamics in the data, capturing the essential patterns associated with changes in observables.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_kscore">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_kscore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_kscore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_kscore" title="Link to this definition"></a></dt>
<dd><p>Calculates the k-score for a given transition matrix. The k-score measures the kinetic separability
of states within the transition matrix, which is derived from the eigenvalues of the matrix. It
provides an indication of how well-separated the dynamics of the system are, based on the time it
takes to reach equilibrium from non-equilibrium states.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The transition matrix, which should be square and represent the probability of transitioning from
one state to another.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A small threshold to determine the relevance of eigenvalues close to 1 (default is 1.e-3).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The calculated k-score, which quantifies the kinetic separability of states in the transition matrix.
If the eigenvalues are such that no significant non-equilibrium dynamics are detected, it returns <cite>np.nan</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The eigenvalues are used to calculate the time constants associated with the decay modes of the system.</p></li>
</ul>
<p>Only the modes with eigenvalues less than 1 and significantly different from 1 (as determined by <cite>eps</cite>)
are considered.
- Eigenvalues exactly equal to 1 correspond to steady-state or equilibrium conditions and are excluded
from the k-score calculation.
- A higher k-score indicates that the system has more slow modes and hence more kinetic separability.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.9</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.05</span><span class="p">,</span> <span class="mf">0.95</span><span class="p">]])</span>  <span class="c1"># Example transition matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">kscore</span> <span class="o">=</span> <span class="n">get_kscore</span><span class="p">(</span><span class="n">Mt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;K-score: </span><span class="si">{</span><span class="n">kscore</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_landscape_coords_umap">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_landscape_coords_umap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vkin</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">embedding_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_landscape_coords_umap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_landscape_coords_umap" title="Link to this definition"></a></dt>
<dd><p>Just a wrapper for UMAP.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vkin</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array where each row contains dynamical motifs or any other high-dimensional data. Each row is treated as an individual data point.</p></li>
<li><p><strong>embedding_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <em>optional</em>) – Additional keyword arguments to pass to the UMAP constructor, allowing customization of the UMAP behavior (e.g., <cite>n_neighbors</cite>, <cite>min_dist</cite>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_clusters</strong> – A 2D array with two columns, representing the 2D embedded coordinates of the input data obtained via UMAP.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_clusters</span> <span class="o">=</span> <span class="n">get_landscape_coords_umap</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">min_dist</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">x_clusters</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>UMAP is a powerful method for embedding high-dimensional data into a lower-dimensional space, preserving both local and global structure of the data.</p></li>
<li><p>The flexibility to specify additional parameters allows for tuning the algorithm based on specific dataset characteristics or analysis requirements.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_motifs">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_motifs</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">w</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_motifs"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_motifs" title="Link to this definition"></a></dt>
<dd><p>Extracts and scales the last <cite>ncomp</cite> components of complex eigenvectors from a given set of eigenvectors, optionally weighted by given weights, eigenvalues can be used as weights for a kinetic scaling.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array containing eigenvectors where each column represents an eigenvector. The array can be complex-valued.</p></li>
<li><p><strong>ncomp</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The number of components from the end of each eigenvector to process.</p></li>
<li><p><strong>w</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A 1D array of weights to scale the components of the eigenvectors. If not provided, the components are processed without scaling.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vkin</strong> – A 2D array where each row represents the concatenated scaled real and imaginary parts of the last <cite>ncomp</cite> components of the eigenvectors from <cite>v</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="mi">2</span><span class="o">+</span><span class="mi">2</span><span class="n">j</span><span class="p">,</span> <span class="mi">3</span><span class="o">+</span><span class="mi">3</span><span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">4</span><span class="o">+</span><span class="mi">4</span><span class="n">j</span><span class="p">,</span> <span class="mi">5</span><span class="o">+</span><span class="mi">5</span><span class="n">j</span><span class="p">,</span> <span class="mi">6</span><span class="o">+</span><span class="mi">6</span><span class="n">j</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ncomp</span> <span class="o">=</span> <span class="mi">2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">weights</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">motifs</span> <span class="o">=</span> <span class="n">get_motifs</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">ncomp</span><span class="p">,</span> <span class="n">weights</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">motifs</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function is useful for to describe or classify a complex system based upon its dynamics as described by a stochastic matrix yielding H-eigs stored as columns in <cite>v</cite>.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_path_entropy_2point">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_path_entropy_2point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_stays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_path_entropy_2point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_path_entropy_2point" title="Link to this definition"></a></dt>
<dd><p>Calculates the entropy of transitions between states over a single step for a set of trajectories,
using a given transition matrix. The entropy is calculated based on the negative logarithm of
the transition probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>) – The initial states of the trajectories.</p></li>
<li><p><strong>x1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>) – The final states of the trajectories after one transition.</p></li>
<li><p><strong>Mt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A square matrix representing the transition probabilities between states. The element <cite>Mt[i, j]</cite>
is the probability of transitioning from state <cite>i</cite> to state <cite>j</cite>.</p></li>
<li><p><strong>clusters</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Clustering</span> <span class="pre">object</span></code>, <em>optional</em>) – A clustering object (e.g., from scikit-learn) that can assign states to <cite>x0</cite> and <cite>x1</cite> data points.
If <cite>None</cite>, <cite>x0</cite> and <cite>x1</cite> are assumed to be already in the form of state indices (default: <cite>None</cite>).</p></li>
<li><p><strong>exclude_stays</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If <cite>True</cite>, transitions where the state does not change (<cite>indc1[itraj] == indc0[itraj]</cite>) are excluded
from the entropy calculation (default: <cite>False</cite>).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The calculated entropy value for the transitions in the trajectories. Returns <cite>np.nan</cite> if the calculation
fails due to empty arrays or other errors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>x0</cite> and <cite>x1</cite> have different lengths, or if <cite>Mt</cite> is not a square matrix.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy</span> <span class="o">=</span> <span class="n">get_path_entropy_2point</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">Mt</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculated entropy: </span><span class="si">{</span><span class="n">entropy</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function assumes that <cite>Mt</cite> is properly normalized such that each row sums to 1.</p></li>
<li><p>Entropy is a measure of uncertainty or randomness. In this context, it quantifies the unpredictability</p></li>
</ul>
<p>in the transitions between states.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_path_ll_2point">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_path_ll_2point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_stays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_path_ll_2point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_path_ll_2point" title="Link to this definition"></a></dt>
<dd><p>Calculates the log-likelihood of observing specific transitions between states over one step
for a set of trajectories, using a provided transition matrix. The log-likelihood is computed
as the logarithm of transition probabilities.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>) – The initial states of the trajectories, assumed to be indices corresponding to the rows in the transition matrix.</p></li>
<li><p><strong>x1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array_like</span></code>) – The final states of the trajectories after one transition, assumed to be indices corresponding to the columns in the transition matrix.</p></li>
<li><p><strong>exclude_stays</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, transitions where the state does not change (where <cite>indc1[itraj] == indc0[itraj]</cite>) are excluded
from the log-likelihood calculation (default: False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The calculated log-likelihood value for the observed transitions in the trajectories. Returns <cite>np.nan</cite> if the calculation
fails due to empty arrays or other errors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If <cite>x0</cite> and <cite>x1</cite> have different lengths or if the transition probabilities cannot be computed because
    <cite>Mt</cite> is not correctly set in the scope of this function.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Mt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">]])</span> <span class="c1"># Example transition matrix</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">log_likelihood</span> <span class="o">=</span> <span class="n">get_path_ll_2point</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Calculated log likelihood: </span><span class="si">{</span><span class="n">log_likelihood</span><span class="si">:</span><span class="s2">.2f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function assumes that the transition matrix <cite>Mt</cite> is correctly normalized such that each row sums to 1.</p></li>
<li><p>The log-likelihood measure provides insights into the predictability of the transitions, with higher values indicating</p></li>
</ul>
<p>more predictable transitions based on the model’s transition probabilities.
- The function <cite>clusters.assign</cite> must be correctly defined to map data points <cite>x0</cite> and <cite>x1</cite> to state indices used in <cite>Mt</cite>.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_steady_state_matrixpowers">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_steady_state_matrixpowers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Tmatrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conv</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_steady_state_matrixpowers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_steady_state_matrixpowers" title="Link to this definition"></a></dt>
<dd><p>Computes the steady-state distribution of a Markov chain by repeatedly multiplying the transition matrix by itself and averaging the rows until convergence.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Tmatrix</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array representing the transition matrix of the Markov chain, where <cite>Tmatrix[i, j]</cite> is the probability of transitioning from state <cite>i</cite> to state <cite>j</cite>.</p></li>
<li><p><strong>conv</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The convergence threshold for the iterative solution. The iteration stops when the change in the steady-state distribution between successive iterations is below this threshold.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>pSS</strong> – An array representing the steady-state distribution, where <cite>pSS[i]</cite> is the long-term probability of being in state <cite>i</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Tmatrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.9</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">steady_state_distribution</span> <span class="o">=</span> <span class="n">get_steady_state_matrixpowers</span><span class="p">(</span><span class="n">Tmatrix</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">steady_state_distribution</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function uses a matrix power method, where the transition matrix is repeatedly squared to accelerate convergence to the steady state.</p></li>
<li><p>The convergence is checked every 10 iterations, comparing the average of the resulting matrix’s rows to the average from the previous iteration.</p></li>
<li><p>If the maximum number of iterations (<cite>max_iters</cite>) is reached without achieving the desired convergence, the last computed distribution is returned.</p></li>
<li><p>Ensure that the transition matrix is stochastic (rows sum to 1) and ergodic to guarantee convergence.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>Tmatrix</cite> is not a square matrix or if any rows sum to more than 1.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_traj_ll_gmean">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_traj_ll_gmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_stays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_traj_ll_gmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_traj_ll_gmean" title="Link to this definition"></a></dt>
<dd><p>Calculates the geometric mean of the log-likelihoods for the transitions of trajectories based on
their assignments to clusters and a transition matrix.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of trajectories’ data points or features from which states are derived.</p></li>
<li><p><strong>exclude_stays</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, transitions where the state does not change (stays in the same state) are excluded
from the calculation.</p></li>
<li><p><strong>states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array indicating the state assignment for each data point in <cite>xt</cite>. If None, states are assumed
to be a sequence from 0 to <cite>Mt.shape[0] - 1</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The geometric mean of the log-likelihoods of transitions between states. Returns <cite>np.nan</cite> if the
calculation fails due to empty input arrays or other computational issues.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>IndexError</strong> – If the length of <cite>states</cite> does not match the expected size based on <cite>Mt</cite>.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The log-likelihood for each transition is taken from a Markov transition matrix <cite>Mt</cite>, which must</p></li>
</ul>
<p>be accessible within the method’s scope.
- This function is particularly useful for analyzing the stability or persistence of states in
Markovian models of dynamic systems.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># Example trajectory data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>  <span class="c1"># Random state assignments</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj_ll_mean</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_traj_ll_gmean</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">states</span><span class="o">=</span><span class="n">states</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Geometric mean of log-likelihoods: </span><span class="si">{</span><span class="n">traj_ll_mean</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_transition_matrix">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_transition_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_transition_matrix" title="Link to this definition"></a></dt>
<dd><p>Calculate the transition matrix from the cluster assignments of two consecutive time points.</p>
<p>This function computes a transition matrix that represents the probabilities of transitions
between clusters from one state (x0) to the next (x1). Each element of the matrix indicates
the probability of a cell transitioning from a cluster at time t (represented by x0) to another
cluster at time t+1 (represented by x1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The dataset representing the state of each cell at time t, where each row is a cell and
its columns are features (e.g., gene expression levels, morphological features).</p></li>
<li><p><strong>x1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The dataset representing the state of each cell at time t+1, with the same structure as x0.</p></li>
<li><p><strong>clusters</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>) – A clustering object which must have a <cite>clustercenters</cite> attribute representing the centers
of each cluster and an <cite>assign</cite> method to assign each instance in x0 and x1 to a cluster.
This object typically comes from a clustering library or a custom implementation that supports
these functionalities.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D numpy array where element (i, j) represents the probability of transitioning from
cluster i at time t to cluster j at time t+1.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)))</span>  <span class="c1"># Fitting on the combined dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transition_matrix</span> <span class="o">=</span> <span class="n">get_transition_matrix</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">clusters</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">transition_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(5, 5)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.get_transition_matrix_CG">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">get_transition_matrix_CG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#get_transition_matrix_CG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.get_transition_matrix_CG" title="Link to this definition"></a></dt>
<dd><p>Calculate the coarse-grained transition matrix from the cluster assignments of two consecutive
time points, considering predefined states.</p>
<p>This function constructs a transition matrix based on states defined by cluster assignments
in x0 and x1. It counts transitions between these states to calculate probabilities,
allowing for analysis of more abstracted dynamics than direct cluster-to-cluster transitions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The dataset representing the state of each cell at time t, where each row is a cell and
its columns are features (e.g., gene expression levels, morphological features).</p></li>
<li><p><strong>x1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The dataset representing the state of each cell at time t+1, with the same structure as x0.</p></li>
<li><p><strong>clusters</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>) – A clustering object with <cite>clustercenters</cite> attribute representing the centers of each cluster
and an <cite>assign</cite> method to map instances in x0 and x1 to a cluster index.</p></li>
<li><p><strong>states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array where each element is a state assignment for the corresponding cluster index, providing
a mapping from cluster index to a higher-level state.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A 2D numpy array where element (i, j) represents the probability of transitioning from
state i at time t to state j at time t+1.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">from</span><span class="w"> </span><span class="nn">sklearn.cluster</span><span class="w"> </span><span class="kn">import</span> <span class="n">KMeans</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">)))</span>  <span class="c1"># Fitting on the combined dataset</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>  <span class="c1"># Coarse-graining clusters into states</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">transition_matrix</span> <span class="o">=</span> <span class="n">get_transition_matrix_CG</span><span class="p">(</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">clusters</span><span class="p">,</span> <span class="n">states</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">transition_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(3, 3)  # Assuming states are labeled from 0 to 2</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.update_mahalanobis_matrix_J">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">update_mahalanobis_matrix_J</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mprev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xi</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#update_mahalanobis_matrix_J"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.update_mahalanobis_matrix_J" title="Link to this definition"></a></dt>
<dd><p>Update the Mahalanobis matrix based on Koopman operator analysis, using the eigenfunctions
and eigenvalues derived from the Koopman operator. This update aims to tune the kernel
for better feature scaling in further analyses.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mprev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The previous Mahalanobis matrix, with shape (features, features), used for scaling the input data.</p></li>
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The observation matrix with shape (samples, features).</p></li>
<li><p><strong>Xi</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Right eigenvectors of the Koopman operator, with shape (samples, samples).</p></li>
<li><p><strong>V</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Left eigenvectors of the Koopman operator, with shape (samples, samples).</p></li>
<li><p><strong>lam</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Eigenvalues of the Koopman operator, arranged in a diagonal matrix with shape (samples, samples).</p></li>
<li><p><strong>h</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Vector of sigma scalings for the Gaussian kernel; if not provided, it will be computed inside the function.</p></li>
<li><p><strong>s</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Scaling factor for kernel bandwidth, default is 0.05.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – The updated Mahalanobis matrix, used for scaling the input data in the kernel.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The function computes an updated Mahalanobis matrix by evaluating the gradients of the Koopman
eigenfunctions. These gradients are used to compute fluxes in the eigenspace, which are then
used to adjust the Mahalanobis matrix to ensure that the observed flux is isotropic in all
dimensions.</p>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.update_mahalanobis_matrix_J_old">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">update_mahalanobis_matrix_J_old</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mprev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#update_mahalanobis_matrix_J_old"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.update_mahalanobis_matrix_J_old" title="Link to this definition"></a></dt>
<dd><p>Update estimation of mahalanobis matrix for kernel tuning</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mprev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">features</span> <span class="pre">x</span> <span class="pre">features</span></code>) – Koopman eigenfunctions</p></li>
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – samples by features</p></li>
<li><p><strong>phi_X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Koopman eigenfunctions, samples x samples</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – updated mahalanobis matrix using Koopman eigenfunction gradients</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.update_mahalanobis_matrix_flux">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">update_mahalanobis_matrix_flux</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mprev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">V</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#update_mahalanobis_matrix_flux"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.update_mahalanobis_matrix_flux" title="Link to this definition"></a></dt>
<dd><p>Update estimation of mahalanobis matrix for kernel tuning</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mprev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">features</span> <span class="pre">x</span> <span class="pre">features</span></code>) – Koopman eigenfunctions</p></li>
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – samples by features</p></li>
<li><p><strong>phi_X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Koopman eigenfunctions, samples x samples</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – updated mahalanobis matrix using Koopman eigenfunction gradients</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.model.update_mahalanobis_matrix_grad">
<span class="sig-prename descclassname"><span class="pre">celltraj.model.</span></span><span class="sig-name descname"><span class="pre">update_mahalanobis_matrix_grad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mprev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi_X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">s</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/model.html#update_mahalanobis_matrix_grad"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.model.update_mahalanobis_matrix_grad" title="Link to this definition"></a></dt>
<dd><p>Update estimation of mahalanobis matrix for kernel tuning</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Mprev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">features</span> <span class="pre">x</span> <span class="pre">features</span></code>) – Koopman eigenfunctions</p></li>
<li><p><strong>X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – samples by features</p></li>
<li><p><strong>phi_X</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Koopman eigenfunctions, samples x samples</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>M</strong> – updated mahalanobis matrix using Koopman eigenfunction gradients</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-celltraj.spatial">
<span id="celltraj-spatial-module"></span><h2>celltraj.spatial module<a class="headerlink" href="#module-celltraj.spatial" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.constrain_volume">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">constrain_volume</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_vols</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">volconstraint_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#constrain_volume"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.constrain_volume" title="Link to this definition"></a></dt>
<dd><p>Adjusts the positions of boundary points to achieve target volumes for different regions.</p>
<p>This function iterates through different regions identified by their indices and adjusts the
boundary points to match specified target volumes. The adjustments are performed using the
<cite>get_volconstraint_com</cite> function, which modifies the boundary points to achieve the desired volume.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing boundary information, typically with keys:
- ‘pts’: ndarray of shape (N, 3), coordinates of the boundary points.
- ‘index’: ndarray of shape (N,), indices identifying the region each point belongs to.
- ‘n’: ndarray of shape (N, 3), normals at the boundary points.</p></li>
<li><p><strong>target_vols</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A dictionary or array where each key or index corresponds to a region index, and the value is
the target volume for that region.</p></li>
<li><p><strong>exclude_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – States to be excluded from volume adjustment. If not provided, all states will be adjusted.
Default is None.</p></li>
<li><p><strong>**volconstraint_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <em>optional</em>) – Additional arguments to pass to the <cite>get_volconstraint_com</cite> function, such as maximum iterations
or convergence criteria.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>border_pts_c</strong> – An array of shape (N, 3) representing the adjusted coordinates of the boundary points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function uses volume constraints to adjust the morphology of different regions based on
specified target volumes.</p></li>
<li><p>The regions are identified by the ‘index’ values in <cite>border_dict</cite>.</p></li>
<li><p>Points belonging to excluded states are not adjusted.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;pts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]),</span>
<span class="go">                   &#39;index&#39;: np.array([1, 1, 2]),</span>
<span class="go">                   &#39;n&#39;: np.array([[0, 0, 1], [0, 1, 0], [1, 0, 0]])}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target_vols</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">:</span> <span class="mf">10.0</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="mf">5.0</span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjusted_pts</span> <span class="o">=</span> <span class="n">constrain_volume</span><span class="p">(</span><span class="n">border_dict</span><span class="p">,</span> <span class="n">target_vols</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">adjusted_pts</span><span class="p">)</span>
<span class="go">array([[ ... ]])  # Adjusted coordinates for regions with target volumes</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_LJ_force">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_LJ_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_repulsion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_LJ_force"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_LJ_force" title="Link to this definition"></a></dt>
<dd><p>Computes the Lennard-Jones (LJ) force for a given set of distances.</p>
<p>The Lennard-Jones potential models interactions between a pair of neutral atoms or molecules,
capturing both the attractive and repulsive forces. This function calculates the LJ force based on
the provided distances, interaction strength, and characteristic distance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The distance(s) at which to calculate the Lennard-Jones force. Can be a single float or an array of distances.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The depth of the potential well, representing the strength of the interaction.</p></li>
<li><p><strong>R</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The characteristic distance parameter, which influences the distance at which the potential well occurs.
Default is 1.</p></li>
<li><p><strong>max_repulsion</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, the force is limited to a maximum repulsion by setting distances below the <cite>sigma</cite> value
to <cite>sigma</cite>, where <cite>sigma</cite> is the distance at which the potential crosses zero (point of maximum repulsion).
Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>force</strong> – The computed Lennard-Jones force at each distance provided in <cite>r</cite>. The shape of the output matches the shape of <cite>r</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interaction_strength</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">characteristic_distance</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">forces</span> <span class="o">=</span> <span class="n">get_LJ_force</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">interaction_strength</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">characteristic_distance</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">forces</span><span class="p">)</span>
<span class="go">[ 0.  -24.         0.7410312]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The Lennard-Jones force is computed using the formula:
<cite>force = 48 * eps * [(sigma^12 / r^13) - 0.5 * (sigma^6 / r^7)]</cite>,
where <cite>eps</cite> is the interaction strength and <cite>sigma</cite> is the effective particle diameter, calculated
as <cite>sigma = R / 2^(1/6)</cite>.</p></li>
<li><p>The <cite>max_repulsion</cite> option ensures that no distances smaller than <cite>sigma</cite> are considered, effectively
limiting the maximum repulsive force.</p></li>
<li><p>This function can handle both scalar and array inputs for <cite>r</cite>.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_adhesive_displacement">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_adhesive_displacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surf_force_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_neighbor_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([1])</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_displacement_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=float64)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">symmetrize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">force_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_adhesive_displacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_adhesive_displacement" title="Link to this definition"></a></dt>
<dd><p>Computes the adhesive displacement between cell surfaces using a specified surface force function.</p>
<p>This function calculates the displacement of cell surfaces based on adhesive forces. It uses the states and positions of
neighboring cells to determine active interfaces and apply force-based displacements. Optionally, the displacements can
be symmetrized to ensure consistency across cell borders.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing border information, including:
- ‘pts’: ndarray of shape (N, 3), coordinates of border points.
- ‘nn_pts’: ndarray of shape (N, 3), coordinates of nearest neighbor points.
- ‘states’: ndarray of shape (N,), states of the border points.
- ‘nn_states’: ndarray of shape (N,), states of the nearest neighbor points.
- ‘nn_inds’: ndarray of shape (N,), indices of the nearest neighbor points.</p></li>
<li><p><strong>surf_force_function</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">callable</span></code>) – A function that computes the surface force based on distance and other parameters.
Should take distance, epsilon, and additional arguments as inputs.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array where <cite>eps[i, j]</cite> represents the interaction strength between state <cite>i</cite> and state <cite>j</cite>.</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A scaling factor for the displacement magnitude (default is 1.0).</p></li>
<li><p><strong>maxd</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The maximum allowed displacement. Displacements will be scaled if any calculated displacements exceed this value.</p></li>
<li><p><strong>rmin</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The minimum interaction distance. Displacements calculated from distances smaller than <cite>rmin</cite> will be set to <cite>rmin</cite>.</p></li>
<li><p><strong>rmax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The maximum interaction distance. Displacements calculated from distances larger than <cite>rmax</cite> will be set to <cite>rmax</cite>.</p></li>
<li><p><strong>active_neighbor_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array specifying the states of neighbors that are active for interaction (default is np.array([1])).</p></li>
<li><p><strong>active_displacement_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array specifying the states of cells that are active for displacement (default is an empty array, which means all states are active).</p></li>
<li><p><strong>symmetrize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, the displacements are symmetrized to ensure consistency across borders (default is True).</p></li>
<li><p><strong>**force_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <em>optional</em>) – Additional arguments to be passed to the <cite>surf_force_function</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dr</strong> – A 2D array of shape (N, 3) representing the displacements of the border points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function filters out inactive or excluded states before computing the displacement.</p></li>
<li><p>Displacement is scaled using the surface force and optionally capped by <cite>maxd</cite>.</p></li>
<li><p>Symmetrization ensures that the displacement is consistent from both interacting cells’ perspectives.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;pts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;nn_pts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;nn_states&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;nn_inds&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">surf_force_function</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">r</span><span class="p">,</span> <span class="n">eps</span><span class="p">:</span> <span class="o">-</span><span class="n">eps</span> <span class="o">*</span> <span class="p">(</span><span class="n">r</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dr</span> <span class="o">=</span> <span class="n">get_adhesive_displacement</span><span class="p">(</span><span class="n">border_dict</span><span class="p">,</span> <span class="n">surf_force_function</span><span class="p">,</span> <span class="n">eps</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dr</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_border_dict">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_border_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vdist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_nnindex</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_nnvector</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_curvature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">border_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_border_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_border_dict" title="Link to this definition"></a></dt>
<dd><p>Computes the border properties of labeled regions in a segmented image.</p>
<p>This function identifies the borders of labeled regions in a given image and calculates various properties
such as nearest neighbor indices, vectors, and curvature. It can also return the scaled distances if specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D or 3D array where each element represents a label, identifying different regions in the image.</p></li>
<li><p><strong>states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array indicating the state of each labeled region. If provided, states are used to differentiate
regions. If None, all regions are assumed to have the same state.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The radius for finding nearest neighbors around each border point (default is 10).</p></li>
<li><p><strong>vdist</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array representing a scalar value in the image, such as estimated ligand concentration, to store in the border point dictionary.</p></li>
<li><p><strong>return_nnindex</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns the nearest neighbor index for each border point (default is True).</p></li>
<li><p><strong>return_nnvector</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns the vector pointing to the nearest neighbor for each border point (default is True).</p></li>
<li><p><strong>return_curvature</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, calculates and returns the curvature at each border point (default is True).</p></li>
<li><p><strong>scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Scaling factors for each dimension of the labels array. If provided, scales the labels accordingly.</p></li>
<li><p><strong>**border_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <em>optional</em>) – Additional arguments to control border property calculations, such as ‘knn’ for the number of nearest
neighbors when computing curvature.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>border_dict</strong> – A dictionary containing the computed border properties:
- ‘pts’: ndarray of float, coordinates of the border points.
- ‘index’: ndarray of int, indices of the regions to which each border point belongs.
- ‘states’: ndarray of int, states of the regions to which each border point belongs.
- ‘nn_index’: ndarray of int, nearest neighbor indices for each border point (if <cite>return_nnindex</cite> is True).
- ‘nn_states’: ndarray of int, states of the nearest neighbors (if <cite>return_nnindex</cite> is True).
- ‘nn_pts’: ndarray of float, coordinates of the nearest neighbors (if <cite>return_nnvector</cite> is True).
- ‘nn_inds’: ndarray of int, indices of the nearest neighbors (if <cite>return_nnvector</cite> is True).
- ‘n’: ndarray of float, normals at each border point (if <cite>return_curvature</cite> is True).
- ‘c’: ndarray of float, curvature at each border point (if <cite>return_curvature</cite> is True).
- ‘vdist’: ndarray of float, scaled distances at each border point (if <cite>vdist</cite> is provided).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function is useful for analyzing cell shapes and their interactions in spatially resolved images.</p></li>
<li><p>The nearest neighbor indices and vectors can help understand cell-cell interactions and local neighborhood structures.</p></li>
<li><p>The curvature values can provide insights into the geometrical properties of cell boundaries.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">scale</span> <span class="o">=</span> <span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="n">get_border_dict</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">,</span> <span class="n">return_nnindex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_nnvector</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">border_dict</span><span class="p">[</span><span class="s1">&#39;pts&#39;</span><span class="p">])</span>
<span class="go">[[0., 1.], [0., 2.], [1., 1.], [2., 0.], [2., 1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">border_dict</span><span class="p">[</span><span class="s1">&#39;nn_index&#39;</span><span class="p">])</span>
<span class="go">[2, 2, 2, 1, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_border_properties">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_border_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_labels</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surfaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_labels_next</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_labels_prev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lin_next</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lin_prev</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vdist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_border_properties_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_border_properties"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_border_properties" title="Link to this definition"></a></dt>
<dd><p>Calculate geometric and physical properties of cell borders, with optional tracking between frames
and surface contact details.</p>
<p>This function computes properties of cell borders based on <cite>cell_labels</cite>, surface contacts, and
multipole moments up to a specified order. It supports tracking cell border displacement across
frames using optional next and previous frame labels (<cite>cell_labels_next</cite>, <cite>cell_labels_prev</cite>).
Outputs include multipole moments and border displacements useful in characterizing cell interactions
and tracking cell behaviors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of labels identifying distinct cells within the domain.</p></li>
<li><p><strong>surfaces</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>, <em>optional</em>) – List of binary masks indicating surface layers adjacent to cells (e.g., membranes or other
boundaries). Each is assigned a unique identifier.</p></li>
<li><p><strong>cell_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Array specifying a state for each cell in <cite>cell_labels</cite>. Defaults to 1 if not provided.</p></li>
<li><p><strong>surface_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Array of states corresponding to each surface in <cite>surfaces</cite>. These states must not overlap
with <cite>cell_states</cite>.</p></li>
<li><p><strong>cell_labels_next</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Label array for the next frame to track cell borders over time.</p></li>
<li><p><strong>cell_labels_prev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Label array for the previous frame, used for backward tracking of cells.</p></li>
<li><p><strong>lin_next</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code>, <em>optional</em>) – Mapping of cells in <cite>cell_labels</cite> to corresponding cells in <cite>cell_labels_next</cite>. Each entry
contains IDs of linked cells in the next frame.</p></li>
<li><p><strong>lin_prev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">lists</span></code>, <em>optional</em>) – Mapping of cells in <cite>cell_labels</cite> to corresponding cells in <cite>cell_labels_prev</cite>, used for
backward tracking.</p></li>
<li><p><strong>border_scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Resolution in microns applied to border point extraction (default is 1.0).</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Radius in pixels for calculating border properties such as contact neighbors (default is 2.0).</p></li>
<li><p><strong>order</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Order of multipole moments to calculate for each border contact (default is 1).</p></li>
<li><p><strong>return_border_properties_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns a list of property names for multipole moments alongside the border
dictionary.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – Dictionary containing calculated properties of each cell’s border, including:</p>
<ul>
<li><p><cite>pts</cite> : Array of border points.</p></li>
<li><p><cite>index</cite> : Label of each cell at the border.</p></li>
<li><p><cite>nn_states</cite> : Neighboring cell states at each border point.</p></li>
<li><p><cite>contact_properties</cite> : Array of multipole moment properties calculated up to <cite>order</cite>.</p></li>
<li><p><cite>border_dx_next</cite>, <cite>border_dx_prev</cite> : Displacements of each border in the next and previous
frames, if applicable.</p></li>
<li><p><cite>dx_next_properties</cite>, <cite>dx_prev_properties</cite> : Arrays of multipole moments based on border
displacement for next and previous frames.</p></li>
</ul>
</li>
<li><p><strong>border_properties_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – List of property names for <cite>contact_properties</cite> array if <cite>return_border_properties_list</cite>
is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p><strong>Multipole Moment Calculation</strong>: Moments up to the specified <cite>order</cite> are computed based on
border charges (representing contact fraction) for each border point.</p></li>
<li><p><strong>Cell Tracking</strong>: When provided with <cite>cell_labels_next</cite> or <cite>cell_labels_prev</cite>, the function
calculates optimal transport (OT) vectors to track border movement between frames.</p></li>
</ul>
<p class="rubric">Examples</p>
<p>Calculate properties of cell borders and multipole moments with next-frame tracking:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span><span class="p">,</span> <span class="n">property_list</span> <span class="o">=</span> <span class="n">get_border_properties</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">cell_labels</span><span class="o">=</span><span class="n">my_cell_labels</span><span class="p">,</span> <span class="n">surfaces</span><span class="o">=</span><span class="n">my_surfaces</span><span class="p">,</span> <span class="n">cell_states</span><span class="o">=</span><span class="n">my_states</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">cell_labels_next</span><span class="o">=</span><span class="n">my_next_frame_labels</span><span class="p">,</span> <span class="n">lin_next</span><span class="o">=</span><span class="n">my_next_frame_links</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">border_scale</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">radius</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">return_border_properties_list</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_boundary_multipole_moments">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_boundary_multipole_moments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_charge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_moments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_boundary_multipole_moments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_boundary_multipole_moments" title="Link to this definition"></a></dt>
<dd><p>Compute normalized radial magnitudes of spherical multipole moments for a discrete boundary charge distribution.</p>
<p>This function uses the <cite>multipoles</cite> package to perform a multipole expansion of the scalar charges
located at the coordinates <cite>border_pts</cite>. It returns, for each multipole order ℓ from 0 up to <cite>order</cite>,
the magnitude of the vector of raw (ℓ,m) moments, normalized by the number of charges and by (2ℓ+1).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_pts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">D)</span></code>) – Coordinates of N boundary points in D dimensions (typically D=2 or 3).</p></li>
<li><p><strong>border_charge</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(N,)</span></code>) – Scalar “charge” values assigned to each boundary point.</p></li>
<li><p><strong>order</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Maximum multipole order ℓ to compute (default is 1, computing monopole and dipole).</p></li>
<li><p><strong>return_moments</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, also return the full set of raw multipole moments for each ℓ and m.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul>
<li><p><strong>magnitudes</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(order+1,)</span></code>) – For each ℓ = 0..order, the normalized radial magnitude of the multipole moments:
[</p>
<blockquote>
<div><p>text{magnitude}_ell = frac{1}{(2ell+1),N} , bigllVert , M_{ell, m}bigrrVert_{m=-ell..ell}</p>
</div></blockquote>
<p>]</p>
</li>
<li><p><strong>moments</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <em>optional</em>) – Only returned if <cite>return_moments=True</cite>. A nested dictionary <cite>moments[ℓ][m]</cite> containing the raw
complex multipole moment for each order ℓ and degree m.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Relies on the <cite>multipoles</cite> package:
<a class="reference external" href="https://github.com/maroba/multipoles?tab=readme-ov-file">https://github.com/maroba/multipoles?tab=readme-ov-file</a></p></li>
<li><p>Points with non-finite charges are filtered out before expansion.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_flux_displacement">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_flux_displacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flux_function</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmeans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fsigmas</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">flux_function_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_flux_displacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_flux_displacement" title="Link to this definition"></a></dt>
<dd><p>Calculates the displacement of border points using flux information.</p>
<p>This function computes the displacement of border points by applying a flux function or random sampling
based on mean and standard deviation values. The displacements can be controlled by normal vectors,
excluded for certain states, and scaled to a maximum displacement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing information about the current cell borders, including:
- ‘n’: ndarray of shape (N, 3), normal vectors at the border points.
- ‘states’: ndarray of shape (N,), states of the border points.</p></li>
<li><p><strong>border_features</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Features at the border points used as input to the flux function (default is None).</p></li>
<li><p><strong>flux_function</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">callable</span></code>, <em>optional</em>) – A function that takes <cite>border_features</cite> and additional arguments to compute mean (<cite>fmeans</cite>) and standard
deviation (<cite>fsigmas</cite>) of the flux at each border point (default is None, meaning random sampling is used).</p></li>
<li><p><strong>exclude_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – A list or array of states to exclude from displacement calculations (default is None, meaning no states are excluded).</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Normal vectors at the border points. If None, normal vectors are taken from <cite>border_dict[‘n’]</cite> (default is None).</p></li>
<li><p><strong>fmeans</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – Mean flux value(s) for random sampling (default is 0.). If <cite>flux_function</cite> is provided, this value is ignored.</p></li>
<li><p><strong>fsigmas</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – Standard deviation of flux value(s) for random sampling (default is 0.). If <cite>flux_function</cite> is provided, this value is ignored.</p></li>
<li><p><strong>random_seed</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Seed for the random number generator to ensure reproducibility (default is None).</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A scaling factor for the displacement magnitude (default is 1.0).</p></li>
<li><p><strong>maxd</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The maximum allowed displacement. If specified, the displacement is scaled to ensure it does not exceed this value (default is None).</p></li>
<li><p><strong>**flux_function_args</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>, <em>optional</em>) – Additional arguments to pass to the <cite>flux_function</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dx</strong> – A 2D array of shape (N, 3) representing the displacements of the border points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function can use a flux function to calculate displacements based on border features or perform random sampling
with specified mean and standard deviation values.</p></li>
<li><p>Displacement deviations are scaled by normal vectors and can be controlled by <cite>alpha</cite> and capped by <cite>maxd</cite>.</p></li>
<li><p>Excludes displacements for specified states, if <cite>exclude_states</cite> is provided.</p></li>
<li><p>The random number generator can be seeded for reproducibility using <cite>random_seed</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="n">get_flux_displacement</span><span class="p">(</span><span class="n">border_dict</span><span class="p">,</span> <span class="n">fmeans</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">fsigmas</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">random_seed</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span> <span class="n">maxd</span><span class="o">=</span><span class="mf">0.2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_flux_ligdist">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_flux_ligdist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vdist</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmean</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">csigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.5</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_flux_ligdist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_flux_ligdist" title="Link to this definition"></a></dt>
<dd><p>Calculate the mean and standard deviation of flux values based on ligand distribution.</p>
<p>This function computes the flux mean and standard deviation for a given ligand distribution, using
specified parameters for the mean and scaling factor for the standard deviation. Optionally, it can
center the mean flux to ensure the overall flux is balanced.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vdist</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 3D array representing the ligand concentration distribution in a tissue volume.</p></li>
<li><p><strong>cmean</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A scaling factor for the mean flux. Default is 1.0.</p></li>
<li><p><strong>csigma</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A scaling factor for the standard deviation of the flux. Default is 0.5.</p></li>
<li><p><strong>center</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, centers the mean flux distribution around zero by subtracting the overall mean. Default is True.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fmeans</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 3D array representing the mean flux values based on the ligand distribution.</p></li>
<li><p><strong>fsigmas</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 3D array representing the standard deviation of flux values based on the ligand distribution.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ligand_distribution</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mean_flux</span><span class="p">,</span> <span class="n">sigma_flux</span> <span class="o">=</span> <span class="n">get_flux_ligdist</span><span class="p">(</span><span class="n">ligand_distribution</span><span class="p">,</span> <span class="n">cmean</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">csigma</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">mean_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">sigma_flux</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 100, 50) (100, 100, 50)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses the absolute value of <cite>vdist</cite> to calculate the standard deviation of the flux.</p></li>
<li><p>Centering the mean flux helps in ensuring there is no net flux imbalance across the tissue volume.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_labels_fromborderdict">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_labels_fromborderdict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">labels_shape</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">active_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">connected</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">random_seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_labels_fromborderdict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_labels_fromborderdict" title="Link to this definition"></a></dt>
<dd><p>Generates a label mask from a dictionary of border points and associated states.</p>
<p>This function creates a 3D label array by identifying regions enclosed by the boundary points
in <cite>border_dict</cite>. It assigns unique labels to each region based on the indices of the border points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing the border points and associated information. Expected keys include:
- ‘pts’: ndarray of shape (N, D), coordinates of the border points.
- ‘index’: ndarray of shape (N,), labels for each border point.
- ‘states’: ndarray of shape (N,), states associated with each border point.</p></li>
<li><p><strong>labels_shape</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ints</span></code>) – The shape of the output labels array.</p></li>
<li><p><strong>active_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – A list or array of states to include in the labeling. If None, all unique states
in <cite>border_dict[‘states’]</cite> are used.</p></li>
<li><p><strong>surface_labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A pre-existing label array to use as a base. Regions with non-zero values in this
array will retain their labels.</p></li>
<li><p><strong>connected</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, ensures that labeled regions are connected. Uses the largest connected
component labeling method.</p></li>
<li><p><strong>random_seed</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – A seed for the random number generator to ensure reproducibility.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>labels</strong> – An array of the same shape as <cite>labels_shape</cite> with labeled regions. Each unique region
enclosed by border points is assigned a unique label.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function utilizes convex hull and Delaunay triangulation to determine the regions
enclosed by the border points.</p></li>
<li><p>It can be used to generate labels for 3D volumes, based on the locations and states of border points.</p></li>
<li><p>The function includes options for randomization and enforcing connectivity of labeled regions.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;pts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]]),</span>
<span class="gp">... </span>    <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels_shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">labels</span> <span class="o">=</span> <span class="n">get_labels_fromborderdict</span><span class="p">(</span><span class="n">border_dict</span><span class="p">,</span> <span class="n">labels_shape</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">labels</span><span class="p">)</span>
<span class="go">array([[[1, 1, 0],</span>
<span class="go">        [1, 1, 0],</span>
<span class="go">        [0, 0, 0]],</span>
<span class="go">       [[1, 1, 0],</span>
<span class="go">        [1, 1, 0],</span>
<span class="go">        [0, 0, 0]],</span>
<span class="go">       [[0, 0, 0],</span>
<span class="go">        [0, 0, 0],</span>
<span class="go">        [0, 0, 0]]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_morse_force">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_morse_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">L</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_morse_force"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_morse_force" title="Link to this definition"></a></dt>
<dd><p>Computes the Morse force for a given set of distances.</p>
<p>The Morse potential is used to model the interaction between a pair of atoms or molecules, capturing both
the attractive and repulsive forces more realistically than the Lennard-Jones potential. This function calculates
the Morse force based on the provided distances, interaction strength, characteristic distance, and interaction range.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The distance(s) at which to calculate the Morse force. Can be a single float or an array of distances.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The depth of the potential well, representing the strength of the interaction.</p></li>
<li><p><strong>R</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The equilibrium distance where the potential reaches its minimum. Default is 1.</p></li>
<li><p><strong>L</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The width of the potential well, determining the range of the interaction. A larger value of <cite>L</cite>
indicates a narrower well, meaning the potential changes more rapidly with distance. Default is 4.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>force</strong> – The computed Morse force at each distance provided in <cite>r</cite>. The shape of the output matches the shape of <cite>r</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.8</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interaction_strength</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">equilibrium_distance</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interaction_range</span> <span class="o">=</span> <span class="mf">4.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">forces</span> <span class="o">=</span> <span class="n">get_morse_force</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">interaction_strength</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">equilibrium_distance</span><span class="p">,</span> <span class="n">L</span><span class="o">=</span><span class="n">interaction_range</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">forces</span><span class="p">)</span>
<span class="go">[ 1.17328042  0.         -0.63212056]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The Morse force is derived from the Morse potential and is calculated using the formula:
<cite>force = eps * [exp(-2 * (r - R) / L) - exp(-(r - R) / L)]</cite>,
where <cite>eps</cite> is the interaction strength, <cite>R</cite> is the equilibrium distance, and <cite>L</cite> is the interaction range.</p></li>
<li><p>This function can handle both scalar and array inputs for <cite>r</cite>.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_nuc_displacement">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_nuc_displacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_pts_new</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Rset</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nuc_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([1])</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">nuc_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_nuc_displacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_nuc_displacement" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_ot_displacement">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_ot_displacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_dict_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">parent_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_ot_displacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_ot_displacement" title="Link to this definition"></a></dt>
<dd><p>Computes the optimal transport (OT) displacement between two sets of boundary points.</p>
<p>This function calculates the optimal transport displacements between the points in the current
boundary (<cite>border_dict</cite>) and the points in the previous boundary (<cite>border_dict_prev</cite>). It finds
the optimal matches and computes the displacement vectors for each point.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing the current boundary points and related information. Expected keys include:
- ‘index’: ndarray of shape (N,), unique labels of current boundary points.
- ‘pts’: ndarray of shape (N, D), coordinates of the current boundary points.</p></li>
<li><p><strong>border_dict_prev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing the previous boundary points and related information. Expected keys include:
- ‘index’: ndarray of shape (M,), unique labels of previous boundary points.
- ‘pts’: ndarray of shape (M, D), coordinates of the previous boundary points.</p></li>
<li><p><strong>parent_index</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array of unique labels (indices) to use for matching previous boundary points. If not provided,
<cite>index1</cite> from <cite>border_dict</cite> will be used to match with <cite>border_dict_prev</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>inds_ot</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 1D array containing the indices of the optimal transport matches for the current boundary points
from the previous boundary points.</p></li>
<li><p><strong>dxs_ot</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array of shape (N, D), representing the displacement vectors from the current boundary points
to the matched previous boundary points.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses the <cite>get_ot_dx</cite> function to compute the optimal transport match and displacement
between boundary points.</p></li>
<li><p>If <cite>parent_index</cite> is not provided, it defaults to using the indices of the current boundary points
(<cite>index1</cite>).</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;pts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict_prev</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;index&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]),</span>
<span class="gp">... </span>    <span class="s1">&#39;pts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds_ot</span><span class="p">,</span> <span class="n">dxs_ot</span> <span class="o">=</span> <span class="n">get_ot_displacement</span><span class="p">(</span><span class="n">border_dict</span><span class="p">,</span> <span class="n">border_dict_prev</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds_ot</span>
<span class="go">array([0, 0, 0])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dxs_ot</span>
<span class="go">array([[ 0, -1],</span>
<span class="go">       [ 0,  1],</span>
<span class="go">       [ 0,  1]])</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_ot_dx">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_ot_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">pts0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_cost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_ot_dx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_ot_dx" title="Link to this definition"></a></dt>
<dd><p>Computes the optimal transport (OT) displacement and cost between two sets of points.</p>
<p>This function calculates the optimal transport map between two sets of points <cite>pts0</cite> and <cite>pts1</cite> using the
Earth Mover’s Distance (EMD). It returns the indices of the optimal transport matches and the displacement
vectors, as well as the transport cost if specified.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>pts0</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array of shape (N, D), representing the first set of points, where N is the number of points
and D is the dimensionality.</p></li>
<li><p><strong>pts1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array of shape (M, D), representing the second set of points, where M is the number of points
and D is the dimensionality.</p></li>
<li><p><strong>return_dx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns the displacement vectors between matched points (default is True).</p></li>
<li><p><strong>return_cost</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns the total transport cost (default is False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>inds_ot</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 1D array of shape (N,), representing the indices of the points in <cite>pts1</cite> that are matched to
the points in <cite>pts0</cite> according to the optimal transport map.</p></li>
<li><p><strong>dx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A 2D array of shape (N, D), representing the displacement vectors from the points in <cite>pts0</cite> to the
matched points in <cite>pts1</cite>. Returned only if <cite>return_dx</cite> is True.</p></li>
<li><p><strong>cost</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The total optimal transport cost, calculated as the sum of the transport cost between matched points.
Returned only if <cite>return_cost</cite> is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses the Earth Mover’s Distance (EMD) for computing the optimal transport map, which minimizes
the cost of moving mass from <cite>pts0</cite> to <cite>pts1</cite>.</p></li>
<li><p>The cost is computed as the sum of the pairwise distances weighted by the transport plan.</p></li>
<li><p>Displacement vectors are computed as the difference between points in <cite>pts0</cite> and their matched points in <cite>pts1</cite>.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">pts0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">pts1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds_ot</span><span class="p">,</span> <span class="n">dx</span><span class="p">,</span> <span class="n">cost</span> <span class="o">=</span> <span class="n">get_ot_dx</span><span class="p">(</span><span class="n">pts0</span><span class="p">,</span> <span class="n">pts1</span><span class="p">,</span> <span class="n">return_dx</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_cost</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">inds_ot</span>
<span class="go">array([0, 1, 2])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span>
<span class="go">array([[ 0, -1],</span>
<span class="go">       [ 0,  1],</span>
<span class="go">       [ 0,  1]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cost</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_secreted_ligand_density">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_secreted_ligand_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indz_bm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">secretion_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">micron_per_pixel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_secreted_ligand_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_secreted_ligand_density" title="Link to this definition"></a></dt>
<dd><p>Calculate the spatial distribution of secreted ligand density in a 3D tissue model.</p>
<p>This function simulates the diffusion and absorption of secreted ligands in a 3D volume defined by a binary mask.
It uses finite element methods to solve the diffusion equation for ligand concentration, taking into account secretion
from cell surfaces and absorption at boundaries.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 3D binary mask representing the tissue, where non-zero values indicate the presence of cells.</p></li>
<li><p><strong>scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The scaling factor for spatial resolution in the x and y dimensions. Default is 2.</p></li>
<li><p><strong>zscale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The scaling factor for spatial resolution in the z dimension. Default is 1.</p></li>
<li><p><strong>npad</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of pixels to pad the mask in each dimension. Default is None, implying no padding.</p></li>
<li><p><strong>indz_bm</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The index for the basal membrane in the z-dimension, where diffusion starts. Default is 0.</p></li>
<li><p><strong>secretion_rate</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – The rate of ligand secretion from the cell surfaces. Can be a scalar or array for different cell types. Default is 1.0.</p></li>
<li><p><strong>D</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The diffusion coefficient for the ligand. If None, it is set to a default value based on the pixel size. Default is None.</p></li>
<li><p><strong>micron_per_pixel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The conversion factor from pixels to microns. Default is 1.</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, generates visualizations of the cell borders and diffusion process. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vdist</strong> – A 3D array representing the steady-state concentration of the secreted ligand in the tissue volume.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">tissue_mask</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">50</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ligand_density</span> <span class="o">=</span> <span class="n">get_secreted_ligand_density</span><span class="p">(</span><span class="n">tissue_mask</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">2.5</span><span class="p">,</span> <span class="n">zscale</span><span class="o">=</span><span class="mf">1.2</span><span class="p">,</span> <span class="n">secretion_rate</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">ligand_density</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(100, 100, 50)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function uses <cite>fipy</cite> for solving the diffusion equation and <cite>skimage.segmentation.find_boundaries</cite> for
identifying cell borders.</p></li>
<li><p>The function includes various options for handling different boundary conditions, cell shapes, and secretion rates.</p></li>
</ul>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_surface_displacement">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_surface_displacement</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_surface_displacement"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_surface_displacement" title="Link to this definition"></a></dt>
<dd><p>Computes the surface displacement of cells based on their curvature and normal vectors.</p>
<p>This function calculates the displacement of cell surfaces using the curvature values and normal vectors.
The displacement can be scaled by a factor <cite>alpha</cite>, and optionally constrained by a maximum displacement value.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing information about the cell borders, including:
- ‘n’: ndarray of shape (N, 3), normal vectors at the border points.
- ‘c’: ndarray of shape (N,), curvature values at the border points.
- ‘states’: ndarray of shape (N,), states of the border points.</p></li>
<li><p><strong>sts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array of scaling factors for each state, used to modify the curvature. If provided, <cite>sts</cite> is multiplied
with the curvature values based on the state of each border point (default is None, meaning no scaling is applied).</p></li>
<li><p><strong>c</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Curvature values at the border points. If None, it uses the curvature from <cite>border_dict</cite> (default is None).</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Normal vectors at the border points. If None, it uses the normal vectors from <cite>border_dict</cite> (default is None).</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A scaling factor for the displacement magnitude (default is 1.0).</p></li>
<li><p><strong>maxd</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The maximum allowed displacement. If specified, the displacement is scaled to ensure it does not exceed this value.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dx</strong> – A 2D array of shape (N, 3) representing the displacements of the border points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The displacement is calculated as a product of curvature, normal vectors, and the scaling factor <cite>alpha</cite>.</p></li>
<li><p>If <cite>sts</cite> is provided, curvature values are scaled according to the states of the border points.</p></li>
<li><p>Displacement magnitude is capped by <cite>maxd</cite> if specified, ensuring that no displacement exceeds this value.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;n&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;c&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="n">get_surface_displacement</span><span class="p">(</span><span class="n">border_dict</span><span class="p">,</span> <span class="n">sts</span><span class="o">=</span><span class="n">sts</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">maxd</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_surface_displacement_deviation">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_surface_displacement_deviation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_dict</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_pts_prev</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_eigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">alpha</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_surface_displacement_deviation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_surface_displacement_deviation" title="Link to this definition"></a></dt>
<dd><p>Calculates the surface displacement deviation using optimal transport between current and previous border points.</p>
<p>This function computes the displacement of cell surface points based on deviations from previous positions.
The displacement can be modified by normal vectors, filtered by specific states, and controlled by curvature
or variance in displacement.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_dict</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – A dictionary containing information about the current cell borders, including:
- ‘pts’: ndarray of shape (N, 3), current border points.
- ‘states’: ndarray of shape (N,), states of the border points.</p></li>
<li><p><strong>border_pts_prev</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array of shape (N, 3) containing the positions of border points from the previous time step.</p></li>
<li><p><strong>exclude_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – A list or array of states to exclude from displacement calculations (default is None, meaning no states are excluded).</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Normal vectors at the border points. If None, normal vectors are calculated based on the optimal transport displacement (default is None).</p></li>
<li><p><strong>knn</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of nearest neighbors to consider when computing variance or eigen decomposition for curvature calculations (default is 12).</p></li>
<li><p><strong>use_eigs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, use eigen decomposition to calculate the displacement deviation; otherwise, use variance (default is False).</p></li>
<li><p><strong>alpha</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A scaling factor for the displacement magnitude (default is 1.0).</p></li>
<li><p><strong>maxd</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The maximum allowed displacement. If specified, the displacement is scaled to ensure it does not exceed this value (default is None).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dx</strong> – A 2D array of shape (N, 3) representing the displacements of the border points.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses optimal transport to calculate deviations between current and previous border points.</p></li>
<li><p>The surface displacement deviation is inspired by the “mother of all non-linearities”– the Kardar-Parisi-Zhang non-linear surface growth universality class.</p></li>
<li><p>Displacement deviations are scaled by the normal vectors and can be controlled by <cite>alpha</cite> and capped by <cite>maxd</cite>.</p></li>
<li><p>If <cite>use_eigs</cite> is True, eigen decomposition of the displacement field is used to calculate deviations, otherwise variance is used.</p></li>
<li><p>Excludes displacements for specified states, if <cite>exclude_states</cite> is provided.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_dict</span> <span class="o">=</span> <span class="p">{</span>
<span class="gp">... </span>    <span class="s1">&#39;pts&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>
<span class="gp">... </span>    <span class="s1">&#39;states&#39;</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span>
<span class="gp">... </span><span class="p">}</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts_prev</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span> <span class="o">=</span> <span class="n">get_surface_displacement_deviation</span><span class="p">(</span><span class="n">border_dict</span><span class="p">,</span> <span class="n">border_pts_prev</span><span class="p">,</span> <span class="n">exclude_states</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">maxd</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">dx</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(100, 3)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_surface_gradvariance">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_surface_gradvariance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx_ot</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_eigs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_surface_gradvariance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_surface_gradvariance" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_surface_points">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_surface_points</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_normals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_curvature</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">knn</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_surface_points"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_surface_points" title="Link to this definition"></a></dt>
<dd><p>Computes the surface points of a labeled mask and optionally calculates normals and curvature.</p>
<p>This function identifies the surface (border) points of a given labeled mask using segmentation techniques.
It can also compute normals (perpendicular vectors to the surface) and curvature values at these points if requested.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>msk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 3D binary or labeled array representing the mask of regions of interest. Non-zero values represent the regions.</p></li>
<li><p><strong>return_normals</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, computes and returns the normals at each surface point (default is False).</p></li>
<li><p><strong>return_curvature</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, computes and returns the curvature at each surface point (default is False).</p></li>
<li><p><strong>knn</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of nearest neighbors to consider when calculating normals and curvature (default is 20).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>border_pts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A 2D array of shape (N, 3) containing the coordinates of the border points, where N is the number of border points found.</p></li>
<li><p><strong>n</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A 2D array of shape (N, 3) containing the normal vectors at each border point. Only returned if <cite>return_normals</cite> is True.</p></li>
<li><p><strong>c</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A 1D array of length N containing the curvature values at each border point. Only returned if <cite>return_curvature</cite> is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function uses eigen decomposition on the neighborhood of each surface point to compute normals and curvature.</p></li>
<li><p>The normals are adjusted to face outward from the surface. If normals face inward, they are flipped.</p></li>
<li><p>Curvature is calculated as the ratio of the smallest eigenvalue to the sum of all eigenvalues, giving an estimate of local surface bending.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">msk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">msk</span><span class="p">[</span><span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">,</span> <span class="mi">40</span><span class="p">:</span><span class="mi">60</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># A cube in the center</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts</span> <span class="o">=</span> <span class="n">get_surface_points</span><span class="p">(</span><span class="n">msk</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(960, 3)</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts</span><span class="p">,</span> <span class="n">normals</span> <span class="o">=</span> <span class="n">get_surface_points</span><span class="p">(</span><span class="n">msk</span><span class="p">,</span> <span class="n">return_normals</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">normals</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((960, 3), (960, 3))</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts</span><span class="p">,</span> <span class="n">normals</span><span class="p">,</span> <span class="n">curvature</span> <span class="o">=</span> <span class="n">get_surface_points</span><span class="p">(</span><span class="n">msk</span><span class="p">,</span> <span class="n">return_normals</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">return_curvature</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">normals</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">curvature</span><span class="o">.</span><span class="n">shape</span>
<span class="go">((960, 3), (960, 3), (960,))</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_volconstraint_com">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_volconstraint_com</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">border_pts</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_volume</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_iter</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">converror</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_volconstraint_com"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_volconstraint_com" title="Link to this definition"></a></dt>
<dd><p>Adjusts the positions of boundary points to achieve a target volume using a centroid-based method.</p>
<p>This function iteratively adjusts the positions of boundary points to match a specified target volume.
The adjustment is done by moving points along the direction from the centroid to the points, scaled
by the difference between the current and target volumes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>border_pts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of shape (N, 3) representing the coordinates of the boundary points.</p></li>
<li><p><strong>target_volume</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The desired volume to be achieved.</p></li>
<li><p><strong>max_iter</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Maximum number of iterations to perform. Default is 1000.</p></li>
<li><p><strong>converror</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Convergence error threshold. Iterations stop when the relative volume error is below this value.
Default is 0.05.</p></li>
<li><p><strong>dc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – A scaling factor for the displacement calculated in each iteration. Default is 1.0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>border_pts</strong> – An array of shape (N, 3) representing the adjusted coordinates of the boundary points that
approximate the target volume.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method assumes a 3D convex hull can be formed by the points, which is adjusted iteratively.</p></li>
<li><p>The convergence is based on the relative difference between the current volume and the target volume.</p></li>
<li><p>If the boundary points are collinear in any dimension, the method adjusts them to ensure a valid convex hull.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_pts</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">target_volume</span> <span class="o">=</span> <span class="mf">10.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">adjusted_pts</span> <span class="o">=</span> <span class="n">get_volconstraint_com</span><span class="p">(</span><span class="n">border_pts</span><span class="p">,</span> <span class="n">target_volume</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">adjusted_pts</span><span class="p">)</span>
<span class="go">array([[ ... ]])  # Adjusted coordinates to approximate the target volume</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.spatial.get_yukawa_force">
<span class="sig-prename descclassname"><span class="pre">celltraj.spatial.</span></span><span class="sig-name descname"><span class="pre">get_yukawa_force</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/spatial.html#get_yukawa_force"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.spatial.get_yukawa_force" title="Link to this definition"></a></dt>
<dd><p>Computes the Yukawa force for a given set of distances.</p>
<p>The Yukawa force is a screened Coulomb force often used to describe interactions
in plasmas and other systems with screened potentials. This function calculates
the Yukawa force based on the provided distances, interaction strength, and screening length.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>r</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The distance(s) at which to calculate the Yukawa force. Can be a single float
or an array of distances.</p></li>
<li><p><strong>eps</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – The interaction strength (or potential strength) parameter, determining the amplitude
of the force.</p></li>
<li><p><strong>R</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The screening length parameter, which determines how quickly the force decays
with distance. Default is 1.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>force</strong> – The computed Yukawa force at each distance provided in <cite>r</cite>. The shape of the output
matches the shape of <cite>r</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">distances</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">interaction_strength</span> <span class="o">=</span> <span class="mf">2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">screening_length</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">forces</span> <span class="o">=</span> <span class="n">get_yukawa_force</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">interaction_strength</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">screening_length</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">forces</span><span class="p">)</span>
<span class="go">[4. e+00 1.47151776e+00 4.48168907e-01]</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The Yukawa force is computed using the formula:
<cite>force = eps * exp(-r / R) * (r + R) / (R * r^2)</cite>,
where <cite>eps</cite> is the interaction strength and <cite>R</cite> is the screening length.</p></li>
<li><p>The function handles both scalar and array inputs for <cite>r</cite>.</p></li>
</ul>
</dd></dl>

</section>
<section id="module-celltraj.trajectory">
<span id="celltraj-trajectory-module"></span><h2>celltraj.trajectory module<a class="headerlink" href="#module-celltraj.trajectory" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">celltraj.trajectory.</span></span><span class="sig-name descname"><span class="pre">Trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h5filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A toolset for single-cell trajectory modeling. See:</p>
<p class="rubric">References</p>
<p>Copperman, Jeremy, Sean M. Gross, Young Hwan Chang, Laura M. Heiser, and Daniel M. Zuckerman.
“Morphodynamical cell state description via live-cell imaging trajectory embedding.”
Communications Biology 6, no. 1 (2023): 484.</p>
<p>Copperman, Jeremy, Ian C. Mclean, Sean M. Gross, Young Hwan Chang, Daniel M. Zuckerman, and Laura M. Heiser.
“Single-cell morphodynamical trajectories enable prediction of gene expression accompanying cell state change.”
bioRxiv (2024): 2024-01.</p>
<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h5filename</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.__init__" title="Link to this definition"></a></dt>
<dd><p>Initializes a Trajectory object, optionally loading metadata and additional data from an HDF5 file.</p>
<p>This constructor sets the HDF5 filename and attempts to load metadata associated with the file.
If the file is present, it reads the metadata from a predefined group. If <cite>data_list</cite> is provided,
it will also attempt to load additional data specified in the list from the HDF5 file. Errors during
metadata or data loading are caught and logged. Future updates should include better commenting and
organizational improvements of class attributes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>h5filename</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – The path to the HDF5 file from which to load the metadata. If not provided, the
instance will be initialized without loading metadata.</p></li>
<li><p><strong>data_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – A list of data group paths within the HDF5 file to be loaded along with the metadata. Each
entry in the list should specify a path to a dataset or group within the HDF5 file that
contains data relevant to the trajectory analysis.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>TODO:
- Improve documentation of class attributes.
- Reorganize attributes into a more meaningful structure.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="go">loading path/to/your/hdf5file.h5</span>
</pre></div>
</div>
<p>If an HDF5 file and data list are provided:
&gt;&gt;&gt; data_groups = [‘/group1/data’, ‘/group2/data’]
&gt;&gt;&gt; traj = Trajectory(‘path/to/your/hdf5file.h5’, data_list=data_groups)
loading path/to/your/hdf5file.h5</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_Xtraj_celltrajectory">
<span class="sig-name descname"><span class="pre">get_Xtraj_celltrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xtraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_Xtraj_celltrajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_Xtraj_celltrajectory" title="Link to this definition"></a></dt>
<dd><p>Retrieves trajectory segments for a specific cell trajectory from a larger set of trajectory data.
This method matches segments of the cell trajectory with those in a pre-computed set of trajectories
and extracts the corresponding features or data points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_traj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array containing indices of a cell’s trajectory over time.</p></li>
<li><p><strong>Xtraj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The trajectory feature matrix from which to extract data. If not provided, the method uses
the instance’s attribute <cite>Xtraj</cite>.</p></li>
<li><p><strong>traj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – A matrix of precomputed trajectories used for matching against <cite>cell_traj</cite>. If not provided,
the method uses the instance’s attribute <cite>traj</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>xt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A subset of <cite>Xtraj</cite> corresponding to the segments of <cite>cell_traj</cite> that match segments in <cite>traj</cite>.</p></li>
<li><p><strong>inds_traj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Indices within <cite>traj</cite> where matches were found, indicating which rows in <cite>Xtraj</cite> were selected.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If the length of <cite>cell_traj</cite> is less than the length used for trajectories in <cite>traj</cite> (<cite>trajl</cite>),
    making it impossible to match any trajectory segments.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">get_unique_trajectories</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cell_trajectory</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_trajectory</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">features</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_Xtraj_celltrajectory</span><span class="p">(</span><span class="n">cell_trajectory</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method requires <cite>trajl</cite>, the length of the trajectory segments, to be set either as a class</p></li>
</ul>
<p>attribute or passed explicitly. This length determines how the segments are compared for matching.
- This function is particularly useful for analyzing time-series data or features extracted from
trajectories, allowing for detailed analysis specific to a single cell’s path through time.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_alpha">
<span class="sig-name descname"><span class="pre">get_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_alpha" title="Link to this definition"></a></dt>
<dd><p>Calculates the alignment measure, alpha, between two cells identified by their indices. This
measure reflects how the movement direction of one cell relates to the direction of the vector
connecting the two cells, essentially quantifying the relative motion along the axis of separation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Index of the first cell.</p></li>
<li><p><strong>i2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Index of the second cell.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>alpha</strong> – The alignment measure between the two cells. This value ranges from -1 to 1, where 1 indicates
that the cells are moving directly towards each other, -1 indicates they are moving directly
away from each other, and 0 indicates orthogonal movement directions. Returns NaN if the calculation
fails (e.g., due to division by zero when normalizing zero-length vectors).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Exception</strong> – If an error occurs during the trajectory retrieval or normalization process, likely due to missing
    data or incorrect indices.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">alignment</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_alpha</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="go"># This computes the alignment measure between cells at index 10 and 15 based on their last movements.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function computes the movement vectors of both cells from their previous positions in their</p></li>
</ul>
<p>respective trajectories and uses these vectors to determine their alignment relative to the vector
connecting the two cells at their current positions.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_beta">
<span class="sig-name descname"><span class="pre">get_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_beta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_beta" title="Link to this definition"></a></dt>
<dd><p>Calculates the cosine of the angle (beta) between the movement directions of two cells. This measure
quantifies the directional similarity or alignment between two moving cells, with values ranging
from -1 to 1.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>i1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Index of the first cell.</p></li>
<li><p><strong>i2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Index of the second cell.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>beta</strong> – The cosine of the angle between the movement vectors of the two cells, indicating their
directional alignment. A value of 1 means the cells are moving in exactly the same direction,
-1 means they are moving in exactly opposite directions, and 0 indicates orthogonal movement
directions. Returns NaN if the calculation fails, typically due to a division by zero when
attempting to normalize zero-length vectors.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Exception</strong> – If an error occurs during the trajectory retrieval or normalization process, likely due to missing
    data or incorrect indices.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alignment</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_beta</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">)</span>
<span class="go"># This computes the directional alignment between cells at index 10 and 15 based on their last movements.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function calculates movement vectors for both cells from their positions at the last two time points</p></li>
</ul>
<p>in their trajectories. It then computes the cosine of the angle between these vectors as the beta value,
providing an indication of how parallel their movements are.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_border_properties_dict">
<span class="sig-name descname"><span class="pre">get_border_properties_dict</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iS</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">secretion_rates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surfaces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_fmask_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_states_baseid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">add_label0_surf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">make_cells_and_surfaces_disjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vdist_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">z_viz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_border_properties_dict"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_border_properties_dict" title="Link to this definition"></a></dt>
<dd><p>Calculate border properties for cells and surfaces at a given frame in a trajectory.</p>
<p>This function extracts data required to characterize the borders of cells within a specified
frame (<cite>iS</cite>) in a 3D or 2D cell image sequence. The borders are characterized based on geometric
and physical properties, with optional visualization and multipole moment expansion up to the
specified <cite>order</cite>. Supports the inclusion of surface contacts, tracking cell borders over time,
and calculating secreted ligand distributions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iS</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Frame index within the trajectory for which to calculate border properties.</p></li>
<li><p><strong>cell_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of states for each cell in the current frame. If not provided, all cells are assigned
state 1 by default.</p></li>
<li><p><strong>secretion_rates</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of secretion rates for each cell, used to calculate secreted ligand distribution
along cell borders. If not provided, no secretion is considered.</p></li>
<li><p><strong>surfaces</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarrays</span></code>, <em>optional</em>) – List of binary masks for surfaces adjacent to cells (e.g., membranes or other boundaries).
Surfaces are optionally assigned states via <cite>surface_fmask_channels</cite>.</p></li>
<li><p><strong>surface_fmask_channels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – List of channels in the frame data specifying each surface’s mask. Used if <cite>surfaces</cite> is
None. Each channel mask is assigned a state from <cite>surface_states_baseid</cite> onward.</p></li>
<li><p><strong>surface_states_baseid</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Base state ID for assigning states to surfaces. Defaults to 1000.</p></li>
<li><p><strong>add_label0_surf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, includes cells labeled as 0 (background) as a surface layer. Default is True.</p></li>
<li><p><strong>make_cells_and_surfaces_disjoint</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, cells and surfaces are treated as mutually exclusive regions. Default is True.</p></li>
<li><p><strong>border_scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Scale for border calculations. If None, it defaults to the <cite>border_resolution</cite> attribute
if available.</p></li>
<li><p><strong>border_resolution</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Resolution of the border calculations in units of pixels. If None, the value from the
object’s <cite>border_resolution</cite> attribute is used if present.</p></li>
<li><p><strong>vdist_scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Scale factor for calculating the secreted ligand distribution. Default is 0.3.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Radius for identifying contact neighbors when calculating border properties. Default is 2.0.</p></li>
<li><p><strong>order</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Order of multipole moments to compute for cell border properties. Default is 1.</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, generates a visualization of the borders, including displacements from the
previous and next frames.</p></li>
<li><p><strong>z_viz</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Specific z-plane to visualize in 3D data. If None, a central z-plane is chosen.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>border_dict</strong> – Dictionary containing computed properties for cell borders, including:</p>
<ul class="simple">
<li><p><cite>pts</cite>: Coordinates of each border point.</p></li>
<li><p><cite>index</cite>: Cell IDs associated with each border point.</p></li>
<li><p><cite>nn_states</cite>: States of neighboring cells at each border point.</p></li>
<li><p><cite>c</cite>: Curvature at each border point.</p></li>
<li><p><cite>global_index</cite>: Global indices for each border point in the dataset.</p></li>
<li><p><cite>border_dx_prev</cite>, <cite>border_dx_next</cite>: Displacement vectors for borders to previous and</p></li>
</ul>
<p>next frames, if applicable.
- <cite>contact_properties</cite>: Multipole moment properties based on cell-state contacts.
- <cite>vdist</cite>: Secreted ligand density distribution, if <cite>secretion_rates</cite> is provided.</p>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p><strong>Tracking</strong>: If previous (<cite>cell_labels_prev</cite>) or next frame (<cite>cell_labels_next</cite>) is provided,</p></li>
</ul>
<p>the function calculates the optimal transport vector between consecutive frames for each cell.
- <strong>Surface Assignment</strong>: When <cite>surface_fmask_channels</cite> is provided, each channel is used to
define a distinct surface mask, and <cite>surface_states</cite> are assigned based on <cite>surface_states_baseid</cite>.
- <strong>Multipole Moments</strong>: Higher-order moments are calculated based on border charges determined
from neighboring cell states.</p>
<p class="rubric">Examples</p>
<p>Compute border properties for frame 10 with secreted ligand distribution and visualize:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">border_properties</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_border_properties_dict</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">iS</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">cell_states</span><span class="o">=</span><span class="n">my_cell_states</span><span class="p">,</span> <span class="n">secretion_rates</span><span class="o">=</span><span class="n">my_secretion_rates</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">surface_fmask_channels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">border_resolution</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span> <span class="n">vdist_scale</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">visual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">z_viz</span><span class="o">=</span><span class="mi">15</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_blocks">
<span class="sig-name descname"><span class="pre">get_cell_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">label</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_label_ids</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_blocks" title="Link to this definition"></a></dt>
<dd><p>Extracts bounding box information for each cell from a labeled mask image. This function
returns the minimum and maximum indices for each labeled cell, useful for operations such
as cropping around a cell or analyzing specific cell regions. The function supports both
2D and 3D labeled images.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>label</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A labeled image array where each unique non-zero integer represents a unique cell.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>cellblocks</strong> – An array containing the bounding boxes for each cell. The array has shape
(number_of_labels, number_of_dimensions, 2), where each cell’s bounding box is
represented by [min_dim1, min_dim2, …, max_dim1, max_dim2, …].</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">label_image</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blocks</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_blocks</span><span class="p">(</span><span class="n">label_image</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">blocks</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(2, 2, 2)  # Example output shape for a 2D label image with two labels.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_channel_crosscorr">
<span class="sig-name descname"><span class="pre">get_cell_channel_crosscorr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgchannel1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgchannel2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_channel_crosscorr"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_channel_crosscorr" title="Link to this definition"></a></dt>
<dd><p>Computes the cross-correlation between two image channels within labeled cells, using masks defined by a specific mask channel. This method is particularly useful for analyzing the relationship between different signal channels at a cellular level.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indcells</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Indices of cells for which to calculate cross-correlations. If None, calculations are performed for all indexed cells.</p></li>
<li><p><strong>mskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Mask channel used to define cellular regions.</p></li>
<li><p><strong>imgchannel1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – First image channel for correlation analysis.</p></li>
<li><p><strong>imgchannel2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Second image channel for correlation analysis.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the calculated cross-correlations to an HDF5 file under the specified directory and file names.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and save_h5 is True, existing data in the HDF5 file will be overwritten.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>corrc</strong> – Array of cross-correlation coefficients for each cell. The length of the array corresponds to the number of cells specified by <cite>indcells</cite>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If required parameters are not set or if no cell index is available, prompting the user to set necessary parameters or perform required prior steps.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">corrc</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_channel_crosscorr</span><span class="p">(</span><span class="n">indcells</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">mskchannel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">imgchannel1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">imgchannel2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_children">
<span class="sig-name descname"><span class="pre">get_cell_children</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">icell</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_children"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_children" title="Link to this definition"></a></dt>
<dd><p>Get the child cells for a given cell in the next frame.</p>
<p>This function identifies the child cells of a given parent cell <cite>icell</cite> by tracking the lineage data
across consecutive frames. The lineage is determined from the parent cell’s index and the lineage set
for the next frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>icell</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The index of the cell for which to find the children.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ind_children</strong> – An array of indices representing the child cells of the given cell <cite>icell</cite> in the next frame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function looks at the current frame of <cite>icell</cite> and identifies its child cells in the subsequent frame</p></li>
</ul>
<p>using the lineage tracking set (<cite>linSet</cite>).
- This method assumes that the lineage set (<cite>linSet</cite>) and cell indexing (<cite>cells_indimgSet</cite>, <cite>cells_indSet</cite>)
are properly initialized and populated.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell_index</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">children</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cell_children</span><span class="p">(</span><span class="n">cell_index</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Children of cell </span><span class="si">{</span><span class="n">cell_index</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">children</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_compartment_ratio">
<span class="sig-name descname"><span class="pre">get_cell_compartment_ratio</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskchannel1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskchannel2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmask_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">make_disjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">remove_background_perframe</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmask_channel_background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">background_percentile</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">erosion_footprint1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">erosion_footprint2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">combined_and_disjoint</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_sum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">intensity_ztransform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">noratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inverse_ratio</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_compartment_ratio"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_compartment_ratio" title="Link to this definition"></a></dt>
<dd><p>Calculates the ratio of features between two cellular compartments, optionally adjusted for image
intensity and morphology transformations. This method allows for complex comparisons between different
mask channels or modified versions of these channels to derive cellular compartment ratios.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indcells</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Indices of cells for which to calculate the feature ratios.</p></li>
<li><p><strong>imgchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Index of the image channel used for intensity measurements.</p></li>
<li><p><strong>mskchannel1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Mask channel index for the numerator in the ratio calculation.</p></li>
<li><p><strong>mskchannel2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Mask channel index for the denominator in the ratio calculation. Overlaps with mskchannel1 are removed.</p></li>
<li><p><strong>fmask_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Mask channel index used to adjust mskchannel2 if no separate mskchannel2 is provided.</p></li>
<li><p><strong>make_disjoint</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, ensures that masks from mskchannel1 and mskchannel2 do not overlap by adjusting mskchannel1.</p></li>
<li><p><strong>erosion_footprint1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Erosion footprint for the first mask, modifies the mask by eroding it before calculations.</p></li>
<li><p><strong>erosion_footprint2</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Erosion footprint for the second mask, modifies the mask by eroding it before calculations.</p></li>
<li><p><strong>combined_and_disjoint</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, combines and then separates the masks to only include disjoint areas in calculations.</p></li>
<li><p><strong>intensity_sum</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, sums the intensity over the area rather than averaging it, before ratio calculation.</p></li>
<li><p><strong>intensity_ztransform</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, applies a z-transformation based on standard deviations and means stored in the object.</p></li>
<li><p><strong>noratio</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns only the numerator intensity mean without forming a ratio.</p></li>
<li><p><strong>inverse_ratio</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, calculates the inverse of the normal ratio.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the calculated ratios to an HDF5 file.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and save_h5 is also True, overwrites existing data in the HDF5 file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>cratio</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of calculated compartment ratios for each specified cell.</p></li>
<li><p><strong>feature_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Descriptions of the cell features, returned if <cite>return_feature_list</cite> is set to True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cratio</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_compartment_ratio</span><span class="p">(</span><span class="n">indcells</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span> <span class="n">imgchannel</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mskchannel1</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mskchannel2</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_data">
<span class="sig-name descname"><span class="pre">get_cell_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">frametype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'boundingbox'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_expansion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_masks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relabel_masks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">relabel_mskchannels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">delete_background</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_data" title="Link to this definition"></a></dt>
<dd><p>Retrieves image and mask data for specific cells based on various configuration options.
This method can extract data for single cells, their neighborhoods, or connected cell groups,
and offers options to expand the extraction region, relabel masks, and more.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ic</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Cell ID(s) for which to retrieve data. Can specify a single cell or a list of cells.</p></li>
<li><p><strong>frametype</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Type of frame data to retrieve; options include ‘boundingbox’, ‘neighborhood’, or ‘connected’.
Default is ‘boundingbox’.</p></li>
<li><p><strong>boundary_expansion</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Array specifying how much to expand the bounding box around the cell in each dimension.</p></li>
<li><p><strong>return_masks</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to return the mask data along with the image data. Default is True.</p></li>
<li><p><strong>relabel_masks</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to relabel mask data with movie cell indices. Default is True.</p></li>
<li><p><strong>relabel_mskchannels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code>, <em>optional</em>) – Specifies the mask channels to relabel. If not set, uses the default mask channel.</p></li>
<li><p><strong>delete_background</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If set to True, sets label and image pixels outside the specified cell set to zero. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>imgc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The image data for the specified cell(s) as a NumPy array.</p></li>
<li><p><strong>mskc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The mask data for the specified cell(s) as a NumPy array, returned if <cite>return_masks</cite> is True.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If cells from multiple frames are requested or necessary attributes are not set.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">img_data</span><span class="p">,</span> <span class="n">mask_data</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_data</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="n">frametype</span><span class="o">=</span><span class="s1">&#39;boundingbox&#39;</span><span class="p">,</span> <span class="n">boundary_expansion</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">return_masks</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_features">
<span class="sig-name descname"><span class="pre">get_cell_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">function_tuple</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">imgchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_fmask_for_intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmskchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_mask_for_intensity_image</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">apply_contact_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">preprocess_functions</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_feature_list</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">concatenate_features</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_features"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_features" title="Link to this definition"></a></dt>
<dd><p>Extracts complex cell features based on the specified custom functions and imaging data.
This method allows customization of the feature extraction process using region properties
from segmented cell data, with optional transformations like border erosion or contact
transformations. Features can be based on intensity images, mask data, or specific
transformations of these data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>function_tuple</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">callable</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">callables</span></code>) – Function(s) that take a mask and an intensity image as input and return a scalar
or array of features. These functions must be compatible with skimage’s regionprops.</p></li>
<li><p><strong>indcells</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Array of cell indices for which to calculate features. If None, calculates for all cells.</p></li>
<li><p><strong>imgchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Index of the image channel used for intensity image feature calculation.</p></li>
<li><p><strong>mskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Index of the mask channel used for single-cell label feature calculation.</p></li>
<li><p><strong>use_fmask_for_intensity_image</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, uses foreground mask data for intensity images.</p></li>
<li><p><strong>fmskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Channel index for foreground mask data if used for intensity image.</p></li>
<li><p><strong>use_mask_for_intensity_image</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, uses mask data instead of image data for intensity measurements.</p></li>
<li><p><strong>bordersize</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Pixel size for erosion of the foreground mask or growth radius for contact boundaries.</p></li>
<li><p><strong>apply_contact_transform</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, applies a contact transform to generate segmentation contacts from the mask data.</p></li>
<li><p><strong>return_feature_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, returns a list of strings describing the calculated features.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the features and their descriptions to an HDF5 file.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and save_h5 is also True, overwrites existing data in the HDF5 file.</p></li>
<li><p><strong>concatenate_features</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, adds the newly calculated features to existing features in the dataset.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Xf</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Array of features indexed by cells. The shape is (number of cells, number of features).</p></li>
<li><p><strong>feature_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Array of strings describing each feature, returned if <cite>return_feature_list</cite> is True.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">features</span><span class="p">,</span> <span class="n">feature_descriptions</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_features</span><span class="p">(</span><span class="n">my_feature_funcs</span><span class="p">,</span> <span class="n">return_feature_list</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_index">
<span class="sig-name descname"><span class="pre">get_cell_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_index"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_index" title="Link to this definition"></a></dt>
<dd><p>Computes indices and corresponding frame information for each cell in an image stack, capturing
this data in several attributes. This method gathers extensive cell data across all frames,
including frame indices, image file indices, individual image indices, and bounding boxes
for each cell. This information is stored in corresponding attributes, facilitating further
analysis or reference.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>verbose</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, prints detailed logging of the processing for each frame. Default is False.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the computed data to an HDF5 file using the specified <cite>mskchannel</cite>. Default is False.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and <cite>save_h5</cite> is True, existing data in the HDF5 file will be overwritten. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>True if the computation and any specified data saving are successful, False if there is
an error due to missing prerequisites or during saving.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.cells_frameSet">
<span class="sig-name descname"><span class="pre">cells_frameSet</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.cells_frameSet" title="Link to this definition"></a></dt>
<dd><p>Array storing the frame index for each cell, shape (ncells_total,).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.cells_imgfileSet">
<span class="sig-name descname"><span class="pre">cells_imgfileSet</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.cells_imgfileSet" title="Link to this definition"></a></dt>
<dd><p>Array storing the image file index for each cell, shape (ncells_total,).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.cells_indSet">
<span class="sig-name descname"><span class="pre">cells_indSet</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.cells_indSet" title="Link to this definition"></a></dt>
<dd><p>Array storing a unique index for each cell in the trajectory, shape (ncells_total,).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.cells_indimgSet">
<span class="sig-name descname"><span class="pre">cells_indimgSet</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.cells_indimgSet" title="Link to this definition"></a></dt>
<dd><p>Array storing the image-specific index for each cell, shape (ncells_total,).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.cellblocks">
<span class="sig-name descname"><span class="pre">cellblocks</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.cellblocks" title="Link to this definition"></a></dt>
<dd><p>Array of bounding boxes for each cell, shape (ncells_total, ndim, 2).</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>AttributeError</strong> – If necessary attributes (like <cite>nmaskchannels</cite>, <cite>ncells_total</cite>, <cite>mskchannel</cite>, <cite>maxFrame</cite>)
    are not set prior to invoking this method.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_index</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">save_h5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_parents">
<span class="sig-name descname"><span class="pre">get_cell_parents</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">icell</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_parents"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_parents" title="Link to this definition"></a></dt>
<dd><p>Get the child cells for a given cell in the next frame.</p>
<p>This function identifies the parent cells of a given child cell <cite>icell</cite> by tracking the lineage data
across consecutive frames. The lineage is determined from the parent cell’s index and the lineage set
for the previous frame.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>icell</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The index of the cell for which to find the children.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ind_children</strong> – An array of indices representing the child cells of the given cell <cite>icell</cite> in the next frame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function looks at the current frame of <cite>icell</cite> and identifies its child cells in the subsequent frame</p></li>
</ul>
<p>using the lineage tracking set (<cite>linSet</cite>).
- This method assumes that the lineage set (<cite>linSet</cite>) and cell indexing (<cite>cells_indimgSet</cite>, <cite>cells_indSet</cite>)
are properly initialized and populated.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell_index</span> <span class="o">=</span> <span class="mi">10</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">children</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cell_children</span><span class="p">(</span><span class="n">cell_index</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Children of cell </span><span class="si">{</span><span class="n">cell_index</span><span class="si">}</span><span class="s1">: </span><span class="si">{</span><span class="n">children</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_positions">
<span class="sig-name descname"><span class="pre">get_cell_positions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_positions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_positions" title="Link to this definition"></a></dt>
<dd><p>Calculate the center of mass for cells in each frame of the mask channel and optionally save
these positions to an HDF5 file. This method processes mask data to find cell positions across
frames and can store these positions back into the HDF5 file associated with the Trajectory
instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The index of the mask channel from which to calculate cell positions. Default is 0.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, the calculated cell positions will be saved to the HDF5 file specified by
<cite>h5filename</cite>. Default is False.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and <cite>save_h5</cite> is also True, existing data in the HDF5 file will be overwritten.
Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of cell positions calculated from the mask channel. The shape of the array is
(number of cells, number of dimensions).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>RuntimeError</strong> – If the stack has not been transformed, indicated by <cite>tf_matrix_set</cite> not being set.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">get_stack_trans</span><span class="p">()</span>  <span class="c1"># Ensure transformation matrix is set</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">positions</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_positions</span><span class="p">(</span><span class="n">mskchannel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">save_h5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">getting positions from mask channel 1, default mskchannel is 0</span>
<span class="go">loading cells from frame 0</span>
<span class="go">loading cells from frame 1</span>
<span class="go">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_sandwich">
<span class="sig-name descname"><span class="pre">get_cell_sandwich</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_expansion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajl_past</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajl_future</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_sandwich"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_sandwich" title="Link to this definition"></a></dt>
<dd><p>Extracts a sequence of image and mask “sandwiches” for a given cell, including past and future frames.</p>
<p>This function creates a set of 2D or 3D image and mask stacks for a specified cell, tracking the cell
across multiple frames into the past and future. It includes boundary expansion around the cell if specified
and gathers the images and masks for the cell trajectory. The function is useful for analyzing the temporal
behavior of a cell within its local neighborhood.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ic</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Index of the target cell.</p></li>
<li><p><strong>msk_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Channel of the mask image where the cell is identified (default is 0).</p></li>
<li><p><strong>boundary_expansion</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code>, <em>optional</em>) – Number of pixels to expand the boundary around the cell block (default is None, no expansion).</p></li>
<li><p><strong>trajl_past</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of past frames to include in the sandwich (default is 1).</p></li>
<li><p><strong>trajl_future</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of future frames to include in the sandwich (default is 1).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>imgs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A list of image stacks (2D or 3D) for each frame in the trajectory sandwich.</p></li>
<li><p><strong>msks</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A list of binary masks corresponding to the same frames in <cite>imgs</cite>, where the cell and its descendants
are highlighted.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function retrieves the cell trajectory from the current frame, including both past and future cells,</p></li>
</ul>
<p>as well as their children in future frames.
- The images and masks are collected and returned in two separate lists, with the past, present, and future
frames in sequential order.
- The function supports both 2D and 3D image data based on the dimensions of the input data.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">imgs</span><span class="p">,</span> <span class="n">msks</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cell_sandwich</span><span class="p">(</span><span class="n">ic</span><span class="o">=</span><span class="mi">42</span><span class="p">,</span> <span class="n">boundary_expansion</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">trajl_past</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">trajl_future</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Retrieved </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">imgs</span><span class="p">)</span><span class="si">}</span><span class="s1"> images and masks for cell 42 across past and future frames.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cell_trajectory">
<span class="sig-name descname"><span class="pre">get_cell_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cell_trajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cell_trajectory" title="Link to this definition"></a></dt>
<dd><p>Retrieves the trajectory of a specified cell across previous frames, tracing back from the current frame to
the point of its first appearance or until a specified number of history steps.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_ind</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The index of the cell for which to retrieve the trajectory.</p></li>
<li><p><strong>n_hist</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of historical steps to trace back. If set to -1 (default), the function traces back
to the earliest frame in which the cell appears.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>cell_traj</strong> – An array of cell indices representing the trajectory of the specified cell across the tracked frames.
The array is ordered from the earliest appearance to the current frame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>IndexError</strong> – If the cell index provided is out of the bounds of the available data.</p></li>
<li><p><strong>ValueError</strong> – If the provided cell index does not correspond to any tracked cell, possibly due to errors in lineage tracking.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell_trajectory</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_cell_trajectory</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">cell_trajectory</span><span class="p">)</span>
<span class="go">[23, 45, 67, 89]  # Example output, actual values depend on cell tracking results.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<p>The trajectory is computed by accessing the lineage data (<cite>linSet</cite>), which must be computed beforehand
via methods such as <cite>get_lineage_btrack</cite>. Each index in the resulting trajectory corresponds to a
position in previous frames where the cell was identified, stepping backwards until the cell’s first
detection or the limit of specified history steps.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cellboundary_library">
<span class="sig-name descname"><span class="pre">get_cellboundary_library</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frames</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">secretion_rates</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_fmask_channels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[0]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">surface_states_baseid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">vdist_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">border_property_args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cellboundary_library"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cellboundary_library" title="Link to this definition"></a></dt>
<dd><p>Collect and create a library of boundary properties for cells across specified frames in a trajectory.</p>
<p>This function gathers cell and surface boundary properties across frames or specific cell indices.
It collects properties such as position, displacement, neighboring point states, curvatures,
and secreted ligand distributions, if applicable. This data is returned in a library format
and optionally saved to an HDF5 file for later use.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frames</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Frame indices to include in the boundary library. If None, includes all frames in <cite>cells_frameSet</cite>.</p></li>
<li><p><strong>indcells</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of specific cell indices to include in the library. If None, all cells are included.</p></li>
<li><p><strong>secretion_rates</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of secretion rates for each cell, used to calculate ligand distribution along borders.</p></li>
<li><p><strong>cell_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of cell states for each cell. If not provided, cells are assigned state 1.</p></li>
<li><p><strong>surface_fmask_channels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>default</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">[0]</span></code>) – List of channels indicating each surface’s mask in the frame data.</p></li>
<li><p><strong>surface_states_baseid</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Starting ID for surface states. Defaults to one more than the maximum <cite>cell_states</cite>.</p></li>
<li><p><strong>border_resolution</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Resolution for border properties in units of pixels. Default is 1.0.</p></li>
<li><p><strong>vdist_scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Scale for secreted ligand distribution. Default is 0.3.</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, displays a visualization of the boundaries. Default is False.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the resulting boundary library to an HDF5 file. Default is False.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, overwrites the HDF5 data file if it exists. Default is False.</p></li>
<li><p><strong>**border_property_args</strong> – Additional arguments passed to the <cite>get_border_properties_dict</cite> function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><p><strong>boundary_library</strong> – Dictionary containing collected boundary properties for the specified cells and frames:</p>
<ul class="simple">
<li><p><cite>global_index</cite>: Global cell indices for each boundary point.</p></li>
<li><p><cite>states</cite>: Cell or surface state at each boundary point.</p></li>
<li><p><cite>pts</cite>: Coordinates of each boundary point.</p></li>
<li><p><cite>dx_prevs</cite>, <cite>dx_nexts</cite>: Displacement vectors for boundaries to previous and next frames.</p></li>
<li><p><cite>surface_normals</cite>: Surface normal vectors at each boundary point.</p></li>
<li><p><cite>curvatures</cite>: Curvature at each boundary point.</p></li>
<li><p><cite>nn_pts</cite>: Coordinates of neighboring points.</p></li>
<li><p><cite>nn_states</cite>: States of neighboring points.</p></li>
<li><p><cite>nn_pts_states</cite>: States of neighboring points with finer resolution.</p></li>
<li><p><cite>surf_vars</cite>: Variance of surface displacement in the previous frame.</p></li>
<li><p><cite>vdists</cite>: Secreted ligand density distribution, if <cite>secretion_rates</cite> is provided.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p><strong>Frames and Cell Selection</strong>: If both <cite>frames</cite> and <cite>indcells</cite> are provided, only frames derived from</p></li>
</ul>
<p><cite>indcells</cite> are used.
- <strong>Surfaces and States</strong>: <cite>surface_fmask_channels</cite> and <cite>surface_states_baseid</cite> define and initialize
surfaces in each frame, using additional states based on <cite>surface_states_baseid</cite>.
- <strong>Ligand Distribution</strong>: Secreted ligand density distribution (<cite>vdists</cite>) is included if <cite>secretion_rates</cite>
is specified.</p>
<p class="rubric">Examples</p>
<p>Generate a cell boundary library for frames 10, 15, and 20, with visualization enabled:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_library</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellboundary_library</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">frames</span><span class="o">=</span><span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">15</span><span class="p">,</span> <span class="mi">20</span><span class="p">],</span> <span class="n">secretion_rates</span><span class="o">=</span><span class="n">my_secretion_rates</span><span class="p">,</span> <span class="n">cell_states</span><span class="o">=</span><span class="n">my_cell_states</span><span class="p">,</span>
<span class="gp">... </span>    <span class="n">surface_fmask_channels</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">visual</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">border_resolution</span><span class="o">=</span><span class="mf">2.0</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
<p>Save the boundary library to HDF5 with overwrite enabled:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">boundary_library</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_cellboundary_library</span><span class="p">(</span>
<span class="gp">... </span>    <span class="n">indcells</span><span class="o">=</span><span class="n">my_indcells</span><span class="p">,</span> <span class="n">save_h5</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">overwrite</span><span class="o">=</span><span class="kc">True</span>
<span class="gp">... </span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_cells_nchildren">
<span class="sig-name descname"><span class="pre">get_cells_nchildren</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_cells_nchildren"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_cells_nchildren" title="Link to this definition"></a></dt>
<dd><p>Compute the number of children for each cell across all frames.</p>
<p>This function calculates the number of child cells each parent cell has across consecutive time frames.
The result is an array where each element corresponds to the number of child cells for a given parent
cell in the next frame. Cells with no children will have a count of 0.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>cells_nchildren</strong> – An array where each element represents the number of child cells for each cell
in the dataset. The indices correspond to the cell indices in <cite>self.cells_indSet</cite>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The function iterates through all time frames (<cite>nt</cite>) to determine the lineage of each cell</p></li>
</ul>
<p>using the <cite>linSet</cite> attribute, which holds the lineage information between frames.
- Cells that are not tracked between frames (i.e., not assigned a child in the next frame)
will have a count of 0 children.
- The method assumes that <cite>linSet</cite>, <cite>cells_indSet</cite>, and <cite>cells_indimgSet</cite> are properly initialized
and populated.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">cell_children_counts</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">get_cells_nchildren</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of children for each cell: </span><span class="si">{</span><span class="n">cell_children_counts</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_dx">
<span class="sig-name descname"><span class="pre">get_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_dx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_dx" title="Link to this definition"></a></dt>
<dd><p>Calculates the displacement vector of a cell between its current position and its previous position in the
trajectory. This vector represents the movement of the cell between two consecutive time points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>i1</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Index of the cell for which to calculate the displacement.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>dx1</strong> – A vector representing the displacement of the cell. The vector is given in the coordinate space
of the cell positions. If the calculation fails (e.g., due to missing data), returns a vector
of NaNs.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>Exception</strong> – If an error occurs during the trajectory retrieval or calculation, typically due to missing
    data or incorrect indices.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">displacement</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_dx</span><span class="p">(</span><span class="mi">10</span><span class="p">)</span>
<span class="go"># This calculates the displacement vector for the cell at index 10 between its current and previous positions.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method attempts to retrieve the last position from the cell’s trajectory using <cite>get_cell_trajectory</cite>.</p></li>
</ul>
<p>If the cell’s trajectory does not have a previous position or the data is missing, the displacement
vector will contain NaN values to indicate the failure of the calculation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_fmask_data">
<span class="sig-name descname"><span class="pre">get_fmask_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_fmask_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_fmask_data" title="Link to this definition"></a></dt>
<dd><p>Retrieve the foreground mask data for a specific frame using different methods depending on
the set attributes. This method determines the foreground mask either by selecting a specific
mask channel (<cite>fmskchannel</cite>), by applying a threshold to an image channel (<cite>fmsk_threshold</cite>
and <cite>fmsk_imgchannel</cite>), or directly from specified channels in the HDF5 file (<cite>fmask_channels</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n_frame</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The frame number from which to retrieve the foreground mask data.</p></li>
<li><p><strong>channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The specific channel to use when <cite>fmask_channels</cite> attribute is set. If not provided, the
default ‘foreground’ channel is used if available.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>fmsk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – The foreground (cells) / background mask array, indicating cell locations as True and
background as False.</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">Methods</span> <span class="pre">for</span> <span class="pre">Determining</span> <span class="pre">`fmsk`</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">------------------------------</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">1.</span> <span class="pre">If</span> <span class="pre">`fmskchannel</span></code> is set`</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">-</span> <span class="pre">The</span> <span class="pre">method</span> <span class="pre">uses</span> <span class="pre">the</span> <span class="pre">specified</span> <span class="pre">channel</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">mask</span> <span class="pre">data</span> <span class="pre">(not</span> <span class="pre">fmask</span> <span class="pre">data).</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">2.</span> <span class="pre">If</span> <span class="pre">`fmsk_threshold`</span></code> and <cite>fmsk_imgchannel</cite> are set</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">-</span> <span class="pre">The</span> <span class="pre">method</span> <span class="pre">thresholds</span> <span class="pre">the</span> <span class="pre">image</span> <span class="pre">data</span> <span class="pre">at</span> <span class="pre">the</span> <span class="pre">specified</span> <span class="pre">channel</span> <span class="pre">using</span> <span class="pre">the</span> <span class="pre">given</span> <span class="pre">threshold.</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">3.</span> <span class="pre">If</span> <span class="pre">`fmask_channels</span></code> is set` and <code class="xref py py-class docutils literal notranslate"><span class="pre">the</span> <span class="pre">channel</span> <span class="pre">parameter</span> <span class="pre">is</span> <span class="pre">provided</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">a</span> <span class="pre">default</span> <span class="pre">is</span> <span class="pre">available</span></code></p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">-</span> <span class="pre">The</span> <span class="pre">method</span> <span class="pre">retrieves</span> <span class="pre">the</span> <span class="pre">mask</span> <span class="pre">from</span> <span class="pre">the</span> <span class="pre">specified</span></code> or <em>default</em> <code class="xref py py-class docutils literal notranslate"><span class="pre">channel</span> <span class="pre">in</span> <span class="pre">the</span> <span class="pre">`fmsk</span></code> dataset.`</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmask_data</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_fmask_data</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fmask_data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1024, 1024)  # Example shape, actual may vary.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_frames">
<span class="sig-name descname"><span class="pre">get_frames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_frames"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_frames" title="Link to this definition"></a></dt>
<dd><p>Scans an HDF5 file for image and mask datasets to determine the total number of frames,
images per frame, and the total number of cells across all frames. This method updates the
instance with attributes for the number of images, the maximum frame index, and the total
cell count. It handles multiple mask channels by requiring the <cite>mskchannel</cite> attribute to be
set if more than one mask channel exists.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Returns True if the frames were successfully scanned and the relevant attributes set.
Returns False if the HDF5 file is not set, no image data is found, or if there are
multiple mask channels but <cite>mskchannel</cite> is not specified.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>AttributeError</strong> – If <cite>mskchannel</cite> needs to be specified but is not set when <cite>nmaskchannel</cite> is greater than zero.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_frames</span><span class="p">()</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_image_data">
<span class="sig-name descname"><span class="pre">get_image_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_image_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_image_data" title="Link to this definition"></a></dt>
<dd><p>Retrieve the image data for a specified frame from the HDF5 file associated with this instance.
This method accesses the HDF5 file, navigates to the specific dataset for the given frame,
and extracts the image data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_frame</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The frame number from which to retrieve image data.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>img</strong> – The image data as a NumPy array. The shape and type of the array depend on the structure
of the image data in the HDF5 file (e.g., may include dimensions for channels or z-stacks).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_data</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_image_data</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">image_data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1024, 1024, 3)  # Example shape, actual may vary.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_image_shape">
<span class="sig-name descname"><span class="pre">get_image_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_image_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_image_shape" title="Link to this definition"></a></dt>
<dd><p>Determine the dimensions of the image and mask data from the HDF5 file at a specified frame
index and store these as attributes. This method retrieves the dimensions of both the image
and mask datasets, discerning whether the data includes channels or z-stacks, and updates the
object’s attributes accordingly. Attributes updated include the number of dimensions (<cite>ndim</cite>),
image axes layout (<cite>axes</cite>), image dimensions (<cite>nx</cite>, <cite>ny</cite>, <cite>[nz]</cite>), number of channels in the
image and mask (<cite>nchannels</cite>, <cite>nmaskchannels</cite>), and the full image shape (<cite>image_shape</cite>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_frame</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The frame index from which to retrieve the image and mask dimensions. Default is 0.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns True if the dimensions were successfully retrieved and stored as attributes,
False otherwise, such as when the file is not found or an error occurs in reading data.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.axes">
<span class="sig-name descname"><span class="pre">axes</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.axes" title="Link to this definition"></a></dt>
<dd><p>The layout of axes in the image data, e.g., ‘xy’, ‘xyc’, ‘zxy’, ‘zxyc’.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.nx">
<span class="sig-name descname"><span class="pre">nx</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.nx" title="Link to this definition"></a></dt>
<dd><p>Width of the image in pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.ny">
<span class="sig-name descname"><span class="pre">ny</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.ny" title="Link to this definition"></a></dt>
<dd><p>Height of the image in pixels.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.nz">
<span class="sig-name descname"><span class="pre">nz</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.nz" title="Link to this definition"></a></dt>
<dd><p>Number of z-stacks in the image, if applicable.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.image_shape">
<span class="sig-name descname"><span class="pre">image_shape</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.image_shape" title="Link to this definition"></a></dt>
<dd><p>Array representing the dimensions of the image.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.nchannels">
<span class="sig-name descname"><span class="pre">nchannels</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.nchannels" title="Link to this definition"></a></dt>
<dd><p>Number of channels in the image data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.nmaskchannels">
<span class="sig-name descname"><span class="pre">nmaskchannels</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.nmaskchannels" title="Link to this definition"></a></dt>
<dd><p>Number of channels in the mask data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.ndim">
<span class="sig-name descname"><span class="pre">ndim</span></span><a class="headerlink" href="#celltraj.trajectory.Trajectory.ndim" title="Link to this definition"></a></dt>
<dd><p>Number of spatial dimensions in the image data.</p>
<dl class="field-list simple">
<dt class="field-odd">Type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></p>
</dd>
</dl>
</dd></dl>

<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">success</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_image_shape</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_lineage_btrack">
<span class="sig-name descname"><span class="pre">get_lineage_btrack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">framewindow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual_1cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_search_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_lineage_btrack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_lineage_btrack" title="Link to this definition"></a></dt>
<dd><p>Tracks cell lineages over an image stack using Bayesian tracking with visual confirmation options.
This method registers transformed masks and applies Bayesian tracking to link cell identities
across frames, storing the lineage information.
Use of btrack software requires a cell_config.json file stored in the directory, see btrack documentation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Mask channel used to identify cell labels from which cell centers are extracted.</p></li>
<li><p><strong>distcut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>) – Maximum distance between cell centers in consecutive frames for cells to be considered the same.</p></li>
<li><p><strong>framewindow</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Number of frames over which to look for cell correspondences.</p></li>
<li><p><strong>visual_1cell</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, displays visual tracking information for single cell matches during processing.</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, displays visual tracking information for all cells during processing.</p></li>
<li><p><strong>max_search_radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The maximum search radius in pixels for linking objects between frames.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True, saves the lineage data (<cite>linSet</cite>) to an HDF5 file.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>) – If True and save_h5 is True, overwrites existing data in the HDF5 file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>linSet</strong> – A list of arrays where each array corresponds to a frame and contains indices that map
each cell to its predecessor in the previous frame. Cells with no predecessor are marked
with -1. The data saved in <cite>linSet</cite> thus represents the lineage of each cell over the stack.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AttributeError</strong> – If <cite>tf_matrix_set</cite> is not set, indicating that stack transformation matrices are required
    for tracking but have not been calculated.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">lineage_data</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_lineage_btrack</span><span class="p">(</span><span class="n">mskchannel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_lineage_min_otcost">
<span class="sig-name descname"><span class="pre">get_lineage_min_otcost</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ot_cost_cut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">inf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">border_resolution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_cost</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_lineage_min_otcost"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_lineage_min_otcost" title="Link to this definition"></a></dt>
<dd><p>Tracks cell lineages over multiple time points using optimal transport cost minimization.</p>
<p>This method uses centroid distances and optimal transport costs to identify the best matches for cell
trajectories between consecutive time points, ensuring accurate tracking even in dense or complex environments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distcut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Maximum distance between cell centroids to consider a match (default is 5.0).</p></li>
<li><p><strong>ot_cost_cut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Maximum optimal transport cost allowed for a match (default is np.inf).</p></li>
<li><p><strong>border_scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Scaling factors for the cell border in the [z, y, x] dimensions. If not provided, the scaling is
determined from <cite>self.micron_per_pixel</cite> and <cite>border_resolution</cite>.</p></li>
<li><p><strong>border_resolution</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Resolution for the cell border, used to determine <cite>border_scale</cite> if it is not provided. If not set,
uses <cite>self.border_resolution</cite>.</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, plots the cells and their matches at each time point for visualization (default is False).</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the lineage data to the HDF5 file (default is False).</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, overwrites existing data in the HDF5 file when saving (default is False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The function updates the instance’s <cite>linSet</cite> attribute, which is a list of arrays containing lineage
information for each time point. If <cite>save_h5</cite> is True, the lineage data is saved to the HDF5 file.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">None</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function assumes that cell positions have already been extracted using the <cite>get_cell_positions</cite> method.</p></li>
<li><p>The function uses the <cite>spatial.get_border_dict</cite> method to compute cell borders and <cite>spatial.get_ot_dx</cite></p></li>
</ul>
<p>to compute optimal transport distances.
- Visualization is available for 2D and 3D data, with different handling for each case.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">get_lineage_min_otcost</span><span class="p">(</span><span class="n">distcut</span><span class="o">=</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">ot_cost_cut</span><span class="o">=</span><span class="mf">50.0</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">Frame 1 tracked 20 of 25 cells</span>
<span class="go">Frame 2 tracked 22 of 30 cells</span>
<span class="go">...</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_lineage_mindist">
<span class="sig-name descname"><span class="pre">get_lineage_mindist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_lineage_mindist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_lineage_mindist" title="Link to this definition"></a></dt>
<dd><p>Tracks cell lineage based on the minimum distance between cells across consecutive frames.
This method assesses cell positions to establish lineage by identifying the nearest cell
in the subsequent frame within a specified distance threshold.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>distcut</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The maximum distance a cell can move between frames to be considered the same cell.
Cells moving a distance greater than this threshold will not be tracked from one frame to the next.</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, displays a visual representation of the tracking process for each frame, showing
the cells and their movements between frames.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the lineage data (<cite>linSet</cite>) to an HDF5 file.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and save_h5 is True, overwrites existing data in the HDF5 file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>linSet</strong> – A list where each entry corresponds to a frame and contains cell indices that map each cell
to its predecessor in the previous frame. Cells with no identifiable predecessor are marked with -1.
This list provides a complete lineage map of cells across all analyzed frames.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>AttributeError</strong> – If the cell positions (<cite>x</cite>) are not calculated prior to running this method, indicating that
    <cite>get_cell_positions</cite> needs to be executed first.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">lineage_data</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_lineage_mindist</span><span class="p">(</span><span class="n">distcut</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">visual</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_mask_data">
<span class="sig-name descname"><span class="pre">get_mask_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_mask_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_mask_data" title="Link to this definition"></a></dt>
<dd><p>Retrieve the mask data for a specified frame from the HDF5 file associated with this instance.
This method accesses the HDF5 file, navigates to the specific dataset for the given frame,
and extracts the mask data.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n_frame</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The frame number from which to retrieve mask data.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>msk</strong> – The mask data as a NumPy array. The structure of the array will depend on the mask setup
in the HDF5 file, such as whether it includes dimensions for multiple channels or z-stacks.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_data</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_mask_data</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">mask_data</span><span class="o">.</span><span class="n">shape</span>
<span class="go">(1024, 1024, 2)  # Example shape, actual may vary.</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_motility_features">
<span class="sig-name descname"><span class="pre">get_motility_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_motility_features"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_motility_features" title="Link to this definition"></a></dt>
<dd><p>Extracts motility features for individual cells and their neighbors. This method calculates
both single-cell and neighbor-averaged motility characteristics, such as displacement and
interaction with neighboring cells, based on tracking data and cell label information.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indcells</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Indices of cells for which to calculate motility features. If None, features are calculated
for all cells in the dataset.</p></li>
<li><p><strong>mskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Mask channel used to define cell labels.</p></li>
<li><p><strong>radius</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Size of morphological expansion in pixels to find neighboring cells.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the calculated motility features to an HDF5 file specified in the trajectory object.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and save_h5 is True, overwrites existing data in the HDF5 file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>Xf_com</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array of computed motility features for each specified cell. The array dimensions are
(number of cells, number of features).</p></li>
<li><p><strong>feature_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Descriptions of each motility feature computed. This is returned if <cite>return_feature_list</cite>
is set to True in the method call.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If required data such as mask channels or cell indices are not set, or if cell tracking has
    not been performed prior to feature extraction.</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">motility_features</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_motility_features</span><span class="p">(</span><span class="n">indcells</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">mskchannel</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_multipole_boundarylibrary_properties">
<span class="sig-name descname"><span class="pre">get_multipole_boundarylibrary_properties</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_state_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn_states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nn_state_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_dx_prevs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_dx_nexts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_curvatures</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_vdists</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">include_shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_multipole_boundarylibrary_properties"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_multipole_boundarylibrary_properties" title="Link to this definition"></a></dt>
<dd><p>Compute spherical multipole‐based features from the pre‐extracted boundary library for each cell.</p>
<p>This routine treats each cell’s boundary points as a discrete distribution of “charges” (scalar values
defined by inverse neighbor distances, curvature, displacements, etc.), and computes the low‐order
multipole moments of that distribution. Multipole moments compactly encode spatial patterns around each
cell, capturing neighborhood geometry, motility, and shape features in a rotationally invariant basis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>self</strong> (<a class="reference internal" href="#celltraj.trajectory.Trajectory" title="celltraj.trajectory.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a>) – A <cite>Trajectory</cite> instance whose <cite>boundary_library</cite> (from
<cite>get_cellboundary_library</cite>) contains per‐point data.</p></li>
<li><p><strong>indcells</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – List of global cell indices to process. If None, processes all cells in the library.</p></li>
<li><p><strong>cell_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Subset of cell‐state IDs to include. Default is all states found in the library.</p></li>
<li><p><strong>cell_state_labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Text labels for each <cite>cell_states</cite> entry. Defaults to <cite>“cell state {state_id}”</cite>.</p></li>
<li><p><strong>nn_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Subset of neighbor‐state IDs to include. Defaults to all neighbor states in the library.</p></li>
<li><p><strong>nn_state_labels</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – Text labels for each <cite>nn_states</cite> entry. Defaults to <cite>“nn state {state_id}”</cite>.</p></li>
<li><p><strong>include_dx_prevs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>default</em> <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>) – Whether to include multipole moments of the previous‐frame normal displacement.</p></li>
<li><p><strong>include_dx_nexts</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>default</em> <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>) – Whether to include multipole moments of the next‐frame normal displacement.</p></li>
<li><p><strong>include_curvatures</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>default</em> <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>) – Whether to include multipole moments of the boundary curvature.</p></li>
<li><p><strong>include_vdists</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>default</em> <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>) – Whether to include multipole moments of secreted ligand density (<cite>vdist</cite>).</p></li>
<li><p><strong>include_shape</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>default</em> <code class="xref py py-obj docutils literal notranslate"><span class="pre">True</span></code>) – Whether to include shape features (e.g., sphere radius) via multipole moments.</p></li>
<li><p><strong>order</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>default</em> <code class="docutils literal notranslate"><span class="pre">1</span></code>) – Maximum spherical harmonic order ℓ for the multipole expansion.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>default</em> <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>) – If True, store results (<cite>mm_properties</cite> and <cite>mm_property_names</cite>) in this instance’s HDF5 data.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>default</em> <code class="xref py py-obj docutils literal notranslate"><span class="pre">False</span></code>) – If True and <cite>save_h5</cite> is True, overwrite existing datasets in the HDF5 file.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>mm_properties</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">shape</span> <span class="pre">(max_cell_id+1</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">n_features)</span></code>) – Rows indexed by cell ID, columns by the multipole‐derived features listed in <cite>property_names</cite>.</p></li>
<li><p><strong>property_names</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – Length‐<cite>n_features</cite> list describing each column in <cite>mm_properties</cite>.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>Multipole moments are computed by expanding the scalar “charge” distribution q(r) on the boundary into</p></li>
</ul>
<p>spherical harmonics up to order <cite>order</cite>, then assembling the radial moments.
- The <cite>multipoles</cite> package (Maroba et al.) handles the core expansion:
<a class="reference external" href="https://github.com/maroba/multipoles">https://github.com/maroba/multipoles</a>
- Feature blocks include:</p>
<blockquote>
<div><ul class="simple">
<li><p>Inverse‐distance charges to each neighbor state</p></li>
<li><p>Frame‐to‐frame normal displacements (prev/next)</p></li>
<li><p>Local curvature</p></li>
<li><p>Ligand density (<cite>vdist</cite>), if requested</p></li>
<li><p>Shape deviations and equivalent sphere radius</p></li>
</ul>
</div></blockquote>
<p class="rubric">References</p>
<ul class="simple">
<li><p>Maroba, M. _multipoles_ Python package:</p></li>
</ul>
<p><a class="reference external" href="https://github.com/maroba/multipoles">https://github.com/maroba/multipoles</a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_pair_rdf">
<span class="sig-name descname"><span class="pre">get_pair_rdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_indsA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_indsB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_pair_rdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_pair_rdf" title="Link to this definition"></a></dt>
<dd><p>Calculates the radial distribution function (RDF) between two sets of cells, identifying the
frequency of cell-cell distances within specified radial bins. This method is commonly used
in statistical physics and materials science to study the spatial distribution of particles.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_indsA</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Indices of the first set of cells. If None, considers all cells.</p></li>
<li><p><strong>cell_indsB</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Indices of the second set of cells. If None, uses the same indices as <cite>cell_indsA</cite>.</p></li>
<li><p><strong>rbins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of radial bins for calculating RDF. If None, bins are generated linearly from nearly 0 to <cite>rmax</cite>.</p></li>
<li><p><strong>nr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of radial bins if <cite>rbins</cite> is not specified. Default is 50.</p></li>
<li><p><strong>rmax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Maximum radius for the radial bins if <cite>rbins</cite> is not specified. Default is 500 units.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>rbins</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – The radial bins used for the RDF calculation, adjusted to remove the zero point and ensure proper binning.</p></li>
<li><p><strong>paircorrx</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – RDF values corresponding to each radial bin, normalized to the total number of pairs and the bin volumes.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">rbins</span><span class="p">,</span> <span class="n">rdf</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_pair_rdf</span><span class="p">(</span><span class="n">cell_indsA</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">cell_indsB</span><span class="o">=</span><span class="p">[</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">],</span> <span class="n">nr</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="mi">200</span><span class="p">)</span>
<span class="go"># This will calculate the RDF between two specified sets of cells with 100 radial bins up to a maximum radius of 200.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The RDF gives a normalized measure of how often pairs of points (cells) appear at certain distances from each other,</p></li>
</ul>
<p>compared to what would be expected for a completely random distribution at the same density.
- This function is useful for examining the spatial organization and clustering behavior of cells in tissues or cultures.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_secreted_ligand_density">
<span class="sig-name descname"><span class="pre">get_secreted_ligand_density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskchannel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">indz_bm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">secretion_rate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">D</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flipz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_secreted_ligand_density"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_secreted_ligand_density" title="Link to this definition"></a></dt>
<dd><p>Simulates the diffusion of secreted ligands from cells, providing a spatial distribution of ligand density across a specified frame.
The simulation considers specified boundary conditions and secretion rates to model the ligand concentration in the vicinity of cells.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>frame</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The frame index from which image and mask data are extracted.</p></li>
<li><p><strong>mskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The channel of the mask that identifies the cells.</p></li>
<li><p><strong>scale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The scaling factor for the resolution of the simulation. Default is 2.0.</p></li>
<li><p><strong>npad</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – Padding to add around the simulation area to avoid edge effects. Defaults to [0, 0, 0] if None.</p></li>
<li><p><strong>indz_bm</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The index of the bottom-most slice to consider in the z-dimension.</p></li>
<li><p><strong>secretion_rate</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – The rate at which ligands are secreted by the cells. Can be a single value or an array specifying different rates for different cells.</p></li>
<li><p><strong>D</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Diffusion coefficient. If not specified, it is calculated based on the pixel size and z-scaling.</p></li>
<li><p><strong>flipz</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, flips the z-dimension of the image and mask data, useful for certain imaging orientations.</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, displays visualizations of the simulation process and results.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>vdist</strong> – A 3D array representing the volumetric distribution of the ligand density around cells in the specified frame.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ligand_density</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_secreted_ligand_density</span><span class="p">(</span><span class="n">frame</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">mskchannel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mf">1.5</span><span class="p">,</span> <span class="n">secretion_rate</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">D</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go"># This will simulate and return the ligand density around cells in frame 10 with specified parameters.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If any of the provided indices or parameters are out of the expected range or if there is a mismatch in array dimensions.</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method performs a complex series of image processing steps including scaling, padding, flipping, and 3D mesh generation.</p></li>
<li><p>It uses finite element methods to solve diffusion equations over the generated mesh, constrained by the cellular boundaries and secretion rates.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_signal_contributions">
<span class="sig-name descname"><span class="pre">get_signal_contributions</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">S</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">time_lag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_pos</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rescale_z</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_signal_contributions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_signal_contributions" title="Link to this definition"></a></dt>
<dd><p>Computes the spatial contributions of signaling between cells over a specified time lag. This method
averages signals from nearby cells, weighted inversely by their distances, to assess local signaling interactions.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>S</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – A binary array indicating the signaling status of cells (1 for active, 0 for inactive).</p></li>
<li><p><strong>time_lag</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The time lag over which to assess signal contributions, defaulting to 0 for immediate interactions.</p></li>
<li><p><strong>x_pos</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Positions of cells. If None, the positions are taken from the instance’s <cite>x</cite> attribute.</p></li>
<li><p><strong>rmax</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The maximum radius within which to consider signal contributions from neighboring cells, default is 5.</p></li>
<li><p><strong>R</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Normalization radius, typically set to the average cell diameter; defaults to the instance’s <cite>cellpose_diam</cite>.</p></li>
<li><p><strong>zscale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The scaling factor for the z-dimension, used if <cite>rescale_z</cite> is True.</p></li>
<li><p><strong>rescale_z</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, scales the z-coordinates of positions by <cite>zscale</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>S_r</strong> – An array where each element is the averaged spatial signal contribution received by each cell, normalized
by distance and weighted by the signaling status of neighboring cells.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="n">traj</span><span class="o">.</span><span class="n">cells_indSet</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">signal_contributions</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_signal_contributions</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">time_lag</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">rmax</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mi">15</span><span class="p">)</span>
<span class="go"># This computes the signal contributions for each cell, considering interactions within a radius of 10 units.</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This method is useful for understanding the influence of cell-cell interactions within a defined spatial range</p></li>
</ul>
<p>and can be particularly insightful in dynamic cellular environments where signaling is a key factor.
- The distances are normalized by the cell radius <cite>R</cite> to provide a relative measure of proximity, and the contributions
are weighted by the inverse of these normalized distances.</p>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If necessary parameters are missing or incorrectly formatted.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_stack_trans">
<span class="sig-name descname"><span class="pre">get_stack_trans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskchannel=0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrans=20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxt=10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist_function=&lt;function</span> <span class="pre">get_pairwise_distance_sum&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">zscale=None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">do_global=False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">**dist_function_keys</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_stack_trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_stack_trans" title="Link to this definition"></a></dt>
<dd><p>Computes translations across an image stack using a brute force optimization method to align
cell centers from frame to frame. This method can apply both local and global alignment strategies
based on the distribution of cell centers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>mskchannel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Mask channel to use for extracting cell centers from labels.</p></li>
<li><p><strong>ntrans</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Number of translations to try in each dimension during optimization.</p></li>
<li><p><strong>maxt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Maximum translation distance to consider in each dimension.</p></li>
<li><p><strong>dist_function</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">function</span></code>) – Optimization function that takes cell centers from two frames and a translation vector,
returning a score where lower values indicate better alignment.</p></li>
<li><p><strong>zscale</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – Scaling factor for the z-dimension to normalize it with x and y dimensions.</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, saves the computed transformation matrices to an HDF5 file.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True and save_h5 is True, overwrites existing data in the HDF5 file.</p></li>
<li><p><strong>do_global</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, performs a global alignment using the center of mass of all masks prior to brute force optimization.</p></li>
<li><p><strong>dist_function_keys</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">dict</span></code>) – Additional keyword arguments to pass to the dist_function.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>tf_matrix_set</strong> – An array of shape (nframes, ndim+1, ndim+1) containing the transformation matrices for aligning
each frame to the first frame based on the computed translations.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">transformations</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_stack_trans</span><span class="p">(</span><span class="n">mskchannel</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">ntrans</span><span class="o">=</span><span class="mi">10</span><span class="p">,</span> <span class="n">maxt</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">do_global</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_tcf">
<span class="sig-name descname"><span class="pre">get_tcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minlength</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_tcf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_tcf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_trajAB_segments">
<span class="sig-name descname"><span class="pre">get_trajAB_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stateB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distcutA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distcutB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_trajAB_segments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_trajAB_segments" title="Link to this definition"></a></dt>
<dd><p>Identifies segments within trajectories that transition between specified states, A and B. This method
can be used to analyze transitions or dwell times in specific states within a trajectory dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xt</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – An array representing trajectories, either as direct state assignments or continuous data.</p></li>
<li><p><strong>stateA</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – The state or states considered as ‘A’. Transitions from this state are analyzed.</p></li>
<li><p><strong>stateB</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code>, <em>optional</em>) – The state or states considered as ‘B’. If defined, transitions from state A to state B are analyzed.</p></li>
<li><p><strong>clusters</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code>, <em>optional</em>) – A clustering object with an ‘assign’ method that can be used to discretize continuous trajectory data into states.</p></li>
<li><p><strong>states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – An array defining all possible states. Used to map states in ‘xt’ if it contains direct state assignments.</p></li>
<li><p><strong>distcutA</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The distance cutoff for determining membership in state A if ‘xt’ is continuous.</p></li>
<li><p><strong>distcutB</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code>, <em>optional</em>) – The distance cutoff for determining membership in state B if ‘xt’ is continuous and ‘stateB’ is defined.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>slices</strong> – A list of slice objects representing the indices of ‘xt’ where transitions between specified states occur.
If only ‘stateA’ is specified, returns segments where the trajectory is in state A.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">slice</span></code></p>
</dd>
<dt class="field-even">Raises<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>ValueError</strong> – If required parameters for defining states or transitions are not provided or if the provided
    parameters are incompatible (e.g., ‘distcutA’ without a corresponding ‘stateA’).</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">xt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># Example continuous trajectory data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">clusters</span> <span class="o">=</span> <span class="n">KMeans</span><span class="p">(</span><span class="n">n_clusters</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">xt</span><span class="p">)</span>  <span class="c1"># Example clustering model</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_trajAB_segments</span><span class="p">(</span><span class="n">xt</span><span class="p">,</span> <span class="n">stateA</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">stateB</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">clusters</span><span class="o">=</span><span class="n">clusters</span><span class="p">)</span>
<span class="go"># Analyze transitions from state 0 to state 1 using cluster assignments</span>
</pre></div>
</div>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>If ‘xt’ contains direct state assignments, ‘states’ must be provided to map these to actual state values.</p></li>
<li><p>For continuous data, ‘clusters’ or distance cutoffs (‘distcutA’, ‘distcutB’) must be used to define states.</p></li>
<li><p>This function is useful for analyzing kinetic data where transitions between states are of interest.</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_traj_segments">
<span class="sig-name descname"><span class="pre">get_traj_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seg_length</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_traj_segments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_traj_segments" title="Link to this definition"></a></dt>
<dd><p>Divides each trajectory into multiple overlapping segments of a specified length. This method
is useful for analyzing sections of trajectories or for preparing data for machine learning
models that require fixed-size input.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>seg_length</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – The length of each segment to be extracted from the trajectories. Segments are created
by sliding a window of this length along each trajectory.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>traj_segSet</strong> – A 2D array where each row represents a segment of a trajectory. The number of columns
in this array equals <cite>seg_length</cite>. Each segment includes consecutive cell indices
from the original trajectories.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This method requires that the <cite>trajectories</cite> attribute has been populated, typically by</p></li>
</ul>
<p>a method that computes full trajectories such as <cite>get_unique_trajectories</cite>.
- Only trajectories that are at least as long as <cite>seg_length</cite> will contribute segments to
the output. Shorter trajectories are ignored.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">get_unique_trajectories</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">segments</span> <span class="o">=</span> <span class="n">traj</span><span class="o">.</span><span class="n">get_traj_segments</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">segments</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="go">(number of segments, 5)  # Example shape, actual values depend on trajectory lengths and seg_length.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError</strong> – If <cite>seg_length</cite> is larger than the length of any available trajectory, resulting in
    no valid segments being produced.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_trajectory_steps">
<span class="sig-name descname"><span class="pre">get_trajectory_steps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xtraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_trajectory_steps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_trajectory_steps" title="Link to this definition"></a></dt>
<dd><p>Extracts sequential steps from cell trajectories and retrieves corresponding features from a feature matrix.
This method is useful for analyses that require step-wise comparison of trajectories, such as
calculating changes or transitions over time.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>inds</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Indices of cells for which to get trajectory steps. If None, processes all cells.</p></li>
<li><p><strong>traj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The trajectory data matrix. If None, uses the instance’s <cite>traj</cite> attribute.</p></li>
<li><p><strong>Xtraj</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – The feature data matrix corresponding to trajectories. If None, uses the instance’s <cite>Xtraj</cite> attribute.</p></li>
<li><p><strong>get_trajectories</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, computes unique trajectories for the specified indices before processing steps.</p></li>
<li><p><strong>nlag</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The lag between steps in a trajectory to consider. A value of 1 means consecutive steps.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>The method assumes that the trajectory and feature data matrices (<cite>traj</cite> and <cite>Xtraj</cite>, respectively)</p></li>
</ul>
<p>are indexed in the same way.
- This function can optionally calculate unique trajectories before extracting steps, making it
versatile for both freshly calculated and pre-computed trajectory datasets.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/data.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">get_trajectory_steps</span><span class="p">(</span><span class="n">get_trajectories</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">nlag</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go"># This will compute unique trajectories for all cells and then extract every second step.</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>IndexError</strong> – If any index in <cite>inds</cite> is out of bounds of the available data.</p></li>
<li><p><strong>ValueError</strong> – If <cite>traj</cite> or <cite>Xtraj</cite> data matrices are not set and not provided as arguments.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.get_unique_trajectories">
<span class="sig-name descname"><span class="pre">get_unique_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.get_unique_trajectories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.get_unique_trajectories" title="Link to this definition"></a></dt>
<dd><p>Computes unique trajectories for a set of cells over multiple frames, minimizing redundancy by
ensuring that no two trajectories cover the same cell path beyond a specified overlap (extra_depth).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>cell_inds</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Array of cell indices for which to calculate trajectories. If None, calculates trajectories
for all cells.</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, provides detailed logs during the trajectory calculation process.</p></li>
<li><p><strong>extra_depth</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Specifies how many frames of overlap to allow between different trajectories. If not set,
uses the pre-set attribute ‘trajl’ minus one as the depth; if ‘trajl’ is not set, defaults to 0.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This method identifies unique trajectories by tracking each cell backward from its last appearance</p></li>
</ul>
<p>to its first, recording the trajectory, and then ensuring subsequent trajectories do not retread
the same path beyond the allowed overlap specified by ‘extra_depth’.
- Each trajectory is tracked until it either reaches the start of the dataset or an earlier part of
another trajectory within the allowed overlap.
- This function updates the instance’s ‘trajectories’ attribute, storing each unique trajectory.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">get_unique_trajectories</span><span class="p">(</span><span class="n">verbose</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.load_from_h5">
<span class="sig-name descname"><span class="pre">load_from_h5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.load_from_h5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.load_from_h5" title="Link to this definition"></a></dt>
<dd><p>Load data from a specified path within an HDF5 file. This method attempts to read records
recursively from the given path in the HDF5 file specified by the <cite>h5filename</cite> attribute
of the instance.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>path</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The base path in the HDF5 file from which to load data.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns True if the data was successfully loaded, False otherwise.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">load_from_h5</span><span class="p">(</span><span class="s1">&#39;/data/group1&#39;</span><span class="p">)</span>
<span class="go">loading path/to/your/hdf5file.h5</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.manual_fate_validation">
<span class="sig-name descname"><span class="pre">manual_fate_validation</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fate_attr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajl_future</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajl_past</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">restart</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">val_tracks</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rep_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bf_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nuc_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_nuc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk_channel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nuclow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">98</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nuchigh</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_allcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_linked</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_pic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">boundary_expansion</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[1,</span> <span class="pre">40,</span> <span class="pre">40]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_attr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_h5</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.manual_fate_validation"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.manual_fate_validation" title="Link to this definition"></a></dt>
<dd><p>Manually validates cell fate by reviewing images and tracking data for individual cells over time.
Provides an interactive validation interface to assess whether cells follow a specific fate or not.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>indcells</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array-like</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Indices of cells to review for fate validation.</p></li>
<li><p><strong>fate_attr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The name of the fate attribute being reviewed and validated.</p></li>
<li><p><strong>trajl_future</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of future frames to include in the trajectory review (default is 2).</p></li>
<li><p><strong>trajl_past</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of past frames to include in the trajectory review (default is 2).</p></li>
<li><p><strong>restart</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to restart validation from the beginning (default is True). If False, previously reviewed cells are re-evaluated.</p></li>
<li><p><strong>val_tracks</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, validates the cell tracking in addition to fate validation (default is True).</p></li>
<li><p><strong>rep_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The channel used for representation images (default is 2).</p></li>
<li><p><strong>bf_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The bright-field channel (default is 0).</p></li>
<li><p><strong>nuc_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The nucleus channel (default is 1).</p></li>
<li><p><strong>msk_channel</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The mask channel used for cell identification (default is 0).</p></li>
<li><p><strong>pathto</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – The path to save images if <cite>save_pic</cite> is True (default is ‘./’).</p></li>
<li><p><strong>save_pic</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to save the images for each validated cell (default is False).</p></li>
<li><p><strong>boundary_expansion</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – The number of pixels to expand the boundary of the cell block in the image (default is [1, 40, 40]).</p></li>
<li><p><strong>save_attr</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to save the validated attributes during the process (default is True).</p></li>
<li><p><strong>save_h5</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to save the updated attributes to an HDF5 file (default is False).</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – Whether to overwrite existing data when saving to HDF5 (default is False).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>vals_fate</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Validated fate values for each cell. 1 indicates fate, 0 indicates not fate, and -1 indicates unclear or indeterminate fate.</p></li>
<li><p><strong>inds_fate</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>) – Indices of the cells that were confirmed to follow the fate of interest.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<ul class="simple">
<li><p>This function provides an interactive review interface, where users can manually validate the fate and tracking of cells.</p></li>
<li><p>It allows users to interactively break cell lineage links if necessary and stores the results of each review session.</p></li>
<li><p>The images and masks for each cell across its past and future trajectory are visualized for validation.</p></li>
</ul>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">vals_fate</span><span class="p">,</span> <span class="n">inds_fate</span> <span class="o">=</span> <span class="n">model</span><span class="o">.</span><span class="n">manual_fate_validation</span><span class="p">(</span><span class="n">indcells</span><span class="p">,</span> <span class="s1">&#39;apoptosis&#39;</span><span class="p">,</span> <span class="n">trajl_future</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">trajl_past</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">save_pic</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">pathto</span><span class="o">=</span><span class="s1">&#39;/output/images&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Validated fates for </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">inds_fate</span><span class="p">)</span><span class="si">}</span><span class="s1"> cells.&#39;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory.Trajectory.save_to_h5">
<span class="sig-name descname"><span class="pre">save_to_h5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">attribute_list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory.html#Trajectory.save_to_h5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory.Trajectory.save_to_h5" title="Link to this definition"></a></dt>
<dd><p>Save specified attributes to an HDF5 file at the given path. This method saves attributes from
the current instance to a specified location within the HDF5 file, creating or overwriting data
as necessary based on the <cite>overwrite</cite> parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>path</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – The base path in the HDF5 file where attributes will be saved.</p></li>
<li><p><strong>attribute_list</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code> of <code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>) – A list containing the names of attributes to save to the HDF5 file.</p></li>
<li><p><strong>overwrite</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, existing data at the specified path will be overwritten. Default is False.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Returns True if the attributes were successfully saved, False otherwise, such as when the
HDF5 file does not exist or attributes cannot be written.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span> <span class="o">=</span> <span class="n">Trajectory</span><span class="p">(</span><span class="s1">&#39;path/to/your/hdf5file.h5&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">some_attribute</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">traj</span><span class="o">.</span><span class="n">save_to_h5</span><span class="p">(</span><span class="s1">&#39;/data/&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;some_attribute&#39;</span><span class="p">])</span>
<span class="go">saving attributes [&#39;some_attribute&#39;] to /data/ in path/to/your/hdf5file.h5</span>
<span class="go">saved some_attribute to path/to/your/hdf5file.h5/data/</span>
<span class="go">True</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

</section>
<section id="module-celltraj.trajectory_legacy">
<span id="celltraj-trajectory-legacy-module"></span><h2>celltraj.trajectory_legacy module<a class="headerlink" href="#module-celltraj.trajectory_legacy" title="Link to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">celltraj.trajectory_legacy.</span></span><span class="sig-name descname"><span class="pre">Trajectory</span></span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A toolset for single-cell trajectory modeling. See:</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>This code, currently, should be considered as an untested pre-release version</p>
</div>
<p class="rubric">References</p>
<p>Jeremy Copperman, Sean M. Gross, Young Hwan Chang, Laura M. Heiser, and Daniel M. Zuckerman.
Morphodynamical cell-state description via live-cell imaging trajectory embedding.
Biorxiv 10.1101/2021.10.07.463498, 2021.</p>
<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.__init__" title="Link to this definition"></a></dt>
<dd><p>Work-in-progress init function. For now, just start adding attribute definitions in here.
.. todo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">Most</span> <span class="n">logic</span> <span class="kn">from</span><span class="w"> </span><span class="nn">initialize</span><span class="p">()</span> <span class="n">should</span> <span class="n">be</span> <span class="n">moved</span> <span class="ow">in</span> <span class="n">here</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Also</span><span class="p">,</span> <span class="n">comment</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">these</span> <span class="n">here</span><span class="o">.</span> <span class="n">Right</span> <span class="n">now</span> <span class="n">most</span> <span class="n">of</span> <span class="n">them</span> <span class="n">have</span> <span class="n">comments</span> <span class="n">throughout</span> <span class="n">the</span> <span class="n">code</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Reorganize</span> <span class="n">these</span> <span class="n">attributes</span> <span class="n">into</span> <span class="n">some</span> <span class="n">meaningful</span> <span class="n">structure</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.afft">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">afft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.afft"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.afft" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.align_image">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">align_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.align_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.align_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.assemble_dmat">
<span class="sig-name descname"><span class="pre">assemble_dmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">symmetrize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.assemble_dmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.assemble_dmat" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.cluster_cells">
<span class="sig-name descname"><span class="pre">cluster_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.cluster_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.cluster_cells" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.cluster_trajectories">
<span class="sig-name descname"><span class="pre">cluster_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.cluster_trajectories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.cluster_trajectories" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.dist">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.dist" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.dist_with_masks">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dist_with_masks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.dist_with_masks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.dist_with_masks" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.explore_2D_celltraj">
<span class="sig-name descname"><span class="pre">explore_2D_celltraj</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_segs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.explore_2D_celltraj"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.explore_2D_celltraj" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.explore_2D_celltraj_nn">
<span class="sig-name descname"><span class="pre">explore_2D_celltraj_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_segs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.explore_2D_celltraj_nn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.explore_2D_celltraj_nn" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.explore_2D_img">
<span class="sig-name descname"><span class="pre">explore_2D_img</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.explore_2D_img"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.explore_2D_img" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.explore_2D_nn">
<span class="sig-name descname"><span class="pre">explore_2D_nn</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dm2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'./'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nvis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">coordlabel</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'coord'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.explore_2D_nn"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.explore_2D_nn" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.featBoundary">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">featBoundary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.featBoundary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.featBoundary" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.featBoundaryCB">
<span class="sig-name descname"><span class="pre">featBoundaryCB</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmsk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ncomp</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">15</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">center</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">256</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.featBoundaryCB"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.featBoundaryCB" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.featHaralick">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">featHaralick</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">levels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.featHaralick"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.featHaralick" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.featZernike">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">featZernike</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">degree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.featZernike"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.featZernike" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.feat_comdx">
<span class="sig-name descname"><span class="pre">feat_comdx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmsk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunch_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.feat_comdx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.feat_comdx" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_Xtraj_celltrajectory">
<span class="sig-name descname"><span class="pre">get_Xtraj_celltrajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_traj</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xtraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_Xtraj_celltrajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_Xtraj_celltrajectory" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_all_trajectories">
<span class="sig-name descname"><span class="pre">get_all_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_all_trajectories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_all_trajectories" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_alpha">
<span class="sig-name descname"><span class="pre">get_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_alpha" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_beta">
<span class="sig-name descname"><span class="pre">get_beta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">i2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_beta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_beta" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_border_profile">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_border_profile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_border_profile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_border_profile" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_borders">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_borders</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_borders"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_borders" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_bunch_clusters">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_bunch_clusters</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">bmsk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">array([0.,</span> <span class="pre">0.,</span> <span class="pre">0.])</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_bunch_clusters"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_bunch_clusters" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cc_cs_border">
<span class="sig-name descname"><span class="pre">get_cc_cs_border</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fmskcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cc_cs_border"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cc_cs_border" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cdist2d">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cdist2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prob1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cdist2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cdist2d" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_blocks">
<span class="sig-name descname"><span class="pre">get_cell_blocks</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_blocks"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_blocks" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_boundary_size">
<span class="sig-name descname"><span class="pre">get_cell_boundary_size</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_boundary_size"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_boundary_size" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_bunches">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_cell_bunches</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fmsk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunchcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_bunches"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_bunches" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_data">
<span class="sig-name descname"><span class="pre">get_cell_data</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_data" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_images">
<span class="sig-name descname"><span class="pre">get_cell_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_images" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_neighborhood">
<span class="sig-name descname"><span class="pre">get_cell_neighborhood</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcell</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bmsk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunch_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cpix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_neighborhood"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_neighborhood" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_positions">
<span class="sig-name descname"><span class="pre">get_cell_positions</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_positions"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_positions" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cell_trajectory">
<span class="sig-name descname"><span class="pre">get_cell_trajectory</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_ind</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_hist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cell_trajectory"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cell_trajectory" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_cellborder_images">
<span class="sig-name descname"><span class="pre">get_cellborder_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">indcells</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bordersize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_cellborder_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_cellborder_images" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_clean_mask">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_clean_mask</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">minsize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_clean_mask"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_clean_mask" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_comdx_features">
<span class="sig-name descname"><span class="pre">get_comdx_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_comdx_features"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_comdx_features" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dmat">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_dmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dmat" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dmatF_row">
<span class="sig-name descname"><span class="pre">get_dmatF_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dmatF_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dmatF_row" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dmatRT_row">
<span class="sig-name descname"><span class="pre">get_dmatRT_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'all'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dmatRT_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dmatRT_row" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dx">
<span class="sig-name descname"><span class="pre">get_dx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dx"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dx" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dx_alpha">
<span class="sig-name descname"><span class="pre">get_dx_alpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">40.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dx_alpha"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dx_alpha" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dx_rdf">
<span class="sig-name descname"><span class="pre">get_dx_rdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">8</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dx_rdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dx_rdf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dx_tcf">
<span class="sig-name descname"><span class="pre">get_dx_tcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dx_tcf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dx_tcf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_dx_theta">
<span class="sig-name descname"><span class="pre">get_dx_theta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">thbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_dx_theta"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_dx_theta" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_embedding">
<span class="sig-name descname"><span class="pre">get_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_entropy_production">
<span class="sig-name descname"><span class="pre">get_entropy_production</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_entropy_production"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_entropy_production" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_fmaskSet">
<span class="sig-name descname"><span class="pre">get_fmaskSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_fmaskSet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_fmaskSet" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_fmask_data">
<span class="sig-name descname"><span class="pre">get_fmask_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_fmask_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_fmask_data" title="Link to this definition"></a></dt>
<dd><p>Returns a list of <code class="xref py py-class docutils literal notranslate"><span class="pre">bluepy.blte.Service</span></code> objects representing
the services offered by the device. This will perform Bluetooth service
discovery if this has not already been done; otherwise it will return a
cached list of services immediately..</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>uuids</strong> (<em>list</em><em>, </em><em>optional</em>) – A list of string service UUIDs to be discovered,
defaults to None</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of the discovered <code class="xref py py-class docutils literal notranslate"><span class="pre">bluepy.blte.Service</span></code> objects,
which match the provided <code class="docutils literal notranslate"><span class="pre">uuids</span></code></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list On Python 3.x, this returns a dictionary view object,
not a list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_frames">
<span class="sig-name descname"><span class="pre">get_frames</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_frames"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_frames" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_imageSet">
<span class="sig-name descname"><span class="pre">get_imageSet</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">start_frame</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">end_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_imageSet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_imageSet" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_imageSet_trans">
<span class="sig-name descname"><span class="pre">get_imageSet_trans</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_imageSet_trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_imageSet_trans" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_imageSet_trans_turboreg">
<span class="sig-name descname"><span class="pre">get_imageSet_trans_turboreg</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_imageSet_trans_turboreg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_imageSet_trans_turboreg" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_image_data">
<span class="sig-name descname"><span class="pre">get_image_data</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_frame</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_image_data"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_image_data" title="Link to this definition"></a></dt>
<dd><p>Example function with PEP 484 type annotations.
The return type must be duplicated in the docstring to comply
with the NumPy docstring style.
:param param1: The first parameter.
:param param2: The second parameter.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>True if successful, False otherwise.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_kscore">
<span class="sig-name descname"><span class="pre">get_kscore</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Mt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_kscore"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_kscore" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_lineage_btrack">
<span class="sig-name descname"><span class="pre">get_lineage_btrack</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">framewindow</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual_1cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">max_search_radius</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_lineage_btrack"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_lineage_btrack" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_lineage_bunch_overlap">
<span class="sig-name descname"><span class="pre">get_lineage_bunch_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">45.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distcutb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">300.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overlapcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bunchcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10000.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clustervisual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_lineage_bunch_overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_lineage_bunch_overlap" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_lineage_mindist">
<span class="sig-name descname"><span class="pre">get_lineage_mindist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">distcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">65.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">pathto</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_lineage_mindist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_lineage_mindist" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_minRT">
<span class="sig-name descname"><span class="pre">get_minRT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">37</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">3.141592653589793</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dx</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">80</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_minRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_minRT" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_minT">
<span class="sig-name descname"><span class="pre">get_minT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">30.0</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_minT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_minT" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_neg_overlap">
<span class="sig-name descname"><span class="pre">get_neg_overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_neg_overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_neg_overlap" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_pair_cluster_rdf">
<span class="sig-name descname"><span class="pre">get_pair_cluster_rdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_indsA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_indsB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_pair_cluster_rdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_pair_cluster_rdf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_pair_distRT">
<span class="sig-name descname"><span class="pre">get_pair_distRT</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_pair_distRT"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_pair_distRT" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_pair_rdf">
<span class="sig-name descname"><span class="pre">get_pair_rdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_indsA</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell_indsB</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">50</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rmax</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_pair_rdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_pair_rdf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_path_entropy_2point">
<span class="sig-name descname"><span class="pre">get_path_entropy_2point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_stays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_path_entropy_2point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_path_entropy_2point" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_path_ll_2point">
<span class="sig-name descname"><span class="pre">get_path_ll_2point</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_stays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_path_ll_2point"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_path_ll_2point" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_pca">
<span class="sig-name descname"><span class="pre">get_pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_pca"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_pca" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_pca_fromdata">
<span class="sig-name descname"><span class="pre">get_pca_fromdata</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">var_cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.95</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_pca_fromdata"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_pca_fromdata" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_scaled_sigma">
<span class="sig-name descname"><span class="pre">get_scaled_sigma</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">neps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_scaled_sigma"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_scaled_sigma" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_stack_trans">
<span class="sig-name descname"><span class="pre">get_stack_trans</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskSet</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_stack_trans"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_stack_trans" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_stack_trans_frompoints">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_stack_trans_frompoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mskSet</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_stack_trans_frompoints"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_stack_trans_frompoints" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_stack_trans_turboreg">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_stack_trans_turboreg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">imgs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_stack_trans_turboreg"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_stack_trans_turboreg" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_tcf">
<span class="sig-name descname"><span class="pre">get_tcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_tcf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_tcf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_traj_ll_gmean">
<span class="sig-name descname"><span class="pre">get_traj_ll_gmean</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Mt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude_stays</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_traj_ll_gmean"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_traj_ll_gmean" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_traj_segments">
<span class="sig-name descname"><span class="pre">get_traj_segments</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">seg_length</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_traj_segments"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_traj_segments" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_trajectory_embedding">
<span class="sig-name descname"><span class="pre">get_trajectory_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajl</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">neigen</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">embedding_type</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'UMAP'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">200</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_trajectory_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_trajectory_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_trajectory_steps">
<span class="sig-name descname"><span class="pre">get_trajectory_steps</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">traj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xtraj</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">get_trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nlag</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_trajectory_steps"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_trajectory_steps" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_transition_matrix">
<span class="sig-name descname"><span class="pre">get_transition_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_transition_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_transition_matrix" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_transition_matrix_CG">
<span class="sig-name descname"><span class="pre">get_transition_matrix_CG</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">clusters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">states</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_transition_matrix_CG"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_transition_matrix_CG" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_unique_trajectories">
<span class="sig-name descname"><span class="pre">get_unique_trajectories</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">extra_depth</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_unique_trajectories"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_unique_trajectories" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.get_xtraj_tcf">
<span class="sig-name descname"><span class="pre">get_xtraj_tcf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">trajectories</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.get_xtraj_tcf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.get_xtraj_tcf" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.initialize">
<span class="sig-name descname"><span class="pre">initialize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fileSpecifier</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">modelName</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.initialize"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.initialize" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.pad_image">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">pad_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxedge</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.pad_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.pad_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.plot_embedding">
<span class="sig-name descname"><span class="pre">plot_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.plot_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.plot_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.plot_pca">
<span class="sig-name descname"><span class="pre">plot_pca</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.plot_pca"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.plot_pca" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.prepare_cell_features">
<span class="sig-name descname"><span class="pre">prepare_cell_features</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">apply_znorm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.prepare_cell_features"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.prepare_cell_features" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.prepare_cell_images">
<span class="sig-name descname"><span class="pre">prepare_cell_images</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">znormalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.prepare_cell_images"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.prepare_cell_images" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.prune_embedding">
<span class="sig-name descname"><span class="pre">prune_embedding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nN</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.prune_embedding"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.prune_embedding" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.save_all">
<span class="sig-name descname"><span class="pre">save_all</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.save_all"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.save_all" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.save_dmat_row">
<span class="sig-name descname"><span class="pre">save_dmat_row</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dmat_row</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">overwrite</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.save_dmat_row"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.save_dmat_row" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.seq_in_seq">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">seq_in_seq</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sub</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">full</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.seq_in_seq"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.seq_in_seq" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.show_cells">
<span class="sig-name descname"><span class="pre">show_cells</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">cell_inds</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">show_segs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stride</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.show_cells"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.show_cells" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.show_cells_from_image">
<span class="sig-name descname"><span class="pre">show_cells_from_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cellblocks</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.show_cells_from_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.show_cells_from_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.show_cells_queue">
<span class="sig-name descname"><span class="pre">show_cells_queue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.show_cells_queue"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.show_cells_queue" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.show_image_pair">
<span class="sig-name descname"><span class="pre">show_image_pair</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk1</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">msk2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.show_image_pair"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.show_image_pair" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.transform_image">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">transform_image</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.transform_image"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.transform_image" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory.znorm">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">znorm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory.znorm"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory.znorm" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory4D">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">celltraj.trajectory_legacy.</span></span><span class="sig-name descname"><span class="pre">Trajectory4D</span></span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory4D"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory4D" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="#celltraj.trajectory_legacy.Trajectory" title="celltraj.trajectory_legacy.Trajectory"><code class="xref py py-class docutils literal notranslate"><span class="pre">Trajectory</span></code></a></p>
<p>A modified toolset for 3D single-cell trajectory modeling. See:</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>This code, currently, should be considered as an untested pre-release version</p>
</div>
<p class="rubric">References</p>
<p>Jeremy Copperman, Sean M. Gross, Young Hwan Chang, Laura M. Heiser, and Daniel M. Zuckerman.
Morphodynamical cell-state description via live-cell imaging trajectory embedding.
Biorxiv 10.1101/2021.10.07.463498, 2021.</p>
<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.Trajectory4D.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#Trajectory4D.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.Trajectory4D.__init__" title="Link to this definition"></a></dt>
<dd><p>Work-in-progress init function. For now, just start adding attribute definitions in here.
.. todo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">Most</span> <span class="n">logic</span> <span class="kn">from</span><span class="w"> </span><span class="nn">initialize</span><span class="p">()</span> <span class="n">should</span> <span class="n">be</span> <span class="n">moved</span> <span class="ow">in</span> <span class="n">here</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Also</span><span class="p">,</span> <span class="n">comment</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">these</span> <span class="n">here</span><span class="o">.</span> <span class="n">Right</span> <span class="n">now</span> <span class="n">most</span> <span class="n">of</span> <span class="n">them</span> <span class="n">have</span> <span class="n">comments</span> <span class="n">throughout</span> <span class="n">the</span> <span class="n">code</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Reorganize</span> <span class="n">these</span> <span class="n">attributes</span> <span class="n">into</span> <span class="n">some</span> <span class="n">meaningful</span> <span class="n">structure</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.TrajectorySet">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">celltraj.trajectory_legacy.</span></span><span class="sig-name descname"><span class="pre">TrajectorySet</span></span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#TrajectorySet"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.TrajectorySet" title="Link to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>A toolset for single-cell trajectory modeling over multiple trajectory objects. See:</p>
<div class="admonition danger">
<p class="admonition-title">Danger</p>
<p>This code, currently, should be considered as an untested pre-release version</p>
</div>
<p class="rubric">References</p>
<p>Jeremy Copperman, Sean M. Gross, Young Hwan Chang, Laura M. Heiser, and Daniel M. Zuckerman.
Morphodynamical cell-state description via live-cell imaging trajectory embedding.
Biorxiv 10.1101/2021.10.07.463498, 2021.</p>
<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.TrajectorySet.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#TrajectorySet.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.TrajectorySet.__init__" title="Link to this definition"></a></dt>
<dd><p>Work-in-progress init function. For now, just start adding attribute definitions in here.
.. todo:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">-</span> <span class="n">Most</span> <span class="n">logic</span> <span class="kn">from</span><span class="w"> </span><span class="nn">initialize</span><span class="p">()</span> <span class="n">should</span> <span class="n">be</span> <span class="n">moved</span> <span class="ow">in</span> <span class="n">here</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Also</span><span class="p">,</span> <span class="n">comment</span> <span class="nb">all</span> <span class="n">of</span> <span class="n">these</span> <span class="n">here</span><span class="o">.</span> <span class="n">Right</span> <span class="n">now</span> <span class="n">most</span> <span class="n">of</span> <span class="n">them</span> <span class="n">have</span> <span class="n">comments</span> <span class="n">throughout</span> <span class="n">the</span> <span class="n">code</span><span class="o">.</span>
<span class="o">-</span> <span class="n">Reorganize</span> <span class="n">these</span> <span class="n">attributes</span> <span class="n">into</span> <span class="n">some</span> <span class="n">meaningful</span> <span class="n">structure</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.TrajectorySet.get_linear_batch_normalization">
<span class="sig-name descname"><span class="pre">get_linear_batch_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">feat1_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#TrajectorySet.get_linear_batch_normalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.TrajectorySet.get_linear_batch_normalization" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="celltraj.trajectory_legacy.TrajectorySet.get_linear_coef">
<span class="sig-name descname"><span class="pre">get_linear_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">countsA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">countsB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">countsAB</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/trajectory_legacy.html#TrajectorySet.get_linear_coef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.trajectory_legacy.TrajectorySet.get_linear_coef" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-celltraj.translate">
<span id="celltraj-translate-module"></span><h2>celltraj.translate module<a class="headerlink" href="#module-celltraj.translate" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="celltraj.translate.get_null_correlations">
<span class="sig-prename descclassname"><span class="pre">celltraj.translate.</span></span><span class="sig-name descname"><span class="pre">get_null_correlations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_fc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_fc_states</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x_fc_predicted</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nrandom</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">seed</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tmfSet</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/translate.html#get_null_correlations"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.translate.get_null_correlations" title="Link to this definition"></a></dt>
<dd><p>Calculate null correlations for predicted and real fold changes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_fc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Measured fold change matrix (conditions x genes).</p></li>
<li><p><strong>x_fc_states</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – State-specific fold change matrix (states x genes).</p></li>
<li><p><strong>x_fc_predicted</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Predicted fold change matrix (conditions x genes).</p></li>
<li><p><strong>nrandom</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of random permutations for generating null distributions (default is 500).</p></li>
<li><p><strong>seed</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Random seed for reproducibility (default is None).</p></li>
<li><p><strong>tmfSet</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Array of treatment names or identifiers (default is None).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>corrSet_pred</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Correlations between predicted and real fold changes for each condition.</p></li>
<li><p><strong>corrSet_rand</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Null correlations between randomly generated state probabilities and real fold changes.</p></li>
<li><p><strong>corrSet_predrand</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Null correlations between predicted fold changes and fold changes from randomly generated state probabilities.</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This function generates null distributions by randomly permuting state probabilities and calculating the
corresponding fold changes. The correlations between these null fold changes and the real/predicted fold changes
are computed to evaluate the significance of the predictions.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>  <span class="c1"># Example fold change data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_fc_states</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>  <span class="c1"># Example state-specific fold changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_fc_predicted</span> <span class="o">=</span> <span class="n">get_predictedFC</span><span class="p">(</span><span class="n">state_probs</span><span class="p">,</span> <span class="n">x_fc_states</span><span class="p">)</span>  <span class="c1"># Example predicted fold changes</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">corr_pred</span><span class="p">,</span> <span class="n">corr_rand</span><span class="p">,</span> <span class="n">corr_predrand</span> <span class="o">=</span> <span class="n">get_null_correlations</span><span class="p">(</span><span class="n">x_fc</span><span class="p">,</span> <span class="n">x_fc_states</span><span class="p">,</span> <span class="n">x_fc_predicted</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.translate.get_predictedFC">
<span class="sig-prename descclassname"><span class="pre">celltraj.translate.</span></span><span class="sig-name descname"><span class="pre">get_predictedFC</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">statesFC</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/translate.html#get_predictedFC"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.translate.get_predictedFC" title="Link to this definition"></a></dt>
<dd><p>Predict fold changes based on state probabilities and state-specific fold changes.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_probs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – State probability matrix (conditions x states).</p></li>
<li><p><strong>statesFC</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – State-specific fold change matrix (states x genes).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_FC_predicted</strong> – Predicted fold change matrix (conditions x genes).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># Example state probability data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">statesFC</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>  <span class="c1"># Example state-specific fold change data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">predicted_fc</span> <span class="o">=</span> <span class="n">get_predictedFC</span><span class="p">(</span><span class="n">state_probs</span><span class="p">,</span> <span class="n">statesFC</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.translate.get_state_decomposition">
<span class="sig-prename descclassname"><span class="pre">celltraj.translate.</span></span><span class="sig-name descname"><span class="pre">get_state_decomposition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x_fc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_probs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">npermutations</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">500</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inds_tm_training</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">save_file</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">visual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nchunk</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gene_names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lb</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ub</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/translate.html#get_state_decomposition"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.translate.get_state_decomposition" title="Link to this definition"></a></dt>
<dd><p>Decompose paired bulk average data (e.g. bulk RNAseq or gene expression measurement) into state-specific contributions using least squares optimization.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>x_fc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – Fold change matrix (samples x genes).</p></li>
<li><p><strong>state_probs</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>) – State probability matrix (samples x states).</p></li>
<li><p><strong>npermutations</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Number of permutations for training set decompositions (default is 500).</p></li>
<li><p><strong>inds_tm_training</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Indices of training set conditions (default is None).</p></li>
<li><p><strong>save_file</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code>, <em>optional</em>) – File path to save the state-specific fold changes (default is None).</p></li>
<li><p><strong>visual</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, visualizes the decomposition process (default is False).</p></li>
<li><p><strong>verbose</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code>, <em>optional</em>) – If True, provides detailed logs during the decomposition process (default is True).</p></li>
<li><p><strong>nchunk</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code>, <em>optional</em>) – Chunk size for logging and saving intermediate results (default is 100).</p></li>
<li><p><strong>gene_names</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Names of the genes (default is None).</p></li>
<li><p><strong>lb</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Lower bounds for the linear least squares optimization (default is None, which sets to zeros).</p></li>
<li><p><strong>ub</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code>, <em>optional</em>) – Upper bounds for the linear least squares optimization (default is None, which sets to infinity).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>x_fc_states</strong> – State-specific fold change matrix (states x genes).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></p>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>If the state corresponds to the same RNA level regardless of the ligand treatment, then the measured average fold change for gene <cite>g</cite> in condition <cite>t</cite> can be decomposed into a linear combination
of state-specific fold changes <cite>s_g</cite> and state probabilities <cite>p_t</cite>, such that:</p>
<div class="math notranslate nohighlight">
\[x_{tg} = \sum_{i=1}^{n} p_{ti} s_{ig}\]</div>
<p>where:
- <cite>x_{tg}</cite> is the measured fold change for gene <cite>g</cite> in condition <cite>t</cite>.
- <cite>p_{ti}</cite> is the probability of state <cite>i</cite> in condition <cite>t</cite>.
- <cite>s_{ig}</cite> is the state-specific fold change for state <cite>i</cite> and gene <cite>g</cite>.
- <cite>n</cite> is the number of states.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x_fc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">5000</span><span class="p">)</span>  <span class="c1"># Example fold change data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state_probs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># Example state probability data</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x_fc_states</span> <span class="o">=</span> <span class="n">get_state_decomposition</span><span class="p">(</span><span class="n">x_fc</span><span class="p">,</span> <span class="n">state_probs</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

</section>
<section id="module-celltraj.utilities">
<span id="celltraj-utilities-module"></span><h2>celltraj.utilities module<a class="headerlink" href="#module-celltraj.utilities" title="Link to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.colorbar">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">colorbar</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">mappable</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#colorbar"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.colorbar" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.dist">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">dist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">img2</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#dist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.dist" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.dist_to_contact">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">dist_to_contact</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">r</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#dist_to_contact"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.dist_to_contact" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_cdist">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_cdist</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prob1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_cdist"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_cdist" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_cdist2d">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_cdist2d</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prob1</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_cdist2d"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_cdist2d" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_cell_centers">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_cell_centers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">labels</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_cell_centers"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_cell_centers" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_dmat">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_dmat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_dmat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_dmat" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_dmat_vectorized">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_dmat_vectorized</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">x1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">x2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_dmat_vectorized"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_dmat_vectorized" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_linear_batch_normalization">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_linear_batch_normalization</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">feat0_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">feat1_all</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nbins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">return_coef</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">stdcut</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">5</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_linear_batch_normalization"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_linear_batch_normalization" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_linear_coef">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_linear_coef</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">counts0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">countsA</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">countsB</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">countsAB</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_linear_coef"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_linear_coef" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_meshfunc_average">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_meshfunc_average</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">faceValues</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">faceCenters</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">bins</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_meshfunc_average"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_meshfunc_average" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_pairwise_distance_sum">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_pairwise_distance_sum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tshift</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">contact_transform</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">r0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">d0</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">6</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">m</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">12</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_pairwise_distance_sum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_pairwise_distance_sum" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.get_tshift">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">get_tshift</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">centers1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">centers2</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist_function</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ntrans</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">10</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">dist_function_keys</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#get_tshift"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.get_tshift" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.load_dict_from_h5">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">load_dict_from_h5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h5file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#load_dict_from_h5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.load_dict_from_h5" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.recursively_load_dict_contents_from_group">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">recursively_load_dict_contents_from_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h5file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#recursively_load_dict_contents_from_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.recursively_load_dict_contents_from_group" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.recursively_save_dict_contents_to_group">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">recursively_save_dict_contents_to_group</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">h5file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dic</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#recursively_save_dict_contents_to_group"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.recursively_save_dict_contents_to_group" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.rescale_to_int">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">rescale_to_int</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">img</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">maxint=65535</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.uint16'&gt;</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#rescale_to_int"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.rescale_to_int" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="celltraj.utilities.save_dict_to_h5">
<span class="sig-prename descclassname"><span class="pre">celltraj.utilities.</span></span><span class="sig-name descname"><span class="pre">save_dict_to_h5</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dic</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">h5file</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">path</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="_modules/celltraj/utilities.html#save_dict_to_h5"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#celltraj.utilities.save_dict_to_h5" title="Link to this definition"></a></dt>
<dd></dd></dl>

</section>
<section id="module-celltraj">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-celltraj" title="Link to this heading"></a></h2>
<p>Top-level package for celltraj.</p>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2024, Jeremy Copperman.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>